<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>新sakura博客园皮肤配置,NewSakura</title>
      <link href="/2020/0814/"/>
      <url>/2020/0814/</url>
      
        <content type="html"><![CDATA[<h1 id="CNblogs-Theme-NewSakura"><a href="#CNblogs-Theme-NewSakura" class="headerlink" title="CNblogs-Theme-NewSakura"></a>CNblogs-Theme-NewSakura</h1><ul><li>基于Sakura美化方案改造的博客园样式：NewSakura</li><li>如使用了本样式，请给个Star。</li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><pre><code>CNblogs-Theme-NewSakura|├─ CNblogs-Theme-NewSakura│    ├─ foot.html 页脚代码│    ├─ main.css 自定义css代码│    ├─ main.js  引用js│    └─ sidebar.html 侧边栏代码├─ README.md└─ img       ├─ 效果1.JPG       └─ 效果2.JPG</code></pre><p> 有js权限，期间将侧边栏、页脚和css代码粘贴进博客园设置内即可！代码文件内有相应注释，根据它修改即可。</p><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>依次分重点：</p><ul><li>新增暗黑白昼模式，白天暗黑刺激</li><li>首页及随笔页头图随机切换</li><li>音乐播放器，使用Aplayer插件</li><li>看板娘，原先的主题已失效，现已修改</li><li>自动生成文章目录，基本功能</li><li>导航菜单子目录，照葫芦画瓢添加</li><li>图片灯箱、滚动进度条</li><li>文章打赏</li><li>鼠标点击粒子效果</li><li>其他网站链接，非必需</li><li>将首页底部不必要的滚动条去掉</li><li>修改了文章评论区的框框大小，原先的过大变形</li><li>暗黑白昼切换不影响评论区，暗黑字白，白昼字黑</li><li>修改了分类页面样式，为了在暗黑后看的清楚美观</li></ul><p>注意：目前Sakura还不支持响应式，所以还需大家帮忙喽！</p><h2 id="主题预览"><a href="#主题预览" class="headerlink" title="主题预览"></a>主题预览</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0ZWUuY29tL3VwbG9hZHMvaW1hZ2VzLzIwMjAvMDgxMi8xNTA3NTJfNzQ3NWIwNWZfNTcxODU3MC5qcGVn?x-oss-process=image/format,png" alt="效果1"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0ZWUuY29tL3VwbG9hZHMvaW1hZ2VzLzIwMjAvMDgxMi8xNTA3NDlfNTA0NWVjZTBfNTcxODU3MC5qcGVn?x-oss-process=image/format,png" alt="效果2"></p><h2 id="主题部署"><a href="#主题部署" class="headerlink" title="主题部署"></a>主题部署</h2><div class="info"><p>快速搭建出与本博客一样的样式，    请看下面这句说明，当然前提是得有<span style="color: red">js权限</span></p></div><p>部署和本博客一样的主题，请直接下载整个主题，对应的改下<strong>文件链接地址</strong> ，把<strong>css</strong>、<strong>侧边栏</strong>、<strong>页脚</strong>代码粘贴的你的博客后台就行。为了个性化定制，如果你想个性化定制博客，请往下看基本部署。</p><h3 id="基本部署"><a href="#基本部署" class="headerlink" title="基本部署"></a>基本部署</h3><ul><li><p>前提：已经开通<code>js</code>权限</p></li><li><p>设置皮肤选择自定义custom</p></li><li><p>引入样式<br>把<strong>main.css</strong>中的代码粘贴到自定义css中，无需个性化操作</p></li><li><p>引入文件<br>放在侧边栏html文件中，本人已为你添加。建议下载该文件并上传博客园，之后只需修改样式引入即可！</p><pre><code>&lt;script src=&quot;https://blog-static.cnblogs.com/files/coderma/main.js&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>顶部菜单设置</p><p>将以下链接替换成自己随笔地址，以下代码在<code>main.js</code>中,建议打开该文件查看并修改</p><pre><code>$(&quot;#navList&quot;).append(&#39;&lt;li&gt;&lt;a id=&quot;blog_nav_myyoulian&quot; class=&quot;menu&quot;href=&quot;https://www.cnblogs.com/coderma/p/1117239.html&quot;&gt;友链&lt;/a&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_myzanshang&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/coderma/p/1133477.html&quot;&gt;赞赏&lt;/a&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_myguanyu&quot; class=&quot;menu&quot; href=&quot;&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;&#39;);</code></pre></li><li><p>菜单icon设置<br>  就是菜单前的小图标，感兴趣的可以去了解一下<a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">Font awesome</a></p><pre class="line-numbers language-javascript"><code class="language-javascript">          <span class="token comment" spellcheck="true">//博客title</span>          <span class="token comment" spellcheck="true">//去掉rss替换成分类</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_rss'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span><span class="token string">'&lt;a id="blog_nav_fenlei" class="menu" href="https://www.cnblogs.com/coderma/p/13458241.html" target="_self">分类&lt;/a>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//可替换以下链接</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#navList"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'&lt;li>&lt;a id="blog_nav_myyoulian" class="menu" href="https://www.cnblogs.com/coderma/p/13413494.html" target="_self">友链&lt;/a>&lt;i>&lt;/i>&lt;/li>&lt;li>&lt;a id="blog_nav_myarchive" class="menu" href="https://www.cnblogs.com/coderma/p/13414527.html" target="_self">归档&lt;/a>&lt;i>&lt;/i>&lt;/li>&lt;li>&lt;a id="blog_nav_myguanyu" class="menu" >关于&lt;/a>&lt;/li>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//添加标签图标</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_sitehome'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-fort-awesome" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//博客园</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myhome'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-home" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//首页</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_newpost'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-edit" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//新随笔</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_contact'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-address-book-o" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//联系</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_fenlei'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-filter" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//分类</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_admin'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-cog" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//管理</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myyoulian'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//友链</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myarchive'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-archive" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//赞赏</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myguanyu'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-universal-access" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关于</span>          <span class="token comment" spellcheck="true">//添加li内嵌ui</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>菜单子目录设置</p><p>  菜单子目录，在<strong>关于</strong>菜单下添加了子目录,相应的样式可自行修改添加</p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token keyword">let</span> guanyu <span class="token operator">=</span> <span class="token string">'&lt;ul class="sub-menu">'</span> <span class="token operator">+</span>      <span class="token string">'&lt;li>&lt;a href=" " target="_self">&lt;i class="fa fa-user-o" aria-hidden="true">&lt;/i>博主&lt;/a>&lt;/li>'</span> <span class="token operator">+</span>   <span class="token comment" spellcheck="true">//添加关于文章链接</span>      <span class="token string">'&lt;li>&lt;a id="blog_nav_theme" onclick="changeTheme();" >&lt;i class="iconfont icon-taohua" aria-hidden="true">&lt;/i> 主题&lt;/a>&lt;/li>'</span> <span class="token operator">+</span>  <span class="token comment" spellcheck="true">//主题/暗黑白昼模式</span>      <span class="token string">'&lt;/ul>'</span><span class="token punctuation">;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myguanyu'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>guanyu<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本设置</p><p>为了配置方便，我在侧边栏里设置了一些常用参数，可根据下表选择需要开启和配置</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;   $.silence({      profile: {          enable: true,          avatar: &#39;https://images.cnblogs.com/cnblogs_com/coderma/1820127/o_200803093536logo.png&#39;, //头像，可修改          favicon: &#39;&#39;,          notice: &#39;个人博客地址：https://index.maliaoblog.cn/  欢迎大家来踩&#39;   //通知，可修改      },      catalog: {          enable: true,          move: true,          index: true,          level1: &#39;h2&#39;,          level2: &#39;h3&#39;,          level3: &#39;h4&#39;,      },      signature: {          enable: true,          home: &#39;https://www.cnblogs.com/coderma/&#39;,  //主页链接，可修改          license: &#39;CC BY 4.0&#39;,          link: &#39;https://creativecommons.org/licenses/by/4.0&#39;      },      sponsor: {          enable: true,          paypal: null,          wechat: &#39;&#39;,  //赞助，可修改图片链接          alipay: &#39;&#39;      },      github: {          enable: false,          color: &#39;#fff&#39;,          fill: &#39;#FF85B8&#39;,          link: &#39;https://github.com/coderxm&#39;  //可修改      },    topImg: {      homeTopImg: [    &quot;https://img2020.cnblogs.com/blog/2027366/202008/2027366-20200807133710823-1221571975.jpg&quot;,   //主页顶部图片，可修改                  ],            notHomeTopImg: [    &quot;https://img2020.cnblogs.com/blog/2027366/202008/2027366-20200807132804040-1889645361.jpg&quot;,  //可修改                  ]      },    topInfo: {          title: &#39;Hi,流浪舟&#39;,  //首页标题（可替换）          text: &quot;No one choose this life for me But I don&#39;t mind it&quot;,  //首页横幅语句          github: &quot;https://github.com/coderxm/&quot;,      //github(替换成相应链接)          weibo: &quot;&quot;,          telegram: &quot;&quot;,          music: &quot;&quot;,          twitter: &quot;&quot;,          zhihu: &quot;&quot;,          mail: &quot;&quot;,      }         });&lt;/script&gt;</code></pre><p>参数说明表：</p><table><thead><tr><th align="left">模块</th><th>属性</th><th>说明</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td align="left">profile（基础信息）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>true</td></tr><tr><td align="left"></td><td>avatar</td><td>作者头像</td><td>String</td><td></td></tr><tr><td align="left"></td><td>favicon</td><td>网站标题图标</td><td>String</td><td></td></tr><tr><td align="left"></td><td>notice</td><td>公告</td><td>String</td><td>感谢使用该主题</td></tr><tr><td align="left"></td><td>authorName</td><td>作者姓名</td><td>String</td><td>coderxm</td></tr><tr><td align="left">catalog（博文目录）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>false</td></tr><tr><td align="left"></td><td>move</td><td>是否允许拖拽</td><td>Boolean</td><td>true</td></tr><tr><td align="left"></td><td>index</td><td>是否显示索引</td><td>Boolean</td><td>true</td></tr><tr><td align="left"></td><td>level1</td><td>一级标题</td><td>String</td><td>h2</td></tr><tr><td align="left"></td><td>level2</td><td>二级标题</td><td>String</td><td>h3</td></tr><tr><td align="left"></td><td>level3</td><td>三级标题</td><td>String</td><td>h4</td></tr><tr><td align="left">signature（博文签名）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>true</td></tr><tr><td align="left"></td><td>home</td><td>作者主页</td><td>String</td><td><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">https://www.cnblogs.com</a></td></tr><tr><td align="left"></td><td>license</td><td>许可证名称</td><td>String</td><td>CC BY 4.0</td></tr><tr><td align="left"></td><td>link</td><td>许可证链接</td><td>String</td><td><a href="https://creativecommons.org/licenses/by/4.0" target="_blank" rel="noopener">https://creativecommons.org/licenses/by/4.0</a></td></tr><tr><td align="left">sponsor（博文赞赏）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>false</td></tr><tr><td align="left"></td><td>paypal</td><td>PayPal 收款地址</td><td>String</td><td>null</td></tr><tr><td align="left"></td><td>alipay</td><td>支付宝收款二维码</td><td>String</td><td>null</td></tr><tr><td align="left"></td><td>wechat</td><td>微信收款二维码</td><td>String</td><td>null</td></tr><tr><td align="left">github（GitHub Corners）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>false</td></tr><tr><td align="left"></td><td>fill</td><td>背景填充色</td><td>String</td><td>[Silence Theme Color]</td></tr><tr><td align="left"></td><td>color</td><td>章鱼猫颜色</td><td>String</td><td>#fff</td></tr><tr><td align="left"></td><td>link</td><td>Github 链接</td><td>String</td><td>null</td></tr><tr><td align="left">topImg（头图）</td><td>homeTopImg</td><td>首页头图</td><td>Array</td><td></td></tr><tr><td align="left"></td><td>notHomeTopImg</td><td>文章和随笔页头图</td><td>Array</td><td></td></tr><tr><td align="left">topInfo(首页头图信息)</td><td>titile</td><td>头部标题</td><td>String</td><td>Hi, 流浪舟!</td></tr><tr><td align="left"></td><td>text</td><td>横幅标题</td><td>String</td><td>No one choose this life for me But I don’t mind it</td></tr></tbody></table></li></ul><p>配置完成后，记得点击「保存」按钮。 </p><h2 id="个性化定制"><a href="#个性化定制" class="headerlink" title="个性化定制"></a>个性化定制</h2><h3 id="新增暗黑白昼模式"><a href="#新增暗黑白昼模式" class="headerlink" title="新增暗黑白昼模式"></a>新增暗黑白昼模式</h3><p>开始的时候是暗黑的，在<strong>关于</strong>下的子菜单栏内，点击主题可切换成白昼模式。 </p><h3 id="菜单新增分类、友链、博主、归档栏"><a href="#菜单新增分类、友链、博主、归档栏" class="headerlink" title="菜单新增分类、友链、博主、归档栏"></a>菜单新增分类、友链、博主、归档栏</h3><p>原理简单，只需先新建随笔即可，并替换链接，点击便可跳转到相应页面。关于分类，去掉了过去的RSS，换成博客园已有的分类，同样的方法，将所有分类链接收录到某一随笔中即可，随笔链接即是分类栏链接。博主一栏写你的信息，归档类似，我相信这样的问题难不倒有大智慧的你！</p><h3 id="首页及文章大图"><a href="#首页及文章大图" class="headerlink" title="首页及文章大图"></a>首页及文章大图</h3><p>首页和随笔以及文章页的头图都是随机切换的，添加图片在侧边栏html配置中。这里类型为随笔的时候头部会显示<strong>标题</strong>、<strong>头像</strong>、<strong>作者</strong>、<strong>发布时间</strong>、<strong>阅读数</strong>，而类型为文章的时候只会显示标题，根据情况选择类型发布。<br>请尽量选择像素1920*1080px的高清大图，这样的话首页图片会更适合。</p><h3 id="随笔预览图"><a href="#随笔预览图" class="headerlink" title="随笔预览图"></a>随笔预览图</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0ZWUuY29tL3VwbG9hZHMvaW1hZ2VzLzIwMjAvMDgxMi8xNTA3NDlfNTA0NWVjZTBfNTcxODU3MC5qcGVn?x-oss-process=image/format,png" alt="预览"></p><p>在写随笔或者文章的时候添加摘要图片和摘要文字，<strong>摘要文字一定要添加</strong>，如果不添加摘要图片会给一张默认图片。</p><h3 id="回顶部钩子"><a href="#回顶部钩子" class="headerlink" title="回顶部钩子"></a>回顶部钩子</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//回到顶部特效</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`&lt;a href="#" class="cd-top faa-float animated cd-fade-out" target="_self">&lt;/a>`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> $win <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> oldScrollY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        $win<span class="token punctuation">.</span><span class="token function">scroll</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            oldScrollY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scrollY<span class="token punctuation">;</span>                <span class="token keyword">let</span> height <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>            <span class="token keyword">let</span> top <span class="token operator">=</span> <span class="token string">'-'</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">900</span> <span class="token operator">-</span> height <span class="token operator">+</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldScrollY <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.cd-top'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'top'</span><span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span>                     <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.cd-top'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'top'</span><span class="token punctuation">,</span> <span class="token string">'-900px'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="公告"><a href="#公告" class="headerlink" title="公告"></a>公告</h3><p>公告内容修改在侧边栏基础信息配置中，修改<code>notice</code>，代码中已有提示</p><h3 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h3><p>我个人博客的看板娘是引用别人的，同一个，失效了会及时修复的！将以下代码添加到页脚，当然本人又已经为你添加好了，所以过程非常轻松！</p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h3><p>相信看过我以前文章的同学对这个一定不会陌生，怎么获取id我也不在这里罗嗦了，可以去找我的文章，获取到id之后把下面的id替换掉就可以了！</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://blog-static.cnblogs.com/files/zouwangblog/APlayer.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/meting@1.2/dist/Meting.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>player<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aplayer aplayer-withlist aplayer-fixed<span class="token punctuation">"</span></span> <span class="token attr-name">data-id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7660234225<span class="token punctuation">"</span></span> <span class="token attr-name">data-server</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tencent<span class="token punctuation">"</span></span> <span class="token attr-name">data-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>playlist<span class="token punctuation">"</span></span> <span class="token attr-name">data-order</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>random<span class="token punctuation">"</span></span> <span class="token attr-name">data-fixed</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">data-listfolded</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">data-theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orangered<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- end --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="博客logo"><a href="#博客logo" class="headerlink" title="博客logo"></a>博客logo</h3><p>左上角的logo，修改文字需要到<code>main.js</code>里找到以下代码，替换文字即可，如果不喜欢可以注掉,我也觉得没啥好看，main.js里我已经删了！</p><pre class="line-numbers language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> title <span class="token operator">=</span> <span class="token string">'&lt;div class="site-branding">'</span> <span class="token operator">+</span>                    <span class="token string">'&lt;span class="logolink moe-mashiro">'</span> <span class="token operator">+</span>                    <span class="token string">'&lt;ruby>&lt;span class="sakuraso">漂泊&lt;/span>&lt;span class="no">的&lt;/span>&lt;span class="shironeko">流浪舟&lt;/span>'</span> <span class="token operator">+</span>                    <span class="token string">'&lt;rt class="chinese-font">漂泊的流浪舟&lt;/rt>&lt;/ruby>&lt;/a>&lt;/span>'</span> <span class="token operator">+</span>                    <span class="token string">'&lt;/div>'</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="页面滚动进度条"><a href="#页面滚动进度条" class="headerlink" title="页面滚动进度条"></a>页面滚动进度条</h3><p>页面滚动的时候会在顶部出现一个橙色的进度条，修改颜色到页面css里，找到以下代码修改<code>background</code></p><pre><code>.scrollCls {    position: fixed;    top: 0;    height: 3px;    background: orange;    transiton-property: width,background;    transition-duration: 1s,1s;    z-index: 99999;}</code></pre><h3 id="首页个人信息"><a href="#首页个人信息" class="headerlink" title="首页个人信息"></a>首页个人信息</h3><ul><li><p>名称<br>在侧边栏配置中修改<code>topInfo</code>里的<code>title</code></p></li><li><p>座右铭（横幅标题）<br>在侧边栏配置中修改<code>topInfo</code>里的<code>text</code></p></li><li><p>其他网站链接(已注释，大都是推特等国外app，影响美观)<br>在侧边栏配置中修改<code>topInfo</code>里对应的链接地址</p></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最近在博客园和皮肤厮混，发现没几个满意的！这让我追求精致的心受到了打击，最开始用的是这个，后来换了，不过换之前改进了一些！最总发现移动端不行，所以干脆把项目弄到github上，让大家看看！我把这个美化分享了出去，以我目前的前端技术改造这么个样式也很费劲的，毕竟不是专业做前端的！这是我在博客园的一篇美化文章了，博客还是有很多改进的，希望采用这个样式的你能够多多支持，有什么问题都可以提交，我也会及时为大家解决!</p><h2 id="微信公众平台"><a href="#微信公众平台" class="headerlink" title="微信公众平台"></a>微信公众平台</h2><p>微信搜索 “小码之光” 关注，里面有加群，可以一起交流！</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/coderxm/CNblogs-Theme-NewSakura" target="_blank" rel="noopener">GitHub地址</a></p><p><a href="https://gitee.com/openkit/CNblogs-Theme-NewSakura" target="_blank" rel="noopener">Gitee地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sakura </tag>
            
            <tag> 博客园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery主题美化(三)-音乐播放器</title>
      <link href="/2020/0809/"/>
      <url>/2020/0809/</url>
      
        <content type="html"><![CDATA[<h4 id="hexo-matery主题美化-三-音乐播放器"><a href="#hexo-matery主题美化-三-音乐播放器" class="headerlink" title="hexo-matery主题美化(三)-音乐播放器"></a>hexo-matery主题美化(三)-音乐播放器</h4><h5 id="配置音乐播放器"><a href="#配置音乐播放器" class="headerlink" title="配置音乐播放器"></a>配置音乐播放器</h5><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Whether to display the musics.</span><span class="token comment" spellcheck="true"># 是否在首页显示音乐.</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> 非吸底模式有效  <span class="token key atrule">show</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">autoHide</span><span class="token punctuation">:</span> <span class="token boolean important">true    </span><span class="token comment" spellcheck="true"># hide automaticaly</span>  <span class="token key atrule">server</span><span class="token punctuation">:</span> tencent   <span class="token comment" spellcheck="true">#require    music platform: netease, tencent, kugou, xiami, baidu</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> playlist    <span class="token comment" spellcheck="true">#require song, playlist, album, search, artist</span>  <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">7660234225     </span><span class="token comment" spellcheck="true">#require    song id / playlist id / album id / search keyword</span>  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">true       </span><span class="token comment" spellcheck="true"># 开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false   </span><span class="token comment" spellcheck="true"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'blue'</span>     <span class="token comment" spellcheck="true">#歌词的颜色</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span>       <span class="token comment" spellcheck="true"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'random'</span>   <span class="token comment" spellcheck="true"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span>   <span class="token comment" spellcheck="true"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7       </span><span class="token comment" spellcheck="true"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">true  </span><span class="token comment" spellcheck="true"># 列表默认折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选：<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选：<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取示例: 打开网易云音乐，选择喜欢的歌单，然后点击分享,生成插件外链</p></blockquote><p>这就是歌单的id，文件里默认设置的歌单其实也还不错。如果以后继续添加歌曲，更新了歌单，我亲自试过，<code>Aplayer</code>插件也会更新，之前的16首现在加了三首有19首。看了一些人的文章，有的人说不会更新，不知道他有没有试过。对了，如果打开博客播放器插件加载不出来，可能是网速的原因，刷新一下就好，也有可能是没配置好，多看看文章就行。</p><p>参考资料：<br><a href="https://www.cnblogs.com/mfrank/p/12830097.html#autoid-0-4-0" target="_blank" rel="noopener">弗兰克的猫-hexo-matery主题配置</a></p><p><a href="https://www.cnblogs.com/fby698/p/12663089.html" target="_blank" rel="noopener">new落花-Aplayer插件</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery主题 </tag>
            
            <tag> 音乐播放器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery主题优化(二)</title>
      <link href="/2020/0806/"/>
      <url>/2020/0806/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo-matery主题优化-二"><a href="#hexo-matery主题优化-二" class="headerlink" title="hexo-matery主题优化(二)"></a>hexo-matery主题优化(二)</h3><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ul><li>hexo搜索</li><li>hexo代码高亮</li><li>消除文章toc目录的那一竖杠杠</li><li>去掉友链下那不必要的一栏空白</li><li>最后</li></ul><p>前段时间，我好像写过一篇文章讲hexo-matery主题的配置优化，隔了很久，自己都忘了，应该是第一次安装主题的时候。那现在有些一篇关于这样的文章帮助大家继续增强美化自己的博客，因为本人最近也在做这件事，搭博客已经3个月了，选了喜欢的主题，却还是有一点点不满意，虽然创建主题的都是大佬，但是也有瑕疵的地方。更头疼的是，到最后也没人来告诉我们怎么把我们的博客做的漂亮一点，还是要自己来亲手改改，直接弄成博客是自己亲生的一样！到时候也能吹吹！这次不介绍太多，怕一下弄不过来，主要就讲最近接触过的。</p><h4 id="hexo搜索"><a href="#hexo搜索" class="headerlink" title="hexo搜索"></a>hexo搜索</h4><p>如果你已经做了这个搜索可以跳过，没有就一起干！过程非常可乐，呃，是非常简单！前提是使用的是hexo主题，配置了相应的环境。主题最开始弄下来是没有搜索插件的，需要下载，接下来你懂的，用npm包管理工具下载插件(如果不会用，可以搜索相应的文章看看，有需要会专门讲一下npm是何物，不会有同学还没安装好npm吧？不会吧！不会吧！)。进入到当前博客根目录下，在命令行里：</p><pre class="line-numbers language-js"><code class="language-js">npm i hexo<span class="token operator">-</span>generator<span class="token operator">-</span>search <span class="token operator">-</span>s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就这样下好了！同时需要再当前根目录配置文件中添加配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#search</span><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hexo代码高亮"><a href="#hexo代码高亮" class="headerlink" title="hexo代码高亮"></a>hexo代码高亮</h4><p>还是不要用主题里的高亮了，enable就false掉，还是同样的“骚操作”，下一个代码高亮的插件，这里用hexo-prism-matery,相同的手法下载下来后，在根目录下的配置文件里添加：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>  <span class="token comment" spellcheck="true"># preprocess/realtime</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#default false</span>  <span class="token key atrule">custom_css</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="消除文章toc目录的那一竖杠杠"><a href="#消除文章toc目录的那一竖杠杠" class="headerlink" title="消除文章toc目录的那一竖杠杠"></a>消除文章toc目录的那一竖杠杠</h4><p>修改前是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20200806121739895.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="toc那一杠"><br>如果你发现文章的toc目录有一条竖杠，不好看，那么就去掉。之前toc目录一直是这样的，我也不想要了。做博客开始的时候发现了，没太在意，终究是影响了美观。现在就要把目录弄得正常点。来到主题目录下，找到source目录，找到lib目录，里面也是一些css和js文件。其中找到tocbot文件夹，打开它的css文件，找到toc-link::before</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.toc-link</span><span class="token pseudo-element">::before</span></span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token hexcode">#EEE</span><span class="token punctuation">;</span><span class="token property">content</span><span class="token punctuation">:</span><span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>inline-block<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>inherit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*left:0;*/</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span>-<span class="token number">1</span>px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*之前是2px*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面可能很乱，就一两行代码，找到后将width值改成0就行了。另外解析的文章目录不完整可能是标题有些不支持：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 是否激活文章 TOC 功能，并配置TOC支持选中哪些标题类型，这是全局配置。</span><span class="token comment" spellcheck="true"># 可以在某篇文章的 Front-matter 中再加上`toc: false`，使该篇文章关闭TOC目录功能</span><span class="token key atrule">toc</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">heading</span><span class="token punctuation">:</span> h2<span class="token punctuation">,</span> h3<span class="token punctuation">,</span> h4<span class="token punctuation">,</span> h5<span class="token punctuation">,</span> h6  <span class="token comment" spellcheck="true">#选中除h1以外的标题，之前没有h6</span>  <span class="token key atrule">collapseDepth</span><span class="token punctuation">:</span> <span class="token number">0 </span><span class="token comment" spellcheck="true"># 目录默认展开层级</span>  <span class="token key atrule">showToggleBtn</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 是否显示切换TOC目录展开收缩的按钮</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="去掉友链下那不必要的一栏空白"><a href="#去掉友链下那不必要的一栏空白" class="headerlink" title="去掉友链下那不必要的一栏空白"></a>去掉友链下那不必要的一栏空白</h4><p>修改前：</p><p><img src="https://img-blog.csdnimg.cn/20200806121702255.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="空白栏"><br>这个也简单，不必过于头疼！因为我已经改好了，直接卖就是了，白给不要钱！</p><pre><code>&lt;div class=&quot;card&quot;&gt;   &lt;!--&lt;div class=&quot;card-content&quot;&gt;        &lt;%- page.content %&gt;       &lt;/div&gt;--&gt; &lt;/div&gt;</code></pre><p>友链下的那栏不必要的空白着实凸显了它的不必要性，所以我们要去掉它。直接把它的代码给注释掉，找到layout文件夹下的friends.ejs文件。hexo引擎渲染该文件生成html文件，变成了友链页面，其中友链的那一片作为一个模块卡片，valine留言板及空白一栏也是，空白的就是什么也没有，很容易发现，注释即可。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>以后还会继续更新站点，如果想看总体的效果就访问我的网站吧！最近的美化优化了很多，变化也很大！如果想深入了解就上公众号吧，<strong>小码之光</strong>，加群交流也行。后续会持续跟大家讲博客美化。</p><hr><p>公众号：小码之光</p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery </tag>
            
            <tag> 博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-01网络模型</title>
      <link href="/2020/0730/"/>
      <url>/2020/0730/</url>
      
        <content type="html"><![CDATA[<h4 id="计算机网络——01网络模型"><a href="#计算机网络——01网络模型" class="headerlink" title="计算机网络——01网络模型"></a>计算机网络——01网络模型</h4><h5 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h5><ol><li><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6></li><li><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6></li><li><h6 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h6></li><li><h6 id="TCP确认机制"><a href="#TCP确认机制" class="headerlink" title="TCP确认机制"></a>TCP确认机制</h6></li><li><h6 id="连接与关闭"><a href="#连接与关闭" class="headerlink" title="连接与关闭"></a>连接与关闭</h6></li><li><h6 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h6></li><li><h6 id="TCP-ISO面向连接与无连接"><a href="#TCP-ISO面向连接与无连接" class="headerlink" title="TCP/ISO面向连接与无连接"></a>TCP/ISO面向连接与无连接</h6></li><li><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6></li></ol><h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现<strong>资源共享和信息传递的计算机系统</strong>。</p><h4 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h4><p>地理范围划分是一种大家都认可的通用网络划分标准。按这种标准可以把各种网络类型划分为<strong>局域网、城域网、广域网</strong>三种。最后讲一下互联网！</p><ul><li><p><strong>局域网</strong>：（Local Area Network，LAN）  通常我们常见的“LAN”就是指局域网，这是我们最常见、应用最广的一种网络。所谓局域网，那就是在局部地区范围内的网络，它所覆盖的地区范围较小。局域网在计算机数量配置上没有太多的限制，少的可以只有两台，多的可达几百台。一般来说在企业局域网中，工作站的数量在几十到两百台次左右。在网络所涉及的地理距离上一般来说可以是几米至10公里以内。这种网络的特点就是：连接范围窄、用户数少、配置容易、连接速率高。目前局域网最快的速率要算现今的10G以太网了。IEEE的802标准委员会定义了多种主要的LAN网：以太网（Ethernet）、令牌环网（Token Ring）、光纤分布式接口网络（FDDI）、异步传输模式网（ATM）以及最新的无线局域网（WLAN）。</p></li><li><p><strong>城域网</strong>：（Metropolitan Area Network，MAN）  这种网络一般来说是在一个城市，但不在同一地理小区范围内的计算机互联。这种网络的连接距离可以在10-100公里，它采用的是IEEE802.6标准。MAN与LAN相比扩展的距离更长，连接的计算机数量更多，在地理范围上可以说是LAN网络的延伸。在一个大型城市或都市地区，一个MAN网络通常连接着多个LAN网。如连接政府机构的LAN、医院的LAN、电信的LAN、公司企业的LAN等等。</p></li><li><p><strong>广域网</strong>：(Wide Area Network，WAN）  这种网络也称为远程网，所覆盖的范围比城域网（MAN）更广，它一般是在不同城市之间的LAN或者MAN网络互联，地理范围可从几百公里到几千公里。因为距离较远，信息衰减比较严重，所以这种网络一般是要租用专线，通过IMP（接口信息处理）协议和线路连接起来，构成网状结构。这种城域网因为所连接的用户多，总出口带宽有限，所以用户的终端连接速率一般较低，通常为9.6Kbps-45Mbps 如：邮电部的CHINANET，CHINAPAC，和CHINADDN网。</p></li><li><p><strong>互联网</strong>：（internet）指的是网络之间所串连成的最大网络，这些网络以一组通用的协议相连，形成逻辑上的大型国际网络，始于1969年美国的阿帕网。通常internet泛指互联网，而<strong>Internet</strong>则特指因特网(国际互联网)。因特网于1969年诞生于美国，最初名为“阿帕网”(ARPAnet）是一个军用研究系统 ，采用TCP/IP协议，现在则已发展成为一个覆盖五大洲多个国家的开放型全球计算机网络系统。</p></li></ul><h4 id="三、网络分层"><a href="#三、网络分层" class="headerlink" title="三、网络分层"></a>三、网络分层</h4><p>为什么要分层？在计算机之间通信，主要是为了发送一些数据信息，一台计算机把数据发送出去，首先要让网络识别目的主机，能够找到它；明确目的主机是否连接网络；机子上的应用是否打开准备接收数据以及相应的异常处理。让我们去处理的话，会怎么解决这些问题呢？这里建立了两种模型：</p><p><strong>OSI七层模型</strong>：亦称OSI（Open System Interconnection）。参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。</p><p><img src="https://img-blog.csdnimg.cn/20200730171144919.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="协议栈"></p><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层:"></a>应用层:</h5><p>网络服务与最终用户的一个接口。</p><p>协议有：HTTP FTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</p><h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层:"></a>表示层:</h5><p>数据的表示、安全、压缩。</p><p>格式有，JPEG、ASCll，加密格式等</p><h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层:"></a>会话层:</h5><p>建立、管理、终止会话，对应主机进程，指本地主机与远程主机正在进行的会话</p><h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层:"></a>传输层:</h5><p>定义传输数据的协议<strong>端口号</strong>，以及流控和差错校验。</p><p>协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</p><h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层:"></a>网络层:</h5><p>网络层的主要工作是定义网络地址、区分网段、子网内MAC寻址、对于不同子网的数据包进行路由</p><p>协议有：ICMP（因特网控制报文协议）  IP（IPV4 IPV6）  ARP地址解析   Routing路由协议</p><h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层:"></a>数据链路层:</h5><p>建立逻辑连接、进行硬件地址寻址、差错校验等功能，将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p><p>协议有：Ethernet  PPP</p><h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层:"></a>物理层:</h5><p>建立、维护、断开物理连接，比特传输。</p><p><strong>TCP/IP模型</strong>：(Transmission Control Protocol / Internet Protocol，传输控制协议/网络互联协议）是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议，由IETF国际互联网工程任务组的RFC 793  定义。<br><img src="https://img-blog.csdnimg.cn/20200730171822546.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="基本五层模型"><br>TCP/IP模型合并了前三层为应用层，应用层定义了各种各样的协议来规范数据格式，常见的在HTTP的Header请求头中，分别定义了请求数据格式Accept和响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理。而链路层定义了主机的身份，即MAC地址，而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。</p><p>因为数据链路层和物理层的内容相差不多，所以在TCP/IP协议中它们被归并在网络接口层次里。只有四层体系结TCP/IP协议，与有七层体系结构的OSI相比要简单了不少，也正是这样，TCP/IP协议在实际的应用中效率更高，成本更低 。</p><p><strong>ARP协议</strong>（网络层）：</p><p>即地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下：ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p><strong>路由协议</strong>：</p><p>首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。而完成这个路由协议的物理设备就是路由器，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。 </p><h4 id="四、TCP确认机制"><a href="#四、TCP确认机制" class="headerlink" title="四、TCP确认机制"></a>四、TCP确认机制</h4><p>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 </p><ul><li>在数据正确性与合法性上，TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和；同时可以使用MD5认证对数据进行加密。</li><li>在保证可靠性上，采用超时重传和捎带确认机制。</li><li>在流量控制上，采用滑动窗口协议，协议中规定，对于窗口内未经确认的分组需要重传。</li></ul><p>在拥塞控制上，采用TCP拥塞控制算法（也称AIMD算法）。该算法主要包括四个主要部分：</p><p>（1）慢启动</p><p>每当建立一个TCP连接时或一个TCP连接发生超时重传后，该连接便进入慢启动阶段。进入慢启动后，TCP实体将拥塞窗口的大小初始化为一个报文段，此后，每收到一个报文段的确认（ACK），拥塞窗口cwnd（congestion window）按指数增加。当cwnd值超过慢启动阐值或发生报文段丢失重传时，慢启动阶段结束。前者进入拥塞避免阶段，后者重新进入慢启动阶段。</p><p>（2）拥塞避免</p><p>在慢启阶段，当cwnd值超过慢启动阐值后，慢启动过程结束，TCP连接进入拥塞避免阶段。在拥塞避免阶段，每一次发送的cwnd个报文段被完全确认后，才将cwnd值加1。在此阶段，cwnd值线性增加。</p><p>（3）快速重传</p><p>快速重传是对超时重传的改进。当源端收到对同一个报文的三个重复确认时，就确定一个报文段已经丢失，因此立刻重传丢失的报文段，而不必等到重传定时器（RTO）超时。以此减少不必要的等待时间。</p><p>（4）快速恢复</p><p>快速恢复是对丢失恢复机制的改进。在快速重传之后，不经过慢启动过程而直接进入拥塞避免阶段。每当快速重传后，置sshtesrh=cwnd/2、ewnd=ssthresh+3。此后，每收到一个重复确认，将cwnd值加1，直至收到对丢失报文段和其后若干报文段的累积确认后，置cwnd=ssthesrh，进入拥塞避免阶段。</p><h4 id="五、连接与关闭"><a href="#五、连接与关闭" class="headerlink" title="五、连接与关闭"></a>五、连接与关闭</h4><h4 id="建立连接："><a href="#建立连接：" class="headerlink" title="建立连接："></a>建立连接：</h4><p>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN同步序列编号数据包连接请求后，等待对方回答</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvMjkzODFmMzBlOTI0Yjg5OWNiMzJmNjMxNmUwNjFkOTUwYTdiZjZhOQ?x-oss-process=image/format,png" alt="图2 TCP的三次握手"><br>SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。 </p><p>TCP三次握手的过程如下：</p><ol><li>客户端发送SYN（SEQ=x序列号）报文给服务器端，进入SYN_SEND状态。</li><li>服务器端收到SYN报文，回应一个SYN （SEQ=y）+ ACK（ACK=x+1）报文，进入SYN_RECV状态。</li><li>客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入已连接状态。</li></ol><p>三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</p><h4 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止:"></a>连接终止:</h4><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。如下图所示。 </p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvYTFlYzA4ZmE1MTNkMjY5NzIxY2M4NzU0NTVmYmIyZmI0MzE2ZDg5OA?x-oss-process=image/format,png" alt="图3 TCP连接的终止"><br>（1） 某个应用进程首先调用close，称该端执行“主动关闭”。该端的TCP于是发送一个FIN结束标志数据包，表示数据发送完毕。</p><p>（2） 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认，发送ACK数据包。</p><p><strong>注意</strong>：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因此，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</p><p>（3） 此时两者之间能够继续互相发送数据包，然而一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字，这导致它的TCP也发送一个FIN。</p><p>（4） 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）ACK确认这个FIN。既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。</p><p><strong>注意</strong>：<br>当一个进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。</p><h4 id="六、TCP和UDP"><a href="#六、TCP和UDP" class="headerlink" title="六、TCP和UDP"></a>六、TCP和UDP</h4><ul><li><p>TCP 是面向<strong>连接</strong>的传输控制协议，而UDP 提供了<strong>无连接</strong>的数据报服务；</p></li><li><p>TCP 具有确认机制，确保传输数据的正确性，很少出现丢失或乱序；</p></li><li><p>UDP  在传输数据前不建立连接，不对数据报进行查改，无须等待对方的应答，会出现分组丢失、重复、乱序；</p></li><li><p>UDP 具有较好的<strong>实时性</strong>，工作效率较 TCP 协议高；</p></li><li><p>UDP 段结构比 TCP 的<strong>段结构简单</strong>，因此网络开销也小。</p></li></ul><p>TCP  协议可以保证接收端毫无差错地接收到发送端发出的字节流，为应用程序提供可靠的通信服务。对可靠性要求高的通信系统往往使用 TCP 传输数据，比如  HTTP 运用 TCP 进行数据的传输。</p><h4 id="七、TCP、ISO模型"><a href="#七、TCP、ISO模型" class="headerlink" title="七、TCP、ISO模型"></a>七、TCP、ISO模型</h4><p><strong>面向连接与无连接</strong>，面向连接可以分为三个阶段：</p><ol><li>发出链接，建立连接</li><li>连接成功才开始传输</li><li>数据传输完毕，必须释放连接</li></ol><p>无连接直接进行数据传输。<br><img src="https://img-blog.csdnimg.cn/2020073017151443.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="模型对比"><br>TCP/IP模型减少了会话层，表示层，可以变成经典5层网络模型，TCP/IP协议能够迅速发展起来并成为事实上的标准，是它恰好适应了世界范围内数据通信的需要。它有以下<br>特点：</p><p>（1）协议标准是完全开放的，可以供用户免费使用不收费。<br>（2）独立于网络硬件系统，可以运行在广域网，更适合于互联网。<br>（3）网络地址IP统一分配，网络中每一设备和终端都具有一个唯一MAC物理地址。</p><p><strong>对比</strong>：OSI层次间存在严格的调用关系，两个层通信必须通过下一层，不能越级，而TCP/IP可以越过下一层，直接使用更低层次所提供的服务，因而减少了一些不必要的开销，提高了效率；TCP/IP协议先出现，之后建立模型，而ISO/OSI先建立模型，后有协议。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>讲了这么多，那么重点在哪呢？在目录三开始的网络分层到最后的TCP/OSI模型对比，分层就记住TCP/IP经典五层模型和各层的协议就行了，其实四层的更好记住，四层无非是应用的服务层、传输层(弄端口号的)、网络层(弄网络IP地址，获取MAC地址及路由寻找的)，接口层（偏向物理的，定义MAC地址，将比特组装成帧进行发送）。有个概念就行，另外TCP确认机制(拥塞控制机制)需要掌握，以及TCP连接和断开的握手机制，还有TCP\UDP和TCP\ISO模型对比都是重点，需要掌握。</p><p>模型对比，分层就记住TCP/IP经典五层模型和各层的协议就行了，其实四层的更好记住，四层无非是应用的服务层、传输层(弄端口号的)、网络层(弄网络IP地址，获取MAC地址及路由寻找的)，接口层（偏向物理的，定义MAC地址，将比特组装成帧进行发送）。有个概念就行，另外TCP确认机制(拥塞控制机制)需要掌握，以及TCP连接和断开的握手机制，还有TCP\UDP和TCP\ISO模型对比都是重点，需要掌握。</p><p>硬核！肝完了！^  _  ^</p><hr><p>公众号：小码之光（文章全部首发）<br><a href="https://github.com/coderxm" target="_blank" rel="noopener">github</a> coderxm</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络模型 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的内部类</title>
      <link href="/2020/0728/"/>
      <url>/2020/0728/</url>
      
        <content type="html"><![CDATA[<h3 id="java中的内部类"><a href="#java中的内部类" class="headerlink" title="java中的内部类"></a>java中的内部类</h3><h4 id="一、内部类及访问特点"><a href="#一、内部类及访问特点" class="headerlink" title="一、内部类及访问特点"></a>一、内部类及访问特点</h4><p>1:内部类概述:把类定义在其他类的内部，这个类就被称为内部类。<br>    理解：内部类不需要被其他外部类调用，所以内部类定义在外部类里边，连成一块<br>2:内部类访问特点<br>    a:内部类可以直接访问外部类的成员，包括私有。<br>    b:外部类要访问内部类的成员，必须创建对象。</p><h4 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h4><p>分类：<br>    成员位置:在成员位置定义的类，被称为成员内部类（不在方法里），又分为静态和非静态<br>    局部位置:在局部位置定义的类，被称为局部内部类（在方法里）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//成员内部类</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//局部内部类</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三、成员内部类的修饰"><a href="#三、成员内部类的修饰" class="headerlink" title="三、成员内部类的修饰"></a>三、成员内部类的修饰</h4><p>成员内部类：</p><ul><li>可以被static修饰(外部类不行)</li><li>被四种访问权限修饰(public private default protected)</li><li>被abstract修饰，不能被实例化</li></ul><p><strong>私有成员内部类</strong>：对于成员内部类得私有使用，<strong>private</strong>，只能被当前类的方法访问，所以可以在外部类创建一个方法，创建内部类对象然后使用内部类方法。</p><h4 id="四、静态和非静态成员内部类及使用"><a href="#四、静态和非静态成员内部类及使用" class="headerlink" title="四、静态和非静态成员内部类及使用"></a>四、静态和非静态成员内部类及使用</h4><p>静态和非静态有什么区别呢？非静态的成员内部类，如果使用比较缸的方式创建对象的话，也是new 类名()，确实会有误解，当然我们平时实例化的时候就是这么干的，不过这里不允许。<br><img src="https://img-blog.csdnimg.cn/20200728200739425.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="非静态"></p><p>而静态成员内部类却依旧保持着原来的做法，像类访问成员一样，调用其构造器创建内部类对象，同样的如果采用非静态类的方法创建对象也不行，new ().new ()也会报错！所以各自只有唯一的方法来创建对象，以免混淆！</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//静态static内部类测试        </span>        Outer<span class="token punctuation">.</span>Inner1 oi1 <span class="token operator">=</span> <span class="token keyword">new</span>  <span class="token class-name">Outer<span class="token punctuation">.</span>Inner1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oi1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//普通内部类测试：访问内部类成员需要创建对象        </span>        Outer<span class="token punctuation">.</span>Inner2 oi2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oi2<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            oi2<span class="token punctuation">.</span><span class="token function">outereat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//另一个外部类</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Outer吃饭啊_内部类调用外部内方法测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//静态static内部类     </span>     <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner1</span><span class="token punctuation">{</span>         <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"说话啊_静态static内部类测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//普通非静态成员内部类 </span>     <span class="token keyword">class</span> <span class="token class-name">Inner2</span><span class="token punctuation">{</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inner3吃饭啊_普通内部类测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                              <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">outereat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Outer<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//内部类获取外部类成员，采用 外部类名.this.外部类成员    </span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非静态内部类获取外部类成员，采用 <strong>外部类名.this.外部类成员</strong>，外部类成员无论哪种修饰也能进行访问。但是静态的成员内部类就惨了点，它不能通过这种方法获取外部类成员。原因是Static在类加载时就已经存在了，但是对象是在创建时才在内存中生成，而this指代的是当前的对象。在静态类里使用this的话，那么this指向的是哪个对象呢？<br><img src="https://img-blog.csdnimg.cn/20200728200849656.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="静态"></p><p> 静态方法是存放在内存中的数据段里，this和super调用的是堆空间里的应用对象不能调用数据段区域里的数据，因此静态方法中不能用this和super关键字，否则会报错。那为什么要分静态和非静态呢？静态使用起来方便，符合原本的创建对象的逻辑：外部类.静态内部类；</p><p><img src="https://img-blog.csdnimg.cn/20200728200828755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="内存图"></p><h4 id="五、局部内部类及使用"><a href="#五、局部内部类及使用" class="headerlink" title="五、局部内部类及使用"></a>五、局部内部类及使用</h4><p>定义在类的<strong>方法中的类</strong>，局部内部类在访问他所在的方法中的局部变量时必须用finnal修饰，因为方法结束后就弹栈了，变量也弹出去了，但是类还在堆里，还要用到变量，所以加个finnal将变量放到方法区常量池里（<strong>jdk1.8不需要加finnal了，默认添加finnal</strong>）</p><p><strong>局部内部类</strong>：（在外部类的方法里创建内部类的对象，外部类方法才能调用内部类方法）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Outer out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//另一个类</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//外部类方法</span>         <span class="token keyword">int</span>  num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//内部类</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//在外部类的方法里创建内部类的对象，外部类方法才能调用内部类方法</span>        Inner i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>匿名内部类：</strong>（特殊的局部内部类，也是局部内部类的一种，必须写在方法里，本质是一个继承了该类（一般是抽象类）或者实现了该接口的子类匿名对象）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyInterface1 myInterface1 <span class="token operator">=</span> <span class="token keyword">new</span>  <span class="token class-name">MyInterface1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你真秀！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//注意这里的分号，new开始到这里是一个语句;</span>        myInterface1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//接口</span><span class="token keyword">interface</span> <span class="token class-name">MyInterface1</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里虽然有一个名字myInterface1，但它是接口对象名，不是类名。其中你可以改写成：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">new</span>  <span class="token class-name">MyInterface1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你真秀！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//注意这里的分号，new开始到这里是一个语句;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就啥名字也没有了！可能会有警告，不过没关系，照样跑！但如果你还学过lamda表达式的话就更好了：</p><pre class="line-numbers language-Java"><code class="language-Java">((MyInterface1) () -> System.out.println("你真秀！")).show();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分号就不容易漏了，一句话解决！你真秀！</p><hr><p>公众号：小码之光（文章全部首发）<br><a href="https://index.maliaoblog.cn/" target="_blank" rel="noopener">个人网站</a>  流浪舟引导<br><a href="https://github.com/coderxm" target="_blank" rel="noopener">github</a> coderxm</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据结构介绍了解</title>
      <link href="/2020/0725/"/>
      <url>/2020/0725/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：coderxm 小码<br><strong>公众号：小码之光</strong></p></blockquote><p><strong>数据结构：反应数据之间的关系，物理或逻辑上的关系。</strong></p><p>有两个角度看数据结构：逻辑结构和存储结构。逻辑结构是指数据之间的逻辑关系，有没有联系。而存储结构才是重点，数据怎么存？存成什么样？有顺序、链式、散列存储等，不过主要研究顺序和链式存储等方式，并对他们的运算进行了解。什么是顺序和链式？其实不难理解，就是容易忘(滑稽)！两者都要从逻辑和存储上看。</p><blockquote><p>顺序结构：逻辑上是连续的，即可以通过任意一节点元素找到该数据元素；存储上，就是物理地址是也是相邻的，连在一块。比如顺序表。</p><p>链式结构：逻辑上同理；但是物理存储地址却不是连在一块的。比如线性链表。</p></blockquote><p>那不是还有线性和非线性结构吗？这个是什么角度呢？从数据的存储方式看，分为线性和非线性。线性结构或者叫线性表，指一个数据结构中的每个节点最多有一个前驱或后继(指向作用)，则为线性表，可以看作连续线状结构。非空的线性表有以下特征：</p><ul><li>只有一个前节点，或头节点，无前件。</li><li>只有一个尾节点，无后件</li><li>其他节点只有一个前件和后件</li></ul><p>那么常见的线性表有这么几个：数组、栈、队列、线性链表；而相应的非线性线性表有树、二叉树、图等等。</p><h4 id="常见数据类型介绍："><a href="#常见数据类型介绍：" class="headerlink" title="常见数据类型介绍："></a>常见数据类型介绍：</h4><p>数组：这个好理解，连续的嘛！一维数组，可以通过下标找到你，而且定义一个数组，在内存上是相邻的一块，非常符合线性表的概念。</p><p>栈：特殊一点，操作都在一端进行，这端或这头叫栈顶top，相反，另一端则为栈底bottom。如果为空的话叫空栈，特点就是：FILO(first in ,last out)</p><p><img src="https://img-blog.csdnimg.cn/20200724122128537.jpg#pic_center" alt="栈"></p><ul><li>先进后出，后进先出</li><li>插入删除操作都是在栈顶进行</li><li>不像线性表，插入删除操作不需要移动栈内其他元素</li></ul><p>插入栈内为入栈或压栈，退出为出栈或退栈，读取就是将栈顶元素读取。</p><p>队列：一端插入，另一端退出删除。遵循FIFO，先进先出。那么哪里是头？哪里是尾呢？想象一下一列火车穿过隧道，火车头先进入隧道，然后尾部(Front)后进入。所以原理类似，在队尾(Rear)进行插入，在队头进行删除。</p><p><img src="https://img-blog.csdnimg.cn/20200724122146284.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="队列"></p><p>树：非线性的，是可以分支和划分层次的，由n(n&gt;=0)个结点构成，树的结点应该满足以下条件：</p><ul><li>只有一个没前驱的节点为根</li><li>其余结点可以构成子树</li><li>没有子结点的为叶子结点，其余为分支点或内点</li></ul><p>一个结点的前件为父结点，后件为孩子结点，有子节点个数多少为度。结点中最大的度为树的度，最大的层数为树的深度。</p><p>二叉树：通常由一个结点和左右子树构成，每一个结点最多有两个子结点。</p><p>满二叉树：除最后一层外，每一层上的结点都有两个子节点，从第一层开始数到n层，第k层有2的n减一次方个结点，共2的n次方减一个结点。（国内是这么定义的，国外则不是，国外定义为一棵二叉树的结点要么是叶子结点，要么它有两个子结点）</p><p>国内：<br><img src="https://img-blog.csdnimg.cn/2020072412220835.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="满二叉树"><br>国外：<br><img src="https://img-blog.csdnimg.cn/20200724122238899.png#pic_center" alt="国际二叉树"></p><p>完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 也就是说，满二叉树一定是完全二叉树！<br><img src="https://img-blog.csdnimg.cn/20200724122334769.jpg#pic_center" alt="完全二叉树"></p><h4 id="完全二叉树的判定："><a href="#完全二叉树的判定：" class="headerlink" title="完全二叉树的判定："></a>完全二叉树的判定：</h4><p>C++代码实现(不是本人亲写)：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <queue>using namespace std;template <class T>struct TreeNode{    T data;    TreeNode<T> *left;    TreeNode<T> *right;    TreeNode(const T &x) : data(x),                           left(NULL),                           right(NULL) {}};template <class T>bool IsComplete(TreeNode<T> *root){    //1.树为空，返回错误    if (root == NULL) {        return false;    }    //2.树不为空    queue<TreeNode<T> *> q;    q.push(root);    while (!q.empty()){        TreeNode<T> *top = q.front();        //2.1如果该节点两个孩子都有，则直接pop        if (top->left && top->right)  {            q.pop();            q.push(top->left);            q.push(top->right);        }        //2.2如果该节点左孩子为空，右孩子不为空，则一定不是完全二叉树        if (top->left == NULL && top->right   {            return false;        }        //2.3如果该节点左孩子不为空，右孩子为空或者该节点为叶子节点，则该节点之后的所有结点都是叶子节点        if ((top->left && top->right == NULL) || (top->left == NULL && top->right == NULL)) {                      if (NULL != top->left && NULL == top->right)   {                            q.push(top->left);                            }            q.pop(); //则该节点之后的所有结点都是叶子节点            while (!q.empty()) {                top = q.front();               if (top->left == NULL && top->right == NULL)  {                    q.pop();                }                else  {                    return false;                }            }            return true;        }                                                    }                                                                return true;}                                                            //满二叉树    //       1    //   2       3    // 4    5  6   7void test1(){    TreeNode<int> *node1 = new TreeNode<int>(1);    TreeNode<int> *node2 = new TreeNode<int>(2);    TreeNode<int> *node3 = new TreeNode<int>(3);    TreeNode<int> *node4 = new TreeNode<int>(4);    TreeNode<int> *node5 = new TreeNode<int>(5);    TreeNode<int> *node6 = new TreeNode<int>(6);    TreeNode<int> *node7 = new TreeNode<int>(7);    node1->left = node2;    node1->right = node3;    node2->left = node4;    node2->right = node5;    node3->left = node6;    node3->right = node7;    cout << IsComplete<int>(node1) << endl;} //二叉树为空void test2(){    cout << IsComplete<int>(NULL) << endl;}//3.二叉树不为空，也不是满二叉树，遇到一个结点左孩子为空，右孩子不为空void test3(){    //       1    //   2       3    // 4    5      7    TreeNode<int> *node1 = new TreeNode<int>(1);    TreeNode<int> *node2 = new TreeNode<int>(2);    TreeNode<int> *node3 = new TreeNode<int>(3);    TreeNode<int> *node4 = new TreeNode<int>(4);    TreeNode<int> *node5 = new TreeNode<int>(5);    TreeNode<int> *node7 = new TreeNode<int>(7);    node1->left = node2;    node1->right = node3;    node2->left = node4;    node2->right = node5;    node3->right = node7;    cout << IsComplete<int>(node1) << endl;} //4.二叉树不为空，也不是满二叉树，遇到叶子节点,则该叶子节点之后的所有结点都为叶子节点void test4(){    //        1    //    2       3    // 4    5    TreeNode<int> *node1 = new TreeNode<int>(1);    TreeNode<int> *node2 = new TreeNode<int>(2);    TreeNode<int> *node3 = new TreeNode<int>(3);    TreeNode<int> *node4 = new TreeNode<int>(4);    TreeNode<int> *node5 = new TreeNode<int>(5);    node1->left = node2;    node1->right = node3;    node2->left = node4;    node2->right = node5;    cout << IsComplete<int>(node1) << endl;}//4.二叉树不为空，也不是满二叉树，遇到左孩子不为空，右孩子为空的结点，则该节点之后的所有结点都为叶子节点void test5(){    //        1    //    2       3    // 4    5   6    TreeNode<int> *node1 = new TreeNode<int>(1);    TreeNode<int> *node2 = new TreeNode<int>(2);    TreeNode<int> *node3 = new TreeNode<int>(3);    TreeNode<int> *node4 = new TreeNode<int>(4);    TreeNode<int> *node5 = new TreeNode<int>(5);    TreeNode<int> *node6 = new TreeNode<int>(6);    node1->left = node2;    node1->right = node3;    node2->left = node4;    node2->right = node5;    node3->left = node6;    cout << IsComplete<int>(node1) << endl;}int main(){    test1();    /*test2();*/    /*test3();*/    /*test4();*/    /*test5();*/    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/gogogo_sky/article/details/76223384" target="_blank" rel="noopener">源码连接</a>：<a href="https://blog.csdn.net/gogogo_sky/article/details/76223384" target="_blank" rel="noopener">https://blog.csdn.net/gogogo_sky/article/details/76223384</a></p><p>二叉树通常用链式存储，每一个元素则可以有两个后件，分别可以指向左右子结点，其链式结构又叫二叉链表。</p><h4 id="二叉树遍历："><a href="#二叉树遍历：" class="headerlink" title="二叉树遍历："></a>二叉树遍历：</h4><p>二叉树遍历要求不能重复访问结点，常用的有前序遍历、中序遍历、后序遍历。</p><ul><li>前序遍历Data Left Right(DLR)：先访问根节点，然后遍历左子树，最后遍历右子树</li><li>中序遍历Left Data Right(LDR)：先遍历左子树，访问根节点，最后遍历右子树</li><li>后序遍历Left Right Data(LRD)：先遍历左子树，后遍历右子树，最后访问根节点</li></ul><p>相应的文章请到<a href="https://www.cnblogs.com/du001011/p/11229170.html" target="_blank" rel="noopener">博客园二叉树</a></p><p>公众号：小码之光（文章全部首发）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opera、google、firefox浏览器的选择</title>
      <link href="/2020/0719/"/>
      <url>/2020/0719/</url>
      
        <content type="html"><![CDATA[<p>作者：coderxm<br><strong>公众号：小码之光</strong></p><hr><h5 id="首先介绍："><a href="#首先介绍：" class="headerlink" title="首先介绍："></a>首先介绍：</h5><p>先介绍本人用的最多的浏览器：火狐</p><p>Mozilla Firefox，中文俗称“火狐”，是一个自由及开放源代码的浏览器，使用Gecko排版引擎，支持多种操作系统，如Windows、Mac OS及GNU/Linux等。该浏览器提供了两种版本，普通版和ESR延长支持版，ESR版本是 Mozilla 专门为那些无法或不愿每隔几周就升级一次的企业打造。Firefox  ESR 版的升级周期为 12 个月，而普通 Firefox 的升级周期为 4  周。由于该浏览器开放了源代码，因此还有一些第三方编译版供使用，如pcxFirefox、苍月浏览器、tete009等。</p><p><img src="https://img-blog.csdnimg.cn/20200719173503451.JPG" alt="百度"></p><p>简洁！使用火狐后，弹窗广告没了，乱七八糟的推送消失了，什么贪玩蓝月和黑网站链接都跟我拜拜了！使用起来还是非常舒适的，而且可以设置保护级别，拦截跟踪，加强反网络监视等等，尊重个人隐私，一些无证书认证的网址是有警告阻止页面的拦截的，很安全！当然不是说绝对的安全，有些墙缝里的黑角落还是有不好的网址的，首先体现在使用了百度搜索引擎之后，就有这个现象，不难看出某度引擎的强大之处。真是什么都能搜过来！</p><h5 id="接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器"><a href="#接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器" class="headerlink" title="接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器"></a>接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器</h5><p>为什么会爆胎呢？在google chrome里搜索几乎等于在网址栏里搜索，所以只是输入关键字是不能搜索的，除非换成其他搜索引擎，比如必应或某度。一般在里面搜索关键字后往往得到如下回应：</p><p><img src="https://img-blog.csdnimg.cn/20200719173532541.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="google"></p><p>谷歌公司（Google Inc.）成立于1998年9月4日，由拉里·佩奇和谢尔盖·布林共同创建，被认为是全球最大的搜索引擎公司。 2010年3月23日，谷歌高级副总裁、首席法律官大卫·德拉蒙德公开发表声明，宣布谷歌关闭在中国大陆市场搜索服务，并将搜索服务由中国内地转至香港。随之，某度当之无愧完全成为第一大搜索引擎公司。</p><p>内核是谷歌自己开发的chrome V8引擎，双内核，不过是谷歌自己用c++研发的，打开网页确实快，但是耗CPU，某种程度上是依托硬件来加速页面的渲染。就chrome的应用文件占500多M，耗内存不是太明显，和火狐差不多。</p><p>不过耗CPU的问题，这里顺便就解决一下，在google的设置里下拉，找到高级，打开找到硬件加速关闭即可。</p><p><img src="https://img-blog.csdnimg.cn/20200719174004917.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="关闭加速"></p><p>应该就老实了吧！记得别加载太多动态页面就行了，很耗CPU的。</p><p><img src="https://img-blog.csdnimg.cn/20200719174037850.JPG#pic_center" alt="google后台消耗"></p><h5 id="其次是用的少的：opera浏览器"><a href="#其次是用的少的：opera浏览器" class="headerlink" title="其次是用的少的：opera浏览器"></a>其次是用的少的：opera浏览器</h5><p>Opera(奥普拉)浏览器，是一款挪威Opera Software ASA公司制作的支持多页面标签式浏览的网络浏览器，是跨平台浏览器可以在Windows、Mac和Linux三个操作系统平台上运行，创始人谭永文创始于1995年4月，中文名就这样。 </p><p>Presto是由Opera Software开发的浏览器排版引擎，Opera 7.0及以上使用。有拦截、标签式浏览、快速拨号(快速拨号就是可以帮助用户将自己最常访问的多个网站，依次设入“拨号面板”中，而这些网站是以缩略图形式展现出来直观明了。然后，每次启动Opera时，便可以通过这个面板，快速打开相应的网站)等待一系列功能。VPN应该也行吧，没用过该功能！</p><p>相比国内某361、222、23957乱七八槽的浏览器，奥普拉干净了不少！也算是老浏览器了，不过国内知名度并不高。有许多特性是opera首创的！同样的跨平台，同样有手机浏览器应用，支持主题更换(暗黑模式)，支持许多扩展功能。不过占内存比较大一点！多了几百M。不过2016年，挪威浏览器厂商 Opera发布公告，宣布了确定被 360 和昆仑万维收购。出价 105 亿挪威克朗（约合 81 亿人民币）收购的，所以，你懂的！</p><hr><h5 id="浏览器与搜索引擎的搭配"><a href="#浏览器与搜索引擎的搭配" class="headerlink" title="浏览器与搜索引擎的搭配"></a>浏览器与搜索引擎的搭配</h5><p>浏览器是浏览器，搜索引擎是搜索引擎，两个是不一样的，一般浏览器都会内置几种搜索引擎供选择，包括Google chrome。</p><p><img src="https://img-blog.csdnimg.cn/20200719174237343.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="内置搜索"></p><p>如果不使用google搜索引擎，就享受不到它的快速，但是国内有没有服务。百度又是国内最大的搜索引擎，搜到的结果是一大堆没用的。比如下图：<br><img src="https://img-blog.csdnimg.cn/20200719174328667.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="广告"></p><p>还有右边的百度热搜，无尽广告等等！另外其他的国外引擎就不行了，要么是进不来国内，要么是搜索结果偏差！这里建议使用微软的必应Bing搜索，虽然没什么花里胡哨的东西，没有热搜榜，但绝对是搜得到匹配的东西！有搜索级别限制，在国内按照相关的规定已默认设置为严格搜索，不能更改了，即使有黑网站链接，但是会拦截过滤掉，也就是说这样的网址是打不开的，环境还是相当好的，墙裂推荐，匹配相关性杠杠的！</p><p><img src="https://img-blog.csdnimg.cn/20200719174406709.JPG#pic_center" alt="必应"></p><blockquote><p>作为一种在线搜索引擎，必应的主要目标是将互联网上相关性最强的搜索结果呈现给用户，从而让用户轻松访问互联网发布者发布的高质量内容。为此，必应会自动抓取互联网内容，为新页面和更新页面（或  URL）建立索引，以便在用户发起搜索或执行操作时显示一组相关的搜索结果。这些页面的内容可能会引用或含有各种在线资源和内容，包括网站、图像、视频、文档以及其他项目。搜索结果是使用计算机算法生成的，即由算法将您输入的搜索词与我们索引中的结果加以匹配，然后据此生成搜索结果。通常情况下，我们尝试尽量全面且有帮助地提供一批显示的搜索结果。我们会设计并不断改进我们的算法，确保提供最相关、最有用的结果。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200719174751969.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="严格搜索"><br>作为一项以算法驱动的服务，必应不会控制编入索引的网站的运营或设计，也不会控制这些网站发布的内容。只要这些网站继续在网页上以及向爬网程序提供信息，通常就可以通过必应或其他搜索引擎获得这些信息。所以还等什么，用起来！</p><hr><p>公众号：小码之光（文章全部首发）</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互质环与最小公倍数的几种求法</title>
      <link href="/2020/0709/"/>
      <url>/2020/0709/</url>
      
        <content type="html"><![CDATA[<h3 id="互质环-序列-与最小公倍数的几种求法"><a href="#互质环-序列-与最小公倍数的几种求法" class="headerlink" title="互质环(序列)与最小公倍数的几种求法"></a>互质环(序列)与最小公倍数的几种求法</h3><h4 id="题目一：互质环"><a href="#题目一：互质环" class="headerlink" title="题目一：互质环"></a>题目一：互质环</h4><p>现在我们要把1…n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多，请输出最大对数.</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><pre><code>一行一个整数n(1≤ n≤ 1000)。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h5><pre><code>一行一个整数表示答案。</code></pre><h5 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h5><pre><code>4</code></pre><h5 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h5><pre><code>4    例：3 2 1 4</code></pre><p>很显然，又是个把做题的的同学(小白)弄得晕头的题，实质上她还是个数学题，就看你数学学的好不好了，呵呵！既然相邻的两个数要互质(除了公因子1外没有其他公因数)，那从小到大顺序排序怎么样！好，试一下：1 2 3 4，也是两两互质，对数为4。是不是巧合呢？大家都知道相邻两数(整数)互质，那么怎么说明是确实是一定互质呢?</p><h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>转化一下，相邻两数：n-1, n(n&gt;1)，我们用反证法证明一下。</p><pre><code>预设结论：这两数不互质，即有除1以外的公因数k，n-1=x·k，n=y·k；那么有n-(n-1)=(y-x)k=1，k=1/(y-x)；y,x,k都是整数，k&gt;1,则1&gt;y-x，不符合！所以相邻两数互质！证明就完了。</code></pre><p>所以结论就是输入几个数就输出几个数，就能构造互质环(互质对数最多的，两两互质)。</p><hr><h4 id="题目二：最小公倍数"><a href="#题目二：最小公倍数" class="headerlink" title="题目二：最小公倍数"></a>题目二：最小公倍数</h4><p>有人说求最小公倍数不很简单吗？我想说的是，你是用那种方法求得，而且算法复杂度小，效率高吗？现在我们就现场讨论一波！</p><p>最小公倍数=两整数的乘积÷最大公约数 。 所以该问题可以转化为求最大公约数。而最大公约数有这几种求法：</p><ol><li><h4 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法 :"></a>辗转相除法 :</h4><p>1.a%b得余数c</p><p>2.如果c = 0,则b为最大公约数</p><p>3.如果c不等于0,则a = b,b = c继续执行步骤1。</p><pre><code>#include&lt;iostream&gt;using namespace std;long long lcm(long long x, long long y){    long long maxs = max(x,y);    long long mins = min(x,y);    long long t = maxs % mins;    while(t != 0){        maxs = mins;        mins = t;        t = maxs % mins;    }    return x * y/mins;}int main(){    long long x, y;        //x,y很大    cin &gt;&gt; x &gt;&gt; y;    cout&lt;&lt;lcm(x,y)&lt;&lt;endl;    return 0;}</code></pre><p>最优算法，t最快接近最大公约数，因为是进行求模运算，所以比相减来得更快。T(n)应该是接近常数级，S(n)的话，由于lcm函数中进行了maxs,mins赋值，空间复杂度降低，和相减法差不多。</p></li></ol><h4 id="2-相减法"><a href="#2-相减法" class="headerlink" title="2 .相减法:"></a>2 .相减法:</h4><p>   两数之差与最大公约数成倍数关系。</p><pre><code>1.若a&gt;b，则a=a-b2.若a &lt; b，则b=b-a3. 若a=b，则a（或b）即为两数的最大公约数4. 若a≠b，则再回去执行1</code></pre><pre><code>#include&lt;stdio.h&gt;int main ( )  /* 相减法求最大公约数 */{     int m, n, a, b, c;   scanf (&quot;%d,%d&quot;, &amp;a, &amp;b);   m=a; n=b;      /* a, b不相等，大数减小数，直到相等为止。*/    while ( a!=b) {         if (a&gt;b)  a=a-b;         else  b=b-a;    }   printf(&quot;The largest common divisor:%d\n&quot;, a); //最大公约数   printf(&quot;The least common multiple:%d\n&quot;, m*n/a);    //最小公倍数}</code></pre><p>T(n)与第一种相比，当两个数比较大时，而且仅相差较小的数，循环需要a=b相等才结束，所以T(n)这时会比较大。</p><h4 id="3-枚举法："><a href="#3-枚举法：" class="headerlink" title="3.枚举法："></a>3.枚举法：</h4><p> 已知1是一个公约数，但是1不是最大公约数，所以可以检测K=2,3,4…..是否为x和y的公约数，直到k大于x或者y，将公约数存储在gcd的变量中,gcd初值设为1</p><pre><code>int gcd = 1;for(int k = 2;k &lt;= x&amp;&amp;k &lt;= y;k++){    if(x % k == 0&amp;&amp; y % k == 0)        gcd = k;}</code></pre><p>当问题规模很大时，这个算法最不好，还是从小到大枚举，T(n)就很大了，k需要不断被自加1赋值，还要判断取模等等，循环次数过多。</p><hr><p>今天的算法分享就完了，任务结束，别忘了点赞！hh！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互质 </tag>
            
            <tag> 最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年轻母牛的故事</title>
      <link href="/2020/0708/"/>
      <url>/2020/0708/</url>
      
        <content type="html"><![CDATA[<h3 id="年轻母牛的故事"><a href="#年轻母牛的故事" class="headerlink" title="年轻母牛的故事"></a>年轻母牛的故事</h3><h4 id="题目是这样的："><a href="#题目是这样的：" class="headerlink" title="题目是这样的："></a>题目是这样的：</h4><p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>​    输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br> n=0表示输入数据的结束，不做处理。 </p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>​    对于每个测试实例，输出在第n年的时候母牛的数量。<br> 每个输出占一行。 </p><p>题目非常简洁，不知道是不是歪果仁想的题，我猜它的英文版是这样的：</p><p>There is a cow, which gives birth to a heifer at the beginning of each  year. Each heifer starts from the fourth year, and a heifer is also born at the beginning of each year. Please program how many cows are there  in the nth year?</p><p>母牛特别能生，4年就发育成熟，就能生！问第几年有多少头母牛？哎呀，对于一个刚入门的新手来说，要想解决这个题，确实很费劲了(很烧脑)！只能感叹：这公牛的后宫不久就壮大了！牛批！而老手一眼看穿规律，就有了思路。那么老手是怎么看穿的呢？</p><p>从数学角度看，这个母牛数目增长还是有一定的规律的，所以我们需要把每一年的母牛的数目清点一下，这个时候，数学基础就暴露出来了，第几年多少头牛都点不清，这还是小学问题，就是个点数题！注意题目描述！</p><p>第一年：1头</p><p>第二年：2头</p><p>第三年：3头</p><p>第四年：4头</p><p>第五年：6头</p><p>第六年：9头</p><p>OK，我相信你数学非常好，很快就能发现规律。归结为一个数学题：设第n年的母牛头数为a[n]，则可以得出一个·递推公式：</p><p>​    a[n] = a[n-1] + a[n-3]；</p><p>可以验证一波，没问题了就可以撸代码了，这里提供了java和c++版的代码题解，如果测试出现翻车概不负责！请注意！</p><p>Java版(我写的)：</p><pre><code>import java.util.Scanner;public class Main{    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        int[] a = new int[60];        a[0] = 0;        a[1] = 1;        a[2] = 2;        a[3] = 3;        a[4] = 4;        for(int i=5;i&lt;=55;i++){            a[i] = a[i-3] + a[i-1]; //递推填充数组        }        while (scanner.hasNextInt()) {      //等待输入            int num = scanner.nextInt();            if(num==0){             //判断是否为0                break;            }            System.out.println(a[num]);        }    }}</code></pre><p>c++版：</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(){    int t , a[60];    a[1] = 1 ;    a[2] = 2;    a[3] = 3;    a[4] = 4;    for(int i = 5 ; i &lt; 60 ; i ++)    {        a[i] = a[i-1] + a[i-3];    }    while(~scanf(&quot;%d&quot;,&amp;t) &amp;&amp; t)    cout&lt;&lt;a[t]&lt;&lt;endl;    return 0 ;}</code></pre><p>hh,如果真有问题公众号交流，加群也行！以学习为首要！</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对比两个代码版本，其实也没差多少，核心代码几乎相同，在算法上完全是一模一样！所以说算法在任何情况下都是通用的，每一种算法都可以解答一种题目，很有逻辑性。另外还涉及到数学的思想，有些特别简单，比如这个数学递推公式，这就结合数学来解算法题了！遇到这样的题目算是很有趣了，一般都有规律可循，只不过需要花点时间。OK，我是小码，一个会发光的准程序员！下期再见！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的复杂度</title>
      <link href="/2020/0705/"/>
      <url>/2020/0705/</url>
      
        <content type="html"><![CDATA[<h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3><blockquote><p><strong>前言</strong>：本人并非所谓的大佬，蒟蒻一枚，写文章的目的主要就是这么几个。一个是为了总结昨天学习的知识，巩固于心；二是将所学的整理起来，也方便以后备用查阅；第三个是可以给其他的有需要的人看，也可以一起学习进步，有必要还可以提建议！总之比没写强吧！缸巴咧！</p></blockquote><p>评判一个程序的好坏通常有几个标准，按照程序的运行效率和代码的可读性以及代码的美观性几个方面看，而最主要的方面不过效率和可读性。可读性没什么好说了，作为团队中的那一个蒟蒻，当然没啥高深的算法描述了。最后就看效率了，效率上可分为运行时间和所需空间大小两个方面入手，数据结构上可专业的称为算法的时间复杂度和空间复杂度。接下来就进入重点了，如何评测一个程序的时间和空间复杂度？</p><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>这里又引入一个专业词：时间开销T，通俗点讲就是所花的时间；问题规模n，可以看作是代码基本语句的执行数量(可以被重复执行)。很显然，时间开销和问题规模n有关，记作T(n)。</p><pre><code>(1)    T(n) = 3n + 3 -&gt; o(f(n)) = n ，[f(n)的高阶无穷小，即n趋于无穷是等于它](2)    T(n) = n^3 + n +9990  -&gt; o(f(n)) = n^3 [同理趋于无穷接近]</code></pre><p>上述式子，省略了常数，那意味着当问题规模很大时，只需要计算一些循环的基本语句的执行次数就行了。</p><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>当(1)与(2)式相加时，效果还是一样，求出其高阶无穷小，简单方法就是去掉低阶项，保留高阶项。</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>既然都相乘了，就不好意思去掉其中任意一个了，所以吧两个高阶无穷小相乘即可。</p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><pre><code>void test(int k[],int n){    //n为数组长度    printf(&quot;I am Tiga\n&quot;);    for(int i=0;i&lt;n;i++){        if(k[i]==n){            printf(&quot;I am light %d\n&quot;,n);            break;        }    }}</code></pre><p>就源码分析来看，入口的参数有两个，一个数组k[ ]，一个整数n。而这个函数的作用在于判断数组k[ ]中是否有整数n,如果有则输出并结束。然而它的时间复杂度不是唯一确定的，需要分情况。最好情况是，数组第一个就是n，那很快就结束了，执行基本语句量为常数，记为T(n) = o(1);最坏情况是，需要找到最后一个n，根据上面的结论可得出，T(n) = o(n)，进而可以求平均时间复杂度。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度就相对理解起来更容易些，因为空间复杂度很少受问题规模的影响。</p><pre><code>void test(int n){    int k = 3;    if(k==n){        printf(&quot;Yes,Thanks!\n&quot;);    }}</code></pre><p>上述代码几乎可以算出所需内存空间大小，如果int整形为4个字节，那么总共需要8个字节，则可以表达为S(n) =o(1)，即常数级大小，那么这样典型的不受问题规模影响的空间复杂度情况就称作算法原地工作。如果受问题规模影响也能举出例子：</p><pre><code>void test(int n){    int k[n];    k[0] = 1;    printf(&quot;Yes,Thanks %d!\n&quot;,k[0]);}</code></pre><p>这个例子就简单又生动了，问题规模影响了空间复杂度，使它不唯一，则可以表示为S(n)= o(n)。</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>算法复杂度这两个方面就写完了，其实也并不复杂，复杂的还在后面。至少了解了一下算法好坏的判断标准，有助于以后写出更好的程序：执行时间少，占用空间小，效率高，美观，可读性好的程序！</p><p>一起学习，一起成长，欢迎关注本人公众号<strong>小码之光</strong>，一个会发光的准程序员！</p><p><a href="https://github.com/coderxm/" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halo开源博客</title>
      <link href="/2020/0702/"/>
      <url>/2020/0702/</url>
      
        <content type="html"><![CDATA[<h2 id="Halo开源博客项目配置"><a href="#Halo开源博客项目配置" class="headerlink" title="Halo开源博客项目配置"></a>Halo开源博客项目配置</h2><h3 id="README"><a href="#README" class="headerlink" title="README"></a>README</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>Halo</strong> <code>[ˈheɪloʊ]</code>，意为光环。Halo 是一款现代化的个人独立博客系统，给习惯写博客的同学多一个选择。当然，你也可以当成拼音读(哈喽)。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><blockquote><p>本项目旨在创造一个好的产品以供人们使用（虽然现在并不是太好），并非一个所谓提供学习的项目。所以，不提供任何学习代码的帮助。也请不要在讨论群，issues，论坛发起任何有关代码学习的问题。当然，如果你是要参与代码贡献，我们非常欢迎。</p></blockquote><p>另外，写给想自己拉代码编译运行的同学：</p><blockquote><p>目前我们的开发分支即 master，肯定会有很多小问题，不要运行不起来就跑过来吐槽什么代码开源不完整之类的，多找找自己的原因。同时建议下载最新 release 版本的代码，或者在 master 分支执行 <code>git checkout v1.3.2</code>。</p></blockquote><p>PS：实在不想写这个声明（影响 README 的美观），但是就目前来看，写在 README 上是有必要的，因为大部分遇到问题的人都不会去仔细阅读文档。</p><h4 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h4><h5 id="下载最新的-Halo-安装包"><a href="#下载最新的-Halo-安装包" class="headerlink" title="下载最新的 Halo 安装包"></a>下载最新的 Halo 安装包</h5><blockquote><p>其他地址：<a href="https://halo.run/archives/download.html" target="_blank" rel="noopener">https://halo.run/archives/download.html</a></p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">curl -L https://github.com/halo-dev/halo/releases/download/v1.3.2/halo-1.3.2.jar --output halo-latest.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre><code>wget https://github.com/halo-dev/halo/releases/download/v1.3.2/halo-1.3.2.jar -O halo-latest.jar</code></pre><h5 id="启动-Halo"><a href="#启动-Halo" class="headerlink" title="启动 Halo"></a>启动 Halo</h5><pre class="line-numbers language-bash"><code class="language-bash">java -jar halo-latest.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>详细部署文档请移步：<a href="https://halo.run/archives/install-quick-start.html" target="_blank" rel="noopener">https://halo.run/archives/install-quick-start.html</a></p><h5 id="博客示例"><a href="#博客示例" class="headerlink" title="博客示例"></a>博客示例</h5><p>请移步： <a href="https://halo.run/p/user-wall.html" target="_blank" rel="noopener">https://halo.run/p/user-wall.html</a>。</p><h4 id="周边"><a href="#周边" class="headerlink" title="周边"></a>周边</h4><ul><li>后台管理（halo-admin）：<a href="https://github.com/halo-dev/halo-admin" target="_blank" rel="noopener">https://github.com/halo-dev/halo-admin</a></li><li>独立评论模块（halo-comment）：<a href="https://github.com/halo-dev/halo-comment" target="_blank" rel="noopener">https://github.com/halo-dev/halo-comment</a></li><li>管理 APP（已停止维护）：<a href="https://github.com/halo-dev/halo-app" target="_blank" rel="noopener">https://github.com/halo-dev/halo-app</a></li><li>主题仓库：<a href="https://halo.run/p/themes.html" target="_blank" rel="noopener">https://halo.run/p/themes.html</a></li><li>资源下载：<a href="https://dl.halo.run" target="_blank" rel="noopener">https://dl.halo.run</a></li><li>WeHalo 小程序：<a href="https://github.com/aquanlerou/WeHalo" target="_blank" rel="noopener">https://github.com/aquanlerou/WeHalo</a></li></ul><hr><p><strong>启动项目前配置</strong></p><p>项目为gradle项目，项目依赖文档配置在build.gradle,开始前确保能自动导入依赖，导入需要花费一些时间。之后可以进行具体的配置，如数据库的配置，找到文件application.yaml文件。<br><img src="https://img-blog.csdnimg.cn/20200702102932816.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="项目结构"></p><p>将h2数据库的enabled和web-allow-others改为<strong>true</strong><br><img src="https://img-blog.csdnimg.cn/20200702103019124.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="数据库配置"></p><p>差不多就可以启动整个项目了，怎么启动呢？之前已经有经验了吧，介绍了一个eladmin后台管理系统的项目，难度或者复杂度比这个大一点，其中就讲了具体的项目的启动配置。找到项目中唯一能运行的源代码文件，一般在源代码文档src/main/java里面，找到它，命名一般是AppRun或ApplicationRun或者Application的Java文件，打开能看到有main()函数的，就是项目启动文件。IDEA会自动找到可运行的启动文件，并打开绿色小三角按钮，点击小三角启动它！<br><img src="https://img-blog.csdnimg.cn/20200702103304505.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="小三角启动"><br>可以看到左下角项目在编译运行。<br><img src="https://img-blog.csdnimg.cn/20200702103054697.PNG#pic_center" alt="启动标志"><br>启动后没有乱码和红色报错，说明配置对了。<br><img src="https://img-blog.csdnimg.cn/20200702103122874.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="启动成功"><br><img src="https://img-blog.csdnimg.cn/20200702103132613.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="启动成功"></p><p>如果出现乱码的情况，说明编译的时候没有配置好，而编码需要的是UTF-8，找到项目的依赖配置文件build.gradle,添加如下配置。</p><pre><code>tasks.withType(JavaCompile) {    options.encoding = &#39;UTF-8&#39;}</code></pre><p>如果出现红色报错，说明有其他配置问题，很大原因是导入依赖不成功，受到了网速影响，需要重新导入模块。还有问题请加群交流，这里不做详细的解释！</p><h4 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDkvMTEvSXUxZU16WkRnNmZydzk3LnBuZw?x-oss-process=image/format,png" alt="install.png"><br>这个halo博客后台支持markdown语法的编辑，对写博客非常友好！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDkvMTEvdWNEaDJ0T1pMSkdUeUhYLnBuZw?x-oss-process=image/format,png" alt="admin-post-edit.png"></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对比其他博客框架，halo博客是一个动态的博客系统，有前端，有后台，可以自己买个服务器搭一搭。而其他的开源博客，有一部分是没有后台的，修改上传文章主要在线下完成，所以维护起来十分费劲。如果可以的话还可以动手改halo的样式，halo也有其他主题样式供选择。OK，以上就是简单的玩一玩开源项目，具体大家可自行研究，有问题或探讨可以关注我公众号加群！<br>公众号：小码之光<br>博客园：coderxm</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA报错稀有问题</title>
      <link href="/2020/0626/"/>
      <url>/2020/0626/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA报错稀有语法问题"><a href="#IDEA报错稀有语法问题" class="headerlink" title="IDEA报错稀有语法问题"></a><strong>IDEA报错稀有语法问题</strong></h3><hr><blockquote><p>Error:java: Compilation failed: internal java compiler error;</p><p>Error:java需要”;”<br><img src="https://img-blog.csdnimg.cn/20200626115209953.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="报错"></p></blockquote><p>这种报错不知道大家见过没有，可能一般人不会出现这种编译错误。实际上它的错误是红色的那个”Erroe:java:需要”;” “,但是仔细检查正在编辑的代码，一点语法错误都没有，IDEA也没说哪里出问题了。于是又陷入了长久以来的僵局——百度！</p><hr><h3 id="百度的结果"><a href="#百度的结果" class="headerlink" title="百度的结果"></a>百度的结果</h3><p>结果说是jdk版本没配置好，我信了，又屁颠屁颠的改版本，原来是jdk8呀，现在也是。步骤如下：</p><p><img src="https://img-blog.csdnimg.cn/20200626115249713.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="module"><br><img src="https://img-blog.csdnimg.cn/20200626115312144.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="project"><br><img src="https://img-blog.csdnimg.cn/20200626115342760.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="java compiler"></p><hr><h5 id="百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西"><a href="#百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西" class="headerlink" title="百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西"></a>百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西</h5><p>所以我放弃百度的搜索，改用经典的eclipse进行编辑，在导入文件夹时，没运行就发现了语法错误，然而eclipse给我报错是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20200626115425299.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="eclipse报错"></p><p>很清楚的给我错的地方！但是反过来看，IDEA自称最智能的编辑器，有时候还是像智障编辑器，eclipse虽然皮肤不好看，但是依旧经典。ok，我回到IDEA智障编辑器里了，这里的问题应该就不难弄懂了，还是过不去的语法问题，出错在另一个文件里。</p><p><img src="https://img-blog.csdnimg.cn/20200626115516956.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="修改错误"><br>改回来之后就行了，就能运行程序了。</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>IDEA报错有时让人摸不着头脑，还告诉你错在何处，接着错上加错，虚度光阴，罪恶之极！总结下来的原因就是，像IDEA编辑文件都是以项目文件进行编辑的，如果一个文件出语法错误，另一个文件(整个项目源码文件)都会受牵连，就会编译不过去。尽管这样，IDEA还是不告诉哪里有语法错误，建议在实际项目用eclipse进行编辑。管他香不香，用的舒服就好！</p><hr><p>更多问题关注我的公众号：小码之光，<strong>文章将在公众号首发</strong>！<br>最后附上：<br><a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码CSDN</a><br><a href="https://www.cnblogs.com/coderma/" target="_blank" rel="noopener">博客园</a><br>微信公众号：小码之光<br><img src="https://img-blog.csdnimg.cn/20200626115852678.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你跑一个开源项目</title>
      <link href="/2020/0531/"/>
      <url>/2020/0531/</url>
      
        <content type="html"><![CDATA[<h3 id="带你跑ELADMIN后台管理系统开源项目"><a href="#带你跑ELADMIN后台管理系统开源项目" class="headerlink" title="带你跑ELADMIN后台管理系统开源项目"></a>带你跑ELADMIN后台管理系统开源项目</h3><hr><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><p>最近开始稍微接触了点框架，本来是想学点开源项目什么的，但学起来耗得时间长，所以公众号和博客的文章都慢慢的停更了许久。之前的java多线程和反射都还没弄透，更别说java源码和JVM了，学习这件事真的需要坚持、耐心和不断总结 。github上满是开源项目，建议找一个适合的项目练练，看看它用到的技术，一个个吃透了，以后用到相同的技术就越发熟练，看代码如同行云流水，毫不费劲。今天就推荐一个十分火爆的开源项目el-admin后台管理系统，结合前端Vue使用 ，是一个不错的开胃菜。</p><hr><h5 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h5><p>一个基于 Spring Boot 2.1.0 、 Spring Boot Jpa、 JWT、Spring Security、Redis、Vue的前后端分离的后台管理系统</p><p>开发文档： <a href="https://docs.auauz.net/" target="_blank" rel="noopener">https://docs.auauz.net/</a><br>体验地址： <a href="https://auauz.net/" target="_blank" rel="noopener">https://auauz.net/</a></p><p>账号密码： <code>admin/123456</code> (默认密码都是123456)</p><table><thead><tr><th></th><th align="center">后端源码</th><th align="center">前端源码</th></tr></thead><tbody><tr><td>github</td><td align="center"><a href="https://github.com/elunez/eladmin" target="_blank" rel="noopener">https://github.com/elunez/eladmin</a></td><td align="center"><a href="https://github.com/elunez/eladmin-web" target="_blank" rel="noopener">https://github.com/elunez/eladmin-web</a></td></tr><tr><td>码云</td><td align="center"><a href="https://gitee.com/elunez/eladmin" target="_blank" rel="noopener">https://gitee.com/elunez/eladmin</a></td><td align="center"><a href="https://gitee.com/elunez/eladmin-web" target="_blank" rel="noopener">https://gitee.com/elunez/eladmin-web</a></td></tr></tbody></table><p>这是用流行框架spring boot和vue实现的前后端分离的后台管理系统，不要被前后端分离吓到了，只是前后端的代码放在不同的地方而已，没有什么特别重要的技术难点。</p><hr><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p>上面已经给出了项目的源码，把前后端的源码下下来就行了，之后要准备什么呢？当然是准备跑项目的环境了，可以分为前端和后端的运行环境。在项目里，是需要后端的，所以先配置后端环境。那我们如何知道应该配好怎样的环境呢？看github项目的介绍，README文档里面也有介绍，以后可以直接看README就行了。既然是个Java项目，当然应该有Java的环境啦，这个可以直接用IDEA代替，社区版的也行，项目的文件就用IDEA打开就是了。</p><hr><h5 id="Redis数据库安装配置"><a href="#Redis数据库安装配置" class="headerlink" title="Redis数据库安装配置"></a>Redis数据库安装配置</h5><p>如果没有，可在公众号内回复<strong>redis</strong>获取。下载好后，应首先配置它的环境变量。分别打开redis-servr.exe和redis-cli.exe，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531093506213.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="redis">)<img src="https://img-blog.csdnimg.cn/20200531093545795.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="redis启动"></p><hr><h5 id="mysql配置"><a href="#mysql配置" class="headerlink" title="mysql配置"></a>mysql配置</h5><p>项目里的eladmin.sql文件为MySQL启动脚本，了解后，并不是双击运行。前提应该有mysql和数据库管理器吧，没有mysql可以在公众号内的软件工具哪里找，应该有，记得配置环境变量。另外管理工具就别用SQL Server了，sqlyog也不错，官网有社区版的，就下的慢，推荐链接：<a href="https://pan.baidu.com/s/1PcVVkucLRf-49lHDPl6syA" target="_blank" rel="noopener">https://pan.baidu.com/s/1PcVVkucLRf-49lHDPl6syA</a> 提取码：w27i 。先建一个项目数据库。</p><p><img src="https://img-blog.csdnimg.cn/2020053110421664.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="创建数据库"></p><p>接着用记事本或其他打开项目sql脚本，全选粘贴在询问一栏，并再次全选右键执行查询或摁F9。</p><p><img src="https://img-blog.csdnimg.cn/20200531093646199.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="sql查询"><br>结果没报错即可，都不要关闭这些。</p><hr><h5 id="后台spring"><a href="#后台spring" class="headerlink" title="后台spring"></a>后台spring</h5><p>如果没有还有spring这个框架，不用太担心，这样大部分是框架依赖，所以交给IDEA去干就行了，前提是别把网断了，需要下依赖包。如何让IDEA自动下呢？在文件那点击setting设置，在Build,Execute那的Maven选项。</p><p><img src="https://img-blog.csdnimg.cn/20200531093753426.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="导入依赖"><strong>自动导入Maven项目</strong></p><p><img src="https://img-blog.csdnimg.cn/20200531093822889.PNG#pic_center" alt="mport-ij"></p><p><img src="https://img-blog.csdnimg.cn/20200531094000871.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字节码版本"><br>上图把编译器生成的字节码类型改为和jdk相同版本，我这里用jdk11编译，不然会报“不支持java 5版本，请使用6及以上版本”。更具体的操作可以自己搜索解决，比较简单。同样在项目的配置文件pom.xml里，需要添加相应的依赖属性。</p><blockquote><p><properties> //添加下面几个，如果没有就加上去<br>        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br>        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;<br>        &lt;java.version&gt;11&lt;/java.version&gt;<br>        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;<br>        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; </properties></p></blockquote><p>这时候还不能自动下载依赖包，可以手动刷新或者说重新导入项目，右键项目文件，在maven选项那点reimport就行了。</p><p><img src="https://img-blog.csdnimg.cn/20200531094242220.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="重新导入"><br>耐心等待后，就可以启动后台了，在eladmin-system下找到Apprun的Java文件，运行它。<br><img src="https://img-blog.csdnimg.cn/20200531094302865.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="项目启动文件"><br>结果如下，没报错就行！<br><img src="https://img-blog.csdnimg.cn/20200531094336323.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><hr><h5 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h5><p>前端配置比较容易出错，报错了直接在命令行输出一大堆信息，关键是解决起来非常麻烦。配置前端呢主要是为了能让大家在本地就能看到效果，只有后端的项目，再好，没前端相辅相成，项目跑的也没意思！同样的套路，同样的逼数！首先咱们找到前端的文件夹，发现里面是没有前端的依赖的，这个不足为奇。那咱们就需要配置依赖了。主要是node.js , node.js 是一个基于 Chrome V8 引擎的 JavaScirpt 运行环境，可以用于服务端编程。我们把它下载后需要<strong>配置它的环境变量</strong>，目的是为了用他的包管理工具npm(nodejs package management)，那有什么用呢?</p><pre><code>  1  允许用户从NPM服务器下载别人编写的第三方包到本地使用  2  允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用  3  允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用</code></pre><p>在这之前，把文件夹里的package.json包修改一下，找到script那里，添加如下：</p><pre><code>&quot;scripts&quot;: {    //如果没有以下，则添加    &quot;dev&quot;: &quot;vue-cli-service serve&quot;,    &quot;start&quot;: &quot;node index.js&quot;,    &quot;server&quot;: &quot;nodemon index.js --ignore client&quot;,    &quot;build&quot;: &quot;vue-cli-service build&quot;,  },</code></pre><p>我们下翻，还能看到前端的依赖dependencies和环境需要的版本，node在8.9及以上，npm在3.0.0及以上。</p><pre><code>&quot;engines&quot;: {    &quot;node&quot;: &quot;&gt;=8.9&quot;,    &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;  },</code></pre><p>之后说白了，npm就是帮我们把前端需要的依赖给下了，方便生成前端页面。具体的nodejs的下载安装配置，可以搜索相关文章，这里就不多讲了。命令行‘npm -v’查看npm版本，能看到输出，说明配置成功。</p><blockquote><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>-g    //设置淘宝镜像，加快下载依赖</p></blockquote><p>cd进入前端文件夹内，输入”npm install”，开始下载依赖，之后文件夹内会多出node_modules文件夹，命令行中不出现报错就行，报错的话可能有几个原因。</p><blockquote><ol><li>网络原因，下载中断了，或下载较慢</li><li>package依赖包没配置好，应先配置好</li><li>版本低，检查一下</li><li>如果不是以上原因，可能是某一个具体因素导致的，就需要仔细查看命令行报错了，很可能是某个依赖没有下好，可以直接进入文件夹查看，如果没有则真的没下好，可以：npm<br>uninstall xxx;再npm install xxx，重新来一遍。</li></ol></blockquote><hr><p>然后一切顺利，”npm run build: prod”；”npm run dev”；前端就跑起来了！结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531101424186.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="eladmin"><br>当然我们不只是纯粹为了演示项目，像里面的配置啊什么的，技术还需要我们一步一步吃透。要学会解决问题，学习路上总有风雨，只要努力专研，还是会有所收获的！如果有更多问题就关注公众号吧！加群了解更多！这次就分享到这了。</p><p>最后附上：<br><a href="https://www.maliaoblog.cn">小码blog</a><br><a href="https://www.cnblogs.com/coderma/" target="_blank" rel="noopener">博客园</a><br>微信公众号：小码之光</p><p> <img src="https://img-blog.csdnimg.cn/20200427213721746.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eladmin </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相比c++,java在基础语法上的改变</title>
      <link href="/2020/0528/"/>
      <url>/2020/0528/</url>
      
        <content type="html"><![CDATA[<p>此篇给Java初学者的一点参考，算是入门吧，对有c/c++基础的同学来说，更是帮助他们尽快理解Java更深层次(面向对象，集合，泛型，多线程与并发)的强力剂，如有缺漏敬请补正！转载需注明出处！</p><h5 id="文章目录："><a href="#文章目录：" class="headerlink" title="文章目录："></a>文章目录：</h5><ol><li>运行机制</li><li>基本数据与特殊类型</li><li>字符集与数值表达</li><li>文档注释</li><li>连字符+与输出</li><li>switch语句</li><li>foreach循环</li><li>数组类型</li></ol><hr><h4 id="01-Java运行机制"><a href="#01-Java运行机制" class="headerlink" title="01 Java运行机制"></a>01 Java运行机制</h4><p>在运行机制上，Java不同于任何一门语言，Java编写好的源代码文件并不是经过编译后就能立马执行的。不像c/c++一样，编译后就是.exe了，双击就可以运行，但是Java有它巧妙的地方。先说明一下，任何的编程语言的源码都需要经过编译变成二进制代码，才能被执行，无论c/c++还是Java。在Windows上把c/c++源码经过gCC/g++编译后能运行，但在Linux或其他平台，要有相应的源码编译器为源码进行编译，也就是说，想要在其他平台上运行，得把c/c++源码在编译一遍才能运行。看起来也还行的样子，不就是在编译一次嘛！有多大麻烦呢？对程序员来说不算是什么难事，但对用户来说就是难事，或者说，用起来就是个麻烦事。谁还会辛辛苦苦又编译一次源码，然后让它在机子上跑，万一出问题还得重来！</p><p>起初Java就是为解决这个问题而设计出来的，最早是被sun公司用于嵌入式的设备开发，理念是“write once,run anywhere!”，设计出来后并不很火，那时候c++本身就可以跨平台，所以也没Java什么事儿了。但是之后发现真的可以做到 “  run anywhere ” , 并且由于网页端互联网浪潮的掀起，Java在web上大显身手，这才有了今天的Java，然而sun公司在09年被Oracle收购，之后江湖上再也没了sun公司的身影。那Java又是怎么解决跨平台的问题呢?</p><p>先要了解Java文件，源码文件以.java为后缀，经过编译后不直接生成可执行文件，而是生成.class字节码文件(16进制)，这个文件不是让平台的操作系统读的，是让JVM (java virtual machine)java虚拟机读的，平台上的虚拟机识别后会相应生成能让机子跑起来的二进制文件，就能执行了。其中的原理比较复杂，就不过多陈述啦！</p><p>那有人就不快乐啦：就这？</p><p>当然不是，继续讲。想简单跑一个”hello 妹纸！”需要咋做啊？</p><p>首先上[Oracle的官网]，下载jdk1.8版本，就是常说的Java8。jdk(java development kits大概就这样)，顾名思义：Java开发包，有SE(standard     environment)   ,  EE (enterprise environment),ME(micro environment),即标准版，企业版，微型版。我们要学的是SE，到了工作岗位，可能就要EE了，ME现在基本少的接触，就不用学了，毕竟jdk都14了！里面大致分为javac编译器，运行器java.exe，JRE(java runtime environment) java 运行环境，java基础类库，和其他支持。其中JRE里面有JVM(负责解释字节码)，和其他环境支持。如果在windows上编译”coder小 码.java “源文件，就变成”coder小码.class”,想要在另一台装linux的机子上运行，只需要在这台机子上装JRE就行了，JVM解释”coder小码.class”文件后执行它就行了。</p><hr><h4 id="02-基本与特殊数据类型"><a href="#02-基本与特殊数据类型" class="headerlink" title="02 基本与特殊数据类型"></a>02 基本与特殊数据类型</h4><p>Java相较于原始的c语言，多出了两个基本数据类型，byte字节(1个字节)，和boolean布尔(true/false)基本类型,总共8种；其他为引用(reference)类型，多出了String字符串类型，Array数组类型，null类型(唯一值null)，等等。原来的char字符类型变成了两个字节，可以支持中文字符，一个char,一个汉字。</p><p>保留字(目前未使用但以后会使用):const ; goto也是关键字。</p><p>直接量：true,false,null.虽然不是关键字，但依然不能用来做标识符。</p><p>标识符：增加了$标识开头(中英字母，下划线)，同样不能数字打头，其后才能接任意字符，中日英皆可。</p><hr><h4 id="03-字符集与数值表达"><a href="#03-字符集与数值表达" class="headerlink" title="03 字符集与数值表达"></a>03 字符集与数值表达</h4><p>上面大家可能就有点疑问了，咋就这么越来越开放了！中日字符都来了！没错，Java换了字符支持，使用unicode字符集，几乎支持所有字符，改变了以往编程语言只支持英文标识符的情况，现在读取一个char就相当于读取了一个汉字了。unicode就是这么杠！</p><p>数值表达：Java在整数上又动手动脚的，增加了对二进制整数的表达，比如。</p><pre><code>int binary = 0b10000001;</code></pre><p>上面为一个负数，需要换算成原码为-128。另外为防止程序员出意外看走眼，还可以写成：</p><pre><code>int binary  = 0b1000_0001;</code></pre><p>用下划线可以分隔整型和浮点型。</p><hr><h4 id="04-文档注释"><a href="#04-文档注释" class="headerlink" title="04 文档注释"></a>04 文档注释</h4><p>注释除了以前常用的单多行注释，Java还增加了文档注释。Java为开发者提供了大量的基础类，同时也提供了<a href="https://www.oracle.com/technetwork/java/javase/downoads/" target="_blank" rel="noopener">API帮助文档</a>，介绍各个API、方法、包、类的使用方法，原型。如果编写很大的Java程序，可以利用javadoc工具将源码的文档注释提取出来变成API文档，例：</p><pre><code>/**两个**Description*&lt;h1&gt;javadoc&lt;/h1&gt;*Copyright 2009*@author coder小码*@version 1.0*/</code></pre><p>可以在类，方法，public\protected变量前加注释。进入目录，终端输入：</p><pre><code>javadoc -d D://coder/ -windowtitle API文档 -author -version *.java</code></pre><p>上面的命令用于生成Java文档，-d 存放目录 ，-windowtitle 窗口标题，-author -version,加上作者和版本信息，从当前目录下所有Java源文件中提取注释。之后就生成了和官方一样专业的API文档了！</p><hr><h4 id="05-连字符‘-’与输出"><a href="#05-连字符‘-’与输出" class="headerlink" title="05 连字符‘+’与输出"></a>05 连字符‘+’与输出</h4><p>和c++一样，Java也有连字符，可以将字符串拼接到一起，但同时又能做算术运算，这就涉及到了运算符的重载和基本数据类型的装拆箱了。</p><pre><code>String coder = &quot;小码&quot;+&quot;coder&quot;;String coder2 = &quot;coder小码&quot;+321；System.out.println(coder);System.out.println(coder2);</code></pre><p>输出为：“小码coder”,“coder小码321”。</p><p>将+看作是一个方法，既可以把数字作为参数，又可以把字符做参数，而方法名却没有变，算是隐式的重载一个“+”方法。</p><h5 id="输入输出："><a href="#输入输出：" class="headerlink" title="输入输出："></a>输入输出：</h5><p>Java里主要有3种输出方式，或者说方法吧！上面的算一种：println(变量),即直接输出变量值，还带换行！第二种：printf(“%s”,string),这种再熟悉不过了，需要搭配格式符输出；第三种：print(变量)，同样直接输出值，只不过不带换行！以上都在lang包的System类下的out方法，返回PrintStream输出流类下的println()方法。</p><hr><h4 id="06-switch语句"><a href="#06-switch语句" class="headerlink" title="06 switch语句"></a>06 switch语句</h4><p>Java7增强了switch语句,原来从switch(expression)，表达式只能是byte , short , int , char四种，后来增加了枚举类型enum和String类型，但是不能为true/false布尔型 。相比c/c++的switch语句，多了byte,char(可以是单个中文字符)。需要注意的是：可以是String类型，而不是StringBuffer或StringBuilder字符串类型，即使都是字符串类型。</p><pre><code>String coder = &quot;coder小码&quot;;switch (coder){    case &quot;点赞&quot;:        System.out.println(coder);        break;    case &quot;收藏&quot;:        System.out.println(coder);        break;    case &quot;coder小码&quot;:        System.out.println(coder);        break;    default:        System.out.println(coder);}</code></pre><hr><h4 id="07-foreach循环"><a href="#07-foreach循环" class="headerlink" title="07 foreach循环"></a>07 foreach循环</h4><p>foreach循环是从Java5之后开始加入的，python语法里也有foreach循环，使用它进行遍历操作非常方便。那方便在哪呢？</p><ul><li>无需获得要遍历对象的长度，即不需要知道数组或集合多大</li><li>无需根据索引(下标)访问数组或集合(collection)的元素</li></ul><p>foreach语法如下：</p><pre><code>for(元素类型 循环变量: 数组或集合){    //要执行的代码块    System.out.println(循环变量);}</code></pre><p>从上面看出，foreach的循环将数组或集合中的元素临时赋值给了循环变量，后逐个输出，并没有改变数组的元素，即foreach虽好，但不能改变数组或集合的内容 或值。如果在循环内给循环变量进行赋值，同样不能改变其内容，反而将想要获得的数组的元素修改替换了。</p><hr><h4 id="08-数组类型"><a href="#08-数组类型" class="headerlink" title="08  数组类型"></a>08  数组类型</h4><p>在Java里数组类型有很大变化，以前在c/c++里，数组名就相当于一个指针，指向数组内存首地址。在Java中不是没有指针，只是指针这种概念被弱化了，很少提到，反而多出了引用这种类型，而数组就属于引用类型。</p><h5 id="数组的定义有两种方式："><a href="#数组的定义有两种方式：" class="headerlink" title="数组的定义有两种方式："></a>数组的定义有两种方式：</h5><pre><code>int[] coder;或int coder[];</code></pre><p>很明显，在引入引用的概念并支持unicode字符集后，选择第一种方式才符合Java的语法，不是说第二种就错了，而是第二种可读性太差，很容易看成是定义了一个int类型的以“coder[]”为变量名的数据，而第一种方式，int[]本身就是一种引用类型，而coder就是一个妥妥的引用变量。</p><h5 id="数组的初始化的3种方式："><a href="#数组的初始化的3种方式：" class="headerlink" title="数组的初始化的3种方式："></a>数组的初始化的3种方式：</h5><pre><code>第一种：coder = new int[] {3,2,1};第二种：coder = new int[3];第三种：int[] coder = {3,2,1};</code></pre><p>经典又常用的三种初始化方式，先说前两种吧。前两种都是在已经定义了数组的情况下进行初始化的，我们将第一种称做静态初始化，即初始化的时候就把元素值填了进去，这个时候数组就定了，长度不再改变。而第二种则可以称动态初始化，只是初始化他的长度，并没有赋值。第三种是第一种的简化，即把数组定义和静态初始化两步合一步。以上就是数组的诞生过程，可能有小伙伴会发牢骚：弄一个数组都这么麻烦，还没c/c++效率高呢！的确，c/c++是效率高，但上面之所以要带一个关键字new，其实是为了给数组分配一个内存并初始化赋值，尽管定义了一个数组变量，但只是引用变量而已，没有真正的存数据的内存，起到的也只是一个指向内存的作用，真正有内存是new一个给它。</p><hr><p>最后附上：<br><a href="https://GitHub.com/coderxm/" target="_blank" rel="noopener">github</a><br><a href="https://www.cnblogs.com/coderma" target="_blank" rel="noopener">博客园</a><br>微信公众号：小码之光</p><p> <img src="https://img-blog.csdnimg.cn/20200427213721746.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL server连接本地数据库的两个问题</title>
      <link href="/2020/0523/"/>
      <url>/2020/0523/</url>
      
        <content type="html"><![CDATA[<h4 id="SQL-Server连接本地数据库时的异常"><a href="#SQL-Server连接本地数据库时的异常" class="headerlink" title="SQL Server连接本地数据库时的异常"></a>SQL Server连接本地数据库时的异常</h4><p> 作者：coder小码</p><hr><p>最近想学点SQL server,几个月前下过，可中间电脑换过机名，重装过系统(电脑不是键盘一下没反应就是鼠标没反应)，充分暴露出windows的不稳定。这告诉我们：要早点和windows离婚吧，换一个漂亮又好用点的linux系统(关键是免费开源)，如果有钱可以跟风mac。哈哈！所以呢，系统里的环境变量全部没了，除了操作系统本身的变量外。经验告诉我们：换系统就是换血，把C盘的除系统外的渣渣都清除了，还好是其他盘的东西还在，不过又得手动配置她们的变量了。。。</p><hr><h5 id="01-SQL-SERVER初探"><a href="#01-SQL-SERVER初探" class="headerlink" title="01 SQL SERVER初探"></a>01 SQL SERVER初探</h5><p>初入SQL SERVER的可能不知道有两种版本分类的SQL SERVER，那现在就普及一下。第一种是MSSQL SERVER,全称是Microsoft SQL Sever，开发版，目前的大型网站一般使用Oracle或者MSSQL，JSP.PHP.ASP都可以。一般是企业级的商务网站使用的。全功能SQL数据库服务器，从2017版开始，横跨任何平台，完全免费。第二种是Express ，商业免费，有对应的限制一般都用这个。是SQL SERVER的简洁版，可以这样说。</p><p> 但开始我也不懂啊，也没人叫我怎么玩哈，所以最近发现SQL不见了，就急忙下个SQL server2019最新版的玩一下。不行的是下载了6个多G，连带管理工具一起下(都是开热点的流量啊！啊啊！)，N久后，才下完！然后安装！！！N久。</p><p>起初是发现从前的2017版的没有了，主要是SSMS没有，SSMS是SQL SERVER Management Studio,SQL SERVER管理工具，用来管理数据库的，而我们下的是SQL SERVER的一个下载工具罢了。没SSMS还是玩不起来。</p><hr><h5 id="02-第一个问题：配置管理器无法连接到-WMI-提供程序"><a href="#02-第一个问题：配置管理器无法连接到-WMI-提供程序" class="headerlink" title="02  第一个问题：配置管理器无法连接到 WMI 提供程序"></a>02  第一个问题：配置管理器无法连接到 WMI 提供程序</h5><p> 这个<strong>问题</strong>我记住你了，化成灰我都认得你！！</p><p> <img src="https://img-blog.csdnimg.cn/20200521170345860.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="配置管理器异常">弄了我一整晚，网上都查遍了，每个有效的方法。现在给大家清楚讲一遍，按上面的说，WMI,（Windows Management Instrumentation 即windows 管理规范）是一项核<br>心的 Windows 管理技术；<strong>用户可以使用 WMI 管理本地和远程计算机</strong>。简单点，就是管本地和远程计算机的一个东西。有点内味了！！也就是说要这个服务来帮助SQL配置管理器管理计算机的，那怎么管呢？</p><p>有两种解决方法：要么是没权限，弄权限；要么是服务器真的不能访问了，解决服务器。很明显，连自己的本地的机子，还说无法访问，那就是没权限啦。查查了半天，说要弄一个NETWORK SERVICE的权限，也弄了没反应，估计还不够吧！之后又有其他办法，说进如：”C:\Program Files (x86)\Microsoft SQL Server”里面，我的是这样的，里面是90‘100’120‘的数字文件夹(跟系统打交道的)，不是真正的SQL SERVER文件夹(有界面的那个)。</p><p>其中有一个shared文件夹里有150\Shared\sqlmgmproviderxpsp2up.mof这个文件。<br><img src="https://img-blog.csdnimg.cn/2020052117542694.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="sql~mof"></p><p>我的是150/，可能不一样。之后在命令行输入：</p><blockquote><p>mofcomp “C:\Program Files(x86)\Microsoft<br>SQLServer\150\Shared\sqlmgmproviderxpsp2up.mof”</p></blockquote><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200521173114764.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="将本地数据放到SQL储存库中"><br>将本地数据放到SQL储存库中了，就表示能访问到。那mof是个什么东西呢！</p><p><img src="https://img-blog.csdnimg.cn/20200521173617862.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="mof"></p><p> 反正就是微软瞎造的东西，跟配置有关。不管了！可以正常打开配置管理器，但是里面项目为空，啥也看不到呀！正常是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20200521174143779.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="正常"></p><p>但是右边什么也没有，而且，SSMS还是连不上本地的数据库实例。</p><hr><h5 id="第二个问题：系统找不到指定的文件"><a href="#第二个问题：系统找不到指定的文件" class="headerlink" title="第二个问题：系统找不到指定的文件"></a>第二个问题：系统找不到指定的文件</h5><p>GUI是这样的：<br><img src="https://img-blog.csdnimg.cn/20200521174341368.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="系统找不到指定的文件"><br>本来是输入个本机名字就行了，可就是死活连不上。SSMS: 想玩我？没门！这个时候，还是用的2017的SQL配置管理器，2019的SQLEXPRESS，连2019的配置管理器都没有，当然弄不了了。那之前的努力都白搭，花了我N久弄完！</p><p>其实挺简单的，一步解决上面两个问题，还能使用最新的2019SQL SERVER。对啦，就是重新安装，不用开浏览器上什么官网，直接follow me。哈哈！</p><p>找到SQL SERBER的安装目录，就是那个有安装的SQL server2019：</p><hr><p> D盘文件夹：<br> <img src="https://img-blog.csdnimg.cn/20200521180118799.PNG#pic_center" alt="SQL文件"></p><p>sqlserver文件夹里是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20200521181435401.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="新的本地实例MSSQL1.5"></p><p>之后一路默认安装：</p><p><img src="https://img-blog.csdnimg.cn/20200521180336817.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="SQL 安装中心"></p><hr><p>安装期间会同时实例化本地的数据库，以windows管理员的身份管理，完成后就能看到开始菜单里有2019配置管理器了：</p><p><img src="https://img-blog.csdnimg.cn/20200521180652720.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="开始菜单"></p><p>sercice服务里也会有SQL服务，之前是没有的，即使解决了第一个问题后。估计这就是第二个问题没解决的原因吧！没SQL server服务，就没得玩喽！</p><p><img src="https://img-blog.csdnimg.cn/20200521180951615.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="SQLsever服务"></p><hr><p>所以最后献上玩美结果：</p><p><img src="https://img-blog.csdnimg.cn/20200521181319650.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="连上了本地"></p><p>哈哈，如果要用Network service权限解决的话请参考<a href="https://blog.csdn.net/qq_17532383/article/details/45542605?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159005588419724811810680%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=159005588419724811810680&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-7-45542605.nonecase&utm_term=sql%E6%97%A0%E6%B3%95WMI" target="_blank" rel="noopener">另一篇</a><br>最后祝大家玩的愉快！！</p><hr><p>最后附上：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码csdn</a><br><a href="https://www.cnblogs.com/coderma" target="_blank" rel="noopener">博客园</a><br>微信公众号：小码之光</p><p> <img src="https://img-blog.csdnimg.cn/20200427213721746.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小码moneykeeper</title>
      <link href="/2020/0514/"/>
      <url>/2020/0514/</url>
      
        <content type="html"><![CDATA[<h3 id="纯c小项目，小码资金管理工具moneykeeper"><a href="#纯c小项目，小码资金管理工具moneykeeper" class="headerlink" title="纯c小项目，小码资金管理工具moneykeeper"></a>纯c小项目，小码资金管理工具moneykeeper</h3><p>作者：coderxm<br>公众号：小码之光</p><hr><p> 你小码哥回来啦！最近闷得慌，又在学java(自学，想走这条路，哎，一个人找到所爱的真的很难,说不定哪天真的挂了，就来不及了)，慢慢地觉得特别吃力了，主要是学习环境不好，住在一个‘破房子’里，人口又多，真的是烦，而且还不是自个家（没家）。有意识地数了数钱口袋，发现是真的穷死光，哎！！！郁闷啊啊啊！感觉连自个亲人都被抛弃地感觉！(<strong>除了自己，谁都别信！</strong>因为别指望他们能帮你买房买车，理解你的世界！) 总想做点什么，于是敲了敲几行代码，做了个小钱钱管理工具，以后方便看看钱兜(哎！)，自己觉得挺简单实用地就分享给大家了，源码也给哈！<br>下载地址        :    <a href="https://github.com/coderxm/moneykeeper.git" target="_blank" rel="noopener">小码理财moneykeeper</a></p><hr><h6 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h6><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt;#include&lt;conio.h&gt;// 户名结构体 typedef struct{    char hum[100];//    char money[10];}hums;// 构造函数void outdata(void); void empty(char *sf);void putdata(hums *hm);void qorw(hums *hm);int strint(char *s);int main(void){    hums zhanghu[11];    //定义户名结构体数组     char get[4];     char command[4];    FILE *fpr;    fpr = fopen(&quot;E:\\wokfilc\\moneykeeper\\data.txt&quot;,&quot;r&quot;);    fgets(get,5,fpr);    fclose(fpr);    if(get==&#39;\0&#39;||get==&quot; &quot;){        printf(&quot;无账户信息!&quot;);        qorw(zhanghu);    }else{        outdata();        printf(&quot;请继续写入wd或退出quit：\n&quot;);        scanf(&quot;%s&quot;,command);        if(strcmp(command,&quot;quit&quot;)==0){            exit(0);        }else if(strcmp(command,&quot;wd&quot;)==0){            putdata(zhanghu);            outdata();            qorw(zhanghu);        }else{            printf(&quot;输入错误，请重新输入：\n&quot;);            qorw(zhanghu);        }    }    return 0;} //输出信息 void outdata(){    FILE *fpr;    fpr = fopen(&quot;E:\\wokfilc\\moneykeeper\\data.txt&quot;,&quot;r&quot;);    int sum=0;    char DataStr[100];    printf(&quot;*****$$*****\n正在输出账户信息：\n&quot;);    while(feof(fpr)==0){        fseek(fpr,0L,SEEK_CUR);                //?        fgets(DataStr,100,fpr);        if(DataStr!=&#39;\0&#39;&amp;&amp;DataStr!=&quot; &quot;){            printf(&quot;%s \n&quot;,DataStr);        }                sum = sum+strint(DataStr);        empty(DataStr);    }     fclose(fpr);    printf(&quot;您的总资金合计为：%d元\n&quot;,sum);}//empty初始化清空数组 void empty(char *sf){    int sfsize = 0;    sfsize = sizeof(sf);     for(int n=0;n&lt;sfsize;n++){        sf[n] = &#39;\0&#39;;     }} //写入数据 void putdata(hums *hm){    FILE *fpw;    fpw = fopen(&quot;E:\\wokfilc\\moneykeeper\\data.txt&quot;,&quot;w+&quot;);    int i = 0;    char input[100];    printf(&quot;(回车)请写入账户数据：\n&quot;);    do{        int len = 0;        empty(input);         printf(&quot;请写入第%d个账户数据:\n&quot;,i+1);        scanf(&quot;%s&quot;,input);            len = strlen(input);        strcpy(hm[i].hum,input);         strcat(hm[i].hum,&quot;\n&quot;);        fputs(hm[i].hum,fpw);        i = i+1;    }while( (strcmp(input,&quot;end&quot;))!=0&amp;&amp;(i&lt;11) );    fclose(fpw);    //写入完毕后关闭文件 }//字符串中提取数字 int strint(char *s){    int slen=0;    int Money=0;    int ml = 0;    char money[10];    slen = strlen(s);    for(int n=0;n&lt;slen;n++){        if(s[n]&gt;=48&amp;&amp;s[n]&lt;=57){            money[ml]=s[n];            ml++;        }    }    Money = atoi(money);    return Money;}//选择（退出或重新写入）函数void qorw(hums *hm){    char getput[10];    printf(&quot;请选择(重新)输入wrdo或退出quit：\n&quot;);    scanf(&quot;%s&quot;,getput);    while(strcmp(getput,&quot;quit&quot;)!=0){        if(strcmp(getput,&quot;quit&quot;)==0){            return;        }else if(strcmp(getput,&quot;wrdo&quot;)==0){            putdata(hm);            qorw(hm);            return;        }else{            printf(&quot;重新输入,&quot;);            qorw(hm);            return;        }    }} </code></pre><hr><p>源码讲解就不用了吧！相信坚定走这路的人学过c，能看懂吧！主要是也让大家有个真实的现实观，好好管管小钱钱，别胡乱挥霍，以后说不定有大用处！至少能给你一个<strong>真正的家</strong>(一个固定的住处)！好啦！拜拜，学习去喽！</p><hr><p>最后：<br>个人站点：<a href="https://www.cnblogs.com/coderma" target="_blank" rel="noopener">博客园</a><br>公众号：<br><img src="https://img-blog.csdnimg.cn/20200513202720997.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> moneykeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疫情之下c又崛起！</title>
      <link href="/2020/0510/"/>
      <url>/2020/0510/</url>
      
        <content type="html"><![CDATA[<blockquote><p>已经5月份了，国内的疫情也渐渐的好转，人们也把目光放在了经济发展和工作上，拿着漫长的疫情期间，编程界有什么波动呢？</p></blockquote><p>据tiobe官网5月份最新数据显示，C语言在疫情结束后悄悄地登上排行第一位，这是继2015java霸着冠军宝座以来，c语言重新闪耀它的魅力。来看看数据：</p><p><img src="https://img-blog.csdnimg.cn/20200510071549355.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="5月排行"></p><p>从上面看出，c已经超过java1%，相差并不大，也就是说，java仍有其可用之处，短期内并不会被时代抛弃。同时也不意味着c能继续禅位。其中可以看到，以大数据、嵌入式为方向的语言如python、R有了明显的排名提升，这说明，在未来大数据、云计算及嵌入式的科技发展将占据一定的主导地位，并且将应用到人工智能领域，推动人工智能的进一步发展。</p><hr><p><strong>再来看看官网的解读</strong>：</p><p>Java和C在4月已经非常接近，但是本月C再次超越Java。C上一次成为第一名是在2015年。我们只能猜测C为什么再次成为第一名。原因之一可能是冠状病毒。这听起来很愚蠢，但是某些编程语言确实可以从这种情况中受益。例子是数据科学领域的Python和R，因为每个人都在寻找该病毒的解毒剂。但是嵌入式软件语言（例如C和C ++）也越来越流行，因为它们被用于医疗设备的软件中。另一方面，值得一提的是，Rust实际上已经接近前20名（一个月内从第27位上升到第21位）。Paul Jansen(保罗·詹森) TIOBE Software首席执行官 TIOBE编程社区索引是编程语言受欢迎程度的指标。索引每月更新一次。评级基于全球熟练的工程师，课程和第三方供应商的数量。<br><img src="https://img-blog.csdnimg.cn/20200510071720384.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="趋势"><br>诸如Google，Bing，Yahoo！，Wikipedia，Amazon，YouTube和Baidu等流行的搜索引擎用于计算评分。</p><blockquote><p> 重要的是要注意，TIOBE索引与最佳编程语言或大多数代码行所用的语言无关。该索引可用于检查您的编程技能是否仍然是最新的，或用于在开始构建新软件系统时就应采用哪种编程语言做出战略决策。TIOBE索引的定义可以在这里找到。</p></blockquote><p>看来官网已经为我们解释的非常好了，只不过有些话很罗嗦。我就不再跟着啰嗦一遍了，总之，c从疫情中发挥了很大的作用，这足以让看不上c的人开开眼。c还是很有作为的！只不过之前没发现而已。大家又在使用或学习哪种语言呢？</p><hr><p>最后：<br><a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">博客CSDN</a>：coder小码<br>公众号‘<strong>小码之光</strong>’：<br><img src="https://img-blog.csdnimg.cn/20200510071951248.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 疫情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java equals()函数与‘==&#39;</title>
      <link href="/2020/0509/"/>
      <url>/2020/0509/</url>
      
        <content type="html"><![CDATA[<h3 id="java-equals-函数与‘-’"><a href="#java-equals-函数与‘-’" class="headerlink" title="java equals()函数与‘==’"></a>java equals()函数与‘==’</h3><hr><blockquote><p>谈到java的字符串比较函数equals(),就不得不说它真真的用途啦！虽然只是java里面一个简单的知识点，还是有必要扯扯它，因为有许多学习java的小伙伴在比较字符串上纠结与equals()和‘==’的选择。</p></blockquote><hr><h4 id="equals-函数"><a href="#equals-函数" class="headerlink" title="equals()函数"></a>equals()函数</h4><p>函数原型：</p><blockquote><p>public boolean equals(Object anObject)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200509203330784.PNG#pic_center" alt="equals()"></p><p>函数用来比较<strong>字符串内容</strong>的相等，可以是字符串的变量String a = “coder小码”,字符串对象String a = new String(“coder小码”)之间或和同类型的字符串比较，只要是String就行。返回值是布尔值，true \ false,与类型是String或String对象没有关系，只要字符串内容一致，就返回true,否则false。</p><h6 id="字符对象比较"><a href="#字符对象比较" class="headerlink" title="字符对象比较"></a>字符对象比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509204232153.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符对象的比较"></p><h6 id="字符对象与字符String比较"><a href="#字符对象与字符String比较" class="headerlink" title="字符对象与字符String比较"></a>字符对象与字符String比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509204448284.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符对象与字符String比较"></p><h6 id="字符String之间比较"><a href="#字符String之间比较" class="headerlink" title="字符String之间比较"></a>字符String之间比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509204724918.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符String之间比较"></p><hr><h4 id="‘-’关系运算符的运用"><a href="#‘-’关系运算符的运用" class="headerlink" title="‘==’关系运算符的运用"></a>‘==’关系运算符的运用</h4><p>在编写代码的过程中我们经常用到‘==’ 运算符，那 它实质比较的是什么呢？其实也不很高深莫测，实质上是在比较引用指向的内存地址的，只要指向的内存地址相同，即可判断为true。</p><p>说到这里可能会有疑惑了，难道还比内存不成？咋回事啊？咱们先看看几个小例子：</p><h6 id="对象间的比较"><a href="#对象间的比较" class="headerlink" title="对象间的比较"></a>对象间的比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509205936508.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="对象间的比较"></p><h6 id="字符间的比较"><a href="#字符间的比较" class="headerlink" title="字符间的比较"></a>字符间的比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509210051416.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符间的比较"></p><h6 id="字符与字符对象的比较"><a href="#字符与字符对象的比较" class="headerlink" title="字符与字符对象的比较"></a>字符与字符对象的比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509210147114.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符与字符对象的比较"></p><h6 id="整型间比较"><a href="#整型间比较" class="headerlink" title="整型间比较"></a>整型间比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509210230950.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="整型间比较"></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上代码例子可以说明equals()只是用来比较字符串内容的，不涉及字符串值的地址，而‘==’用法就广泛一点，还能用来比较整形(不止整形和字符)，但实质上是比较是不是来自同一个地址，是就返回true，否则false。好啦，以上就是今天的内容，欢迎在下面留言哦！每一点都是知识的积累，希望学习躺赢，学习愉快！</p><hr><p>最后：<br><a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">博客CSDN</a>：coder小码<br>公众号‘<strong>小码之光</strong>’：<br><img src="https://img-blog.csdnimg.cn/20200509211320148.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> equals </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA启动加速与java编译</title>
      <link href="/2020/0506/"/>
      <url>/2020/0506/</url>
      
        <content type="html"><![CDATA[<h4 id="IJ-IDEA启动加速与java编译"><a href="#IJ-IDEA启动加速与java编译" class="headerlink" title="IJ IDEA启动加速与java编译"></a>IJ IDEA启动加速与java编译</h4><p>1.<strong>启动加速</strong><br>2.<strong>java编译</strong></p><hr><h5 id="01-启动加速"><a href="#01-启动加速" class="headerlink" title="01 启动加速"></a>01 启动加速</h5><p><img src="https://img-blog.csdnimg.cn/20200504113321417.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="tips"><br>忽然有一天IDEA说：你打开它“有点慢”，然后说：consider reducing the num of folder under antivirus protection. 这很有效！</p><p> 可能用IDEA的伙伴都会遇到这样的问题，这只是一个提示。那他说这很有效，到底个怎么有效呢？<em>consider reducing the num of folder under antivirus protection</em> 意思翻译过来 就是：考虑在病毒防护中排除启动器打开的文件。那具体咋弄？先看看官方解释：<br> <img src="https://img-blog.csdnimg.cn/20200504114120578.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70" alt="jetbrain"><br>再翻译一下：</p><blockquote><p>某些防病毒软件可能会干扰IDE的构建过程，从而导致构建的运行速度大大降低。 在IDE中运行构建时，会在计算机上创建许多类文件。<br>如果您的防病毒软件启用了实时扫描，则防病毒软件可以在每次创建文件时强制停止构建过程，而防病毒软件会扫描该文件。</p><p>如果您使用的是Windows Defender，则IDE会自动检查您是否启用了实时扫描，以及是否将扫描配置为处理IDE写入大量文件的目录。</p><p>IDE提供了一种可能性，可以从自动扫描中排除那些目录（此功能在2019.2+ IDE版本中可用）。</p><p>如果您希望手动执行必要的配置，则可以按照以下步骤进行：</p><pre><code> 点击开始按钮 输入“ Windows安全性” 点击“病毒和威胁防护” 点击“病毒和威胁防护设置”下的“管理设置” 如果需要，请向下滚动，然后单击“添加或删除排除项” 对于通知中显示的每个文件夹，请按+按钮，从菜单中选择“文件夹”，然后选择该文件夹。</code></pre></blockquote><p> 官方都非常详细地解释了一番，打开IDEA慢的原因受到电脑自带的杀毒软件的影响，使IDEA不能构建文件。</p><hr><h5 id="02-java编译"><a href="#02-java编译" class="headerlink" title="02 java编译"></a>02 java编译</h5><p>有些刚玩IDEA的小伙伴在创建java文件后不知如何编译，大家都知道点击RUN编译运行就可以了，但那是编译带运行输出结果，如果是没有主函数main()呢，只是想编译呢？</p><p> 接下来我们介绍三种编译方式：</p><blockquote><p> Compile、Make和Build的区别</p></blockquote><p>针对开发工具，一般都有Compile、Make和Build三个菜单项，完成的功能的都差不多，但是又有区别。编译，是将源代码转换为可执行代码的过程。编译需要指定源文件和编译输出的文件路径（输出目录）。Java的编译会将java编译为class 文件，将非java的文件（一般成为资源文件、比如图片、xml、txt、poperties等文件）原封不动的复制到编译输出目录，并保持源文件夹的目 录层次关系。</p><p>在Java的集成开发环境中，比如Eclipse、IDEA中，有常常有三种与编译相关的选项<strong>Compile、Make、Build</strong>三个选项。这三个选项最基本的功能都是完成编译过程。但又有很大的区别：</p><blockquote><p>1、Compile：只编译选定的目标，不管之前是否已经编译过。</p></blockquote><blockquote><p>2、Make：编译选定的目标，但是Make只编译上次编译变化过的文件，减少重复劳动，节省时间。（具体怎么检查未变化，这个就不用考虑了，IDE自己内部会搞定这些的）</p></blockquote><blockquote><p>3、Build：是对整个工程进行彻底的重新编译，而不管是否已经编译过。Build过程往往会生成发布包，这个具体要看对IDE的配置了，Build在实际中应用很少，因为开发时候基本上不用，发布生产时候一般都用ANT等工具来发布。Build因为要全部编译，还要执行打包等额外工 作，因此时间较长。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200504115100594.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="编译"><br>·</p><hr><p>··················································END························································</p><p>以后编译不用迷迷糊糊的去编译啦！对于IEAD的启动Tips，有些人可能会厌烦，但作为一款风靡全球的智能开发软件，还是对新入门的小鸟有很大帮助的，用习惯了，就想说：“<strong>真香</strong>！”</p><hr><p> 最后写作不易：关注我吧(小码之光)<br><a href="https://www.maliaoblog.cn">博客</a>：<a href="http://www.maliaoblog.cn">www.maliaoblog.cn</a><br><img src="https://img-blog.csdnimg.cn/20200504120421301.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息轰炸</title>
      <link href="/2020/0504/"/>
      <url>/2020/0504/</url>
      
        <content type="html"><![CDATA[<h4 id="消息轰炸器-c语言版"><a href="#消息轰炸器-c语言版" class="headerlink" title="消息轰炸器(c语言版)"></a>消息轰炸器(c语言版)</h4><p> C语言学着学着都感觉没啥用，但是事情没有你想的那样枯燥！C还是很有作为的，比如简单的QQ消息轰炸，原理其实很简单！如有需要或了解可关注下面的微信公众号：<strong>小码之光</strong>，回复<strong>消息轰炸</strong>即可获得源码和轰炸器及使用说明。</p><p><img src="https://img-blog.csdnimg.cn/20200503183114618.jpg#pic_center" alt="小码之光"></p><hr><p>话不多说，既然是个成品，就爽快地拿出来：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main(){    int i;    char name[100];    printf(&quot;目标：&quot;);    scanf_s(&quot;%s&quot;,&amp;name,40);    printf(&quot;次数：&quot;);    scanf_s(&quot;%d&quot;,&amp;i);    HWND H = FindWindow(0,name);    //寻找对话框     while(i--&gt;0){        SendMessage(H,WM_PASTE,0,0);    //粘贴         SendMessage(H,WM_KEYDOWN,VK_RETURN,0);//回车     }} </code></pre><h5 id="原理介绍："><a href="#原理介绍：" class="headerlink" title="原理介绍："></a>原理介绍：</h5><blockquote><p> &lt;windows.h&gt;这个头文件大家很少接触到，里面是一些有关操作系统地接口函数，实际上它是windows的一部分。</p></blockquote><p>scanf_s()函数的用法和scanf()类似，只不过要两个参数，函数原型为</p><pre><code>int scanf_s( const char *format ，[argument]);</code></pre><p>这个函数原型不是太精确，大概来说是这样的，&amp;name为输入需要的储存地址（数组首地址），第二个40为输入大小的限制（40字节）。这个函数是微软之后加上去的，相比scanf()，有输入限制，更安全。</p><p>HWND H是定义了一个句柄，本质上是一个指针，指向窗口。FindWindow()函数用来寻找窗口，所以输入给name数组的为窗口标题。第一个参数是个位常量字符串指针，可以不用管。</p><p>sendmessage()函数很明显用来发消息，发消息第一步肯定是先把消息粘贴，然后enter键发送啦！第一个参数为句柄，第二个为发消息的类型，比如粘贴或按键，后面的参数为具体按键操作。应该能理解。</p><p>i–&gt;0 的意思就是，先判断i是否大于0（大于0，表达式的值为1，否则为0，这个结果将用于while的条件），然后将 i 的值减1。while语句，权如果括号内的值为0，则跳出while循环， 只要括号内的值不为0，则继续循环。 这个大家都学过也能理解。</p><hr><blockquote><p>ok，以上代码就不难弄懂了，好啦，感兴趣的话，可以关注我的公众号进一步了解，希望大家学习c更快乐学习躺赢哦！！哈哈！</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200503192355721.gif#pic_center" alt="学习躺赢"></p><hr><p> 最后：<br>个人博客：<a href="https://www.maliaoblog.cn">https://www.maliaoblog.cn</a><br>公众号：小码之光</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++高级编程</title>
      <link href="/2020/0501/"/>
      <url>/2020/0501/</url>
      
        <content type="html"><![CDATA[<h4 id="c-高级编程介绍"><a href="#c-高级编程介绍" class="headerlink" title="c++高级编程介绍"></a>c++高级编程介绍</h4><p>   学c++确实是件痛苦的事，这水平得一步步抬上去，实话说学校教的也不好，就更痛苦了，还要学这学那，对技术没半点提升。最近就在学这个，没得方向，只好自己归纳了。嘤！嘤！<br>   <img src="https://img-blog.csdnimg.cn/20200429165631459.jpg#pic_center" alt="嘤嘤"></p><hr><h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ul><li>预处理</li><li>模板</li><li>命名空间</li><li>文件和流</li><li>动态内存分配</li><li>异常处理</li><li>信号处理</li><li>多线程</li><li>web编程</li></ul><hr><p><img src="https://img-blog.csdnimg.cn/20200429190054196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="知识图"></p><hr><h5 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h5><h6 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h6><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。所有的预处理器指令都是以井号（#）开头，和C语言一样，也不是c++语句。C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等。</p><p><strong>define 预处理</strong></p><p>#define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：</p><pre><code>#define 宏 替代文本 </code></pre><p>这里的宏可以当成常量，书本上一般都大写。但不是非得大写，可以小写，只是在以后的学习上有一个好习惯。其他的宏就不一一介绍了。</p><p><strong>预定义宏</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429170234837.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="预定义宏"></p><p><strong>#运算符</strong></p><p> 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把替换文本令牌转换为用引号引起来的字符串。<br> <img src="https://img-blog.csdnimg.cn/20200429170741843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70" alt="#"><br> <strong>条件编译</strong><br> 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。条件预处理器的结构与 if 选择结构很像。<br><img src="https://img-blog.csdnimg.cn/20200429171048730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70" alt="条件编译"></p><hr><h5 id="02-模板"><a href="#02-模板" class="headerlink" title="02 模板"></a>02 模板</h5><p>模板是c++一个很重要的概念，模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p><p>上面是c++自己说的，讲的这么高尚，都把自己讲糊涂了！简单去讲，模板可以理解为一种基本模样，可以用来创建函数或者类，或者别的，只是还不到变量的类型。需要注意的是模板可不是类，也就是没有特定的类型啦！</p><p><strong>函数模板</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429172124168.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="函数模板">)图中的T是无特定类型，整个用法有点像函数重载一样，至少重载需要定义不同的同名函数，参数输入也要不一样，有了模板，代码量就减少了，套模板就是。当输入的是整型时，则T为整形进行运算，其余类似。关于刚才的重载和inline内联可参考上次的文章：<a href="https://blog.csdn.net/gobullin/article/details/105798076" target="_blank" rel="noopener">c++面向对象吗？不懂看这个</a></p><p><strong>类模板</strong></p><p>在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型。<br><img src="https://img-blog.csdnimg.cn/20200429173329417.PNG#pic_center" alt="类模板"></p><p><img src="https://img-blog.csdnimg.cn/20200429173646951.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="类模板"><br>以上就是几个常见的模板，如果真要一个类型去归纳的话，c++给了一个高大上的名字：<strong>泛型</strong>，一个宽泛的类型。。。。</p><hr><h5 id="03-命名空间"><a href="#03-命名空间" class="headerlink" title="03 命名空间"></a>03 命名空间</h5><p>在c++中，一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。因此，引入了命名空间这个概念，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个<strong>范围</strong>。<br><img src="https://img-blog.csdnimg.cn/20200429174417484.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="图解"><br><strong>特定命名</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200429174452299.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="命名namespace">然而，以上命名空间的函数前，都加了空间名，我们可以用using指令省去，即using namespace 空间名 就可以省去了，例：</p><p>using namespace std;</p><p>cout &lt;&lt; ‘小码之光’ &lt;&lt;endl;<br> 而不是std::cout/endl</p><p><strong>嵌套命名</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429175303338.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="嵌套命名"></p><hr><h5 id="04-文件和流"><a href="#04-文件和流" class="headerlink" title="04 文件和流"></a>04 文件和流</h5><p>C++ 中另一个标准库 fstream，它定义了三个新的数据类型：<br><img src="https://img-blog.csdnimg.cn/20200429175459819.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="文件io"><br>以上三个理解：<br>ofstream:out-file-stream写文件;<br>ifstream:in-file-stream读文件;<br>fstream:file-stream读写;</p><p><img src="https://img-blog.csdnimg.cn/20200429180035780.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="读写模式"><br>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，即需要<strong>先创建文件对象</strong>，如果只需要打开文件进行读操作，则使用 ifstream 对象。和c里的文件读取一样，c++也有打开模式。不过有点不同。</p><p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><p>void open（文件名, ios::打开模式);</p><p><img src="https://img-blog.csdnimg.cn/20200429180141903.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="例"><br>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p><p>close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><hr><h5 id="05-动态内存"><a href="#05-动态内存" class="headerlink" title="05 动态内存"></a>05 动态内存</h5><p><strong>关键字</strong>new\delete<br>堆是程序中未使用的内存，在程序运行时可用于动态分配内存。使用new 运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。</p><p><strong>数组</strong><br><img src="https://img-blog.csdnimg.cn/20200429181216147.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="动态分配"><strong>对象</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429181424810.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="对象分配"></p><hr><h5 id="06-异常处理"><a href="#06-异常处理" class="headerlink" title="06 异常处理"></a>06 异常处理</h5><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p><p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。<br>··································································································<br>   throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。<br>   catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕    获异常。<br>    try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。<br>····································································································</p><p><img src="https://img-blog.csdnimg.cn/20200429181940957.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="异常处理"><br><img src="https://img-blog.csdnimg.cn/20200429182015771.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="捕获异常"><br>C++ 提供了一系列标准的异常，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200429182113676.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="异常说明"><br><strong>自定义异常</strong></p><p><img src="https://img-blog.csdnimg.cn/2020042918221952.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="自定义"></p><hr><h5 id="07-信号处理"><a href="#07-信号处理" class="headerlink" title="07 信号处理"></a>07 信号处理</h5><p>信号是由操作系统传给进程的中断，会提早终止一个程序。不是我们一般意义上的信号。这些信号是定义在 C++ 头文件csignal 。</p><p><img src="https://img-blog.csdnimg.cn/20200429182634851.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="信号">C++ 信号处理库csignal提供了 signal 函数，用来捕获突发事件。<br><strong>signal函数</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429182924504.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="signal"><br><strong>raise函数</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429183036845.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="raise"></p><hr><h5 id="08-多线程"><a href="#08-多线程" class="headerlink" title="08 多线程"></a>08 多线程</h5><p>在高级语言编程里，总是会听到多线程，一些大厂面试也会提到多线程，那多线程有多厉害多神秘呢？</p><p>这里又要扯上专业课了，多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。</p><pre><code>基于进程的多任务处理是程序的并发执行。基于线程的多任务处理是同一程序的片段的并发执行。</code></pre><p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。通俗的说就是，计算机干活时候，将以一个进程为单位，处理一个要执行的程序，比如要打开的QQ，但不能一股脑把它干了，还有别的程序要运行呢。所以进程在内存上是间隔的，运行一个程序，计算机把很大的可执行文件分成若干部分去执行，每一部分以线程(都这么叫)的形式执行，这样就有了多线程处理。</p><p><strong>创建线程</strong>：<br>    #include &lt;pthread.h&gt;<br>    pthread_create (thread, attr, start_routine, arg) ；</p><p><img src="https://img-blog.csdnimg.cn/20200429184556582.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="参数"><br><strong>终止线程</strong></p><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p><p>#include &lt;pthread.h&gt;<br>pthread_exit (status) ；</p><p>在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止</p><p><strong>线程连接与分离</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429185150937.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="线程连接分离">)<img src="https://img-blog.csdnimg.cn/20200429185212778.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="lianjie"><br>··············································································································<br><img src="https://img-blog.csdnimg.cn/20200429185308444.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="c11"></p><hr><h5 id="09-web编程"><a href="#09-web编程" class="headerlink" title="09 web编程"></a>09 web编程</h5><p> 除了线程难以外，web编程学起来也很费劲，对初学者一点也不友好。所以在这里就不做过多累赘了。要学的太多了！就简单介绍一下公共网关接口（CGI），公共网关接口（CGI）是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的，是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。如果要深入学习就寻找相关的书籍资料吧！(进公众号也行，问小码要哦，尽量帮你弄到， 写作不易，客官赏一个！)<br><img src="https://img-blog.csdnimg.cn/2020042919130999.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="拽"></p><hr><p>更多尽在微信公众号小码之光</p><p>博客：<a href="http://www.maliaoblog.cn">www.maliaoblog.cn</a><br> 推荐：<br>    《Essential C++ 中文版》<br>    《C++ Primer Plus 第6版中文版》<br>    《C++ Primer中文版（第5版）》</p><p>··················································END·························································</p><p> 微信公众号    ：小码之光（免费资料等你拿哦，文章公众号首发！二维码7天有效）<br> <a href="https://mp.weixin.qq.com/s/C-IDOjM245by-U_mBzPV2Q" target="_blank" rel="noopener">项目资料</a></p><p> <img src="https://img-blog.csdnimg.cn/20200429190944279.jpg#pic_center" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++对象？看看这个</title>
      <link href="/2020/0428/"/>
      <url>/2020/0428/</url>
      
        <content type="html"><![CDATA[<h3 id="深入理解c-面向对象几大特性"><a href="#深入理解c-面向对象几大特性" class="headerlink" title="深入理解c++面向对象几大特性"></a>深入理解c++面向对象几大特性</h3><hr><ul><li>类</li><li>继承</li><li>重载</li><li>多态</li><li>数据抽象</li><li>数据封装</li><li>抽象类及实例化</li></ul><hr><p><img src="https://img-blog.csdnimg.cn/20200427194118832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="思维图"></p><hr><h4 id="01-类"><a href="#01-类" class="headerlink" title="01 类"></a>01 类</h4><p>类是 C++ 的核心特性，通常被称为用户定义的类型。也就是说，它和其他基本类型一样(浅显的这么说)，都是type。类定义是以关键字 class 开头，后跟类的名称。由类可以生成对象，这里，对象可以理解为变量，一种特殊类型的变量，相当于c语言中的struct结构体类型变量。</p><hr><h4 id="02-类成员函数"><a href="#02-类成员函数" class="headerlink" title="02 类成员函数"></a>02 类成员函数</h4><p>类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。也可以在类的外部使用范围解析运算符 :: 定义该函数</p><p><img src="https://img-blog.csdnimg.cn/20200427195444481.PNG#pic_center" alt="范围解析"></p><p>需要强调一点，在 :: 运算符之前必须使用类名，调用成员函数是在对象上使用点运算符（.）。</p><hr><h4 id="03-类访问修饰符"><a href="#03-类访问修饰符" class="headerlink" title="03 类访问修饰符"></a>03 类访问修饰符</h4><p>访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。</p><p>公有成员在程序中类的外部是可访问的(public)，即可以通过(对象.成员)或内部的public调用函数访问。</p><p> 私有成员(private)则不同，那只能通过类内部的调用函数访问或修改，这时的内部public函数相当于链接类内外的桥梁，而不能用(对象.成员)去访问了，即便是继承了的子类(派生类)也不能这样调用私有成员。除了protected。</p><p> 保护成员(protected)像私有成员一样，不能直接访问，需要使用内部函数，但区别就体现在继承的子类上，子类则可以直接通过(对象.成员)调用成员。</p><p><img src="https://img-blog.csdnimg.cn/20200427202735199.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="protected"></p><hr><h4 id="04-析构与构造函数"><a href="#04-析构与构造函数" class="headerlink" title="04 析构与构造函数"></a>04 析构与构造函数</h4><p>类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p><p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><p>下面的实例有助于更好地理解析构函数的概念：</p><p><img src="https://img-blog.csdnimg.cn/20200427203150275.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="构造函数"></p><hr><h5 id="拷贝构造函数："><a href="#拷贝构造函数：" class="headerlink" title="拷贝构造函数："></a>拷贝构造函数：</h5><p>拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</p><p><img src="https://img-blog.csdnimg.cn/20200427203553626.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="拷贝构造函数"></p><h4 id="05-友元函数"><a href="#05-友元函数" class="headerlink" title="05 友元函数"></a>05 友元函数</h4><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend。</p><p><img src="https://img-blog.csdnimg.cn/20200427203814283.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="友元函数"><br>注意：友元函数不是类成员函数，但有很厉害的通行证，能访问所以成员，同时也不能被子类继承，要访问不能用(对象.函数)。</p><hr><h4 id="06-内联函数"><a href="#06-内联函数" class="headerlink" title="06 内联函数"></a>06 内联函数</h4><p> 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p><pre><code>1.在内联函数内不允许使用循环语句和开关语句；2.内联函数的定义必须出现在内联函数第一次调用之前；</code></pre><hr><h4 id="07-this指针"><a href="#07-this指针" class="headerlink" title="07 this指针"></a>07 this指针</h4><p>每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p><p>this 指针是所有成员函数的隐含参数，即this已经事先定义好了，不用再声明了。友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。用法与c中结构体类似，指向对象。</p><hr><h4 id="08-指向类的指针"><a href="#08-指向类的指针" class="headerlink" title="08 指向类的指针"></a>08 指向类的指针</h4><p>指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。访问指向类的指针的成员，需要使用成员访问运算符 -&gt;，就像访问指向结构的指针一样。与所有的指针一样，必须在使用指针之前，对指针进行初始化。</p><hr><h4 id="09-静态成员"><a href="#09-静态成员" class="headerlink" title="09 静态成员"></a>09 静态成员</h4><p>使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。</p><p><img src="https://img-blog.csdnimg.cn/20200427210152476.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="静态成员函数"></p><hr><h4 id="10-继承"><a href="#10-继承" class="headerlink" title="10 继承"></a>10 继承</h4><p>创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。<br> 如：<br>class 继承类: 访问修饰符 基类；</p><hr><h4 id="11-多继承"><a href="#11-多继承" class="headerlink" title="11 多继承"></a>11 多继承</h4><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：</p><p>class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…<br>{<br>&lt;派生类类体&gt;<br>};</p><hr><h4 id="12-函数重载"><a href="#12-函数重载" class="headerlink" title="12 函数重载"></a>12 函数重载</h4><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。</p><p><img src="https://img-blog.csdnimg.cn/2020042721070710.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="重载">)<img src="https://img-blog.csdnimg.cn/20200427210731932.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="重载"></p><hr><h4 id="13-运算符重载"><a href="#13-运算符重载" class="headerlink" title="13 运算符重载"></a>13 运算符重载</h4><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。成员运算符重载：</p><p>Box operator+(const Box&amp;);</p><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，那这样子类也不能继承，如下所示：</p><p>Box operator+(const Box&amp;, const Box&amp;);</p><p><img src="https://img-blog.csdnimg.cn/20200427211346583.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="重载函数"></p><h6 id="重载决策："><a href="#重载决策：" class="headerlink" title="重载决策："></a>重载决策：</h6><p>上面的print()函数用了3次，仔细看都是不一样类型的参数，接下来在主函数main里调用了3次，所以内部有一个重载决策机制判断输入的参数类型该定义哪一个函数后调用。</p><hr><h4 id="14-多态"><a href="#14-多态" class="headerlink" title="14 多态"></a>14 多态</h4><p>就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数(即使成员函数名相同)时，会根据调用函数的对象的类型(意味着在基类上产生了不同的派生类)来执行不同的函数。</p><p><img src="https://img-blog.csdnimg.cn/20200427212119939.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="多态"></p><hr><h4 id="15-数据抽象与封装"><a href="#15-数据抽象与封装" class="headerlink" title="15 数据抽象与封装"></a>15 数据抽象与封装</h4><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。使用类来定义我们自己的抽象数据类型（ADT），可以使用类 iostream 的 cout 对象来输出数据到标准输出，而不需要知道如何实现。说简单点就是要用到接口之类的，从而来方便调用操作数据。</p><p>数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。</p><hr><h4 id="16-抽象类"><a href="#16-抽象类" class="headerlink" title="16 抽象类"></a>16 抽象类</h4><p>C++ 接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示：<br>class Box<br>{<br>   public:<br>      // 纯虚函数<br>      virtual double getVolume() = 0;<br>   private:<br>      double length;      // 长度<br>      double breadth;     // 宽度<br>      double height;      // 高度<br>};</p><p>设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p><p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为具体类。</p><p><img src="https://img-blog.csdnimg.cn/20200427212858552.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="抽象类"><br>说白了，这术语本质上就是个接口，以供调用。这些人说的这么高大上，最后把大家都弄晕了。好了以上就是给大家一个柳暗花明，希望有帮助在学习c++的路上！</p><p><img src="https://img-blog.csdnimg.cn/20200427213257990.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="哈哈"><br> 最后附上：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码csdn</a><br> 微信公众号：小码之光<br> <img src="https://img-blog.csdnimg.cn/20200427213721746.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还要翻墙？试试这个</title>
      <link href="/2020/0427/"/>
      <url>/2020/0427/</url>
      
        <content type="html"><![CDATA[<p>想看看国外的风光吗？疫情期间就像挂在家的咸鱼一样，快发酵了！点开浏览器，可是只能在国内的网站上静静地划过，没有一点新鲜事。可是想上外网又被墙，怎么办？</p><p><img src="https://img-blog.csdnimg.cn/20200426223714317.jpg#pic_center" alt="咋办"></p><p>  哈哈!客官别着急，我这就给您上‘菜’。咱们开了浏览器，最好是火狐的，在设置里的附加组件中的扩展里搜索谷歌上网助手Ghelper(在插件商店里也行)</p><p><img src="https://img-blog.csdnimg.cn/20200426225107588.jpg#pic_center" alt="gao"></p><p><img src="https://img-blog.csdnimg.cn/20200426223824507.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="插件"></p><hr><p>接下来很简单，添加这个插件就行了，添加如下</p><p><img src="https://img-blog.csdnimg.cn/20200426223918722.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="ghelper"><br>on开启上网策略，在这之前需要配置隐私设置。找到该插件，点击管理，允许在隐私窗口运行即可。<br><img src="https://img-blog.csdnimg.cn/20200426224000741.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="ghelper"><br><img src="https://img-blog.csdnimg.cn/20200426224038620.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="开启后台运行"></p><hr><p><img src="https://img-blog.csdnimg.cn/20200426224215506.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="excited"></p><hr><pre><code>客官：太好了！！！！！小码：先别太过于兴奋，咱们先试试看，到底能不能上像youtube这样的外网。客官：那好，快试试！</code></pre><p><img src="https://img-blog.csdnimg.cn/20200426224442361.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="youtube"></p><hr><p>行啦！！（可能需要验证邮件）没问题！不过是走日本的线路，所以才有日语，可以换换别的，就有别的语言选择。</p><pre><code>客官：嗯，不错！开动！小码：莫急，咱再试试！</code></pre><p><img src="https://img-blog.csdnimg.cn/20200426225236528.jpeg#pic_center" alt="tm"></p><p>进入face看看，来到了奥巴马的主页。。。。</p><p><img src="https://img-blog.csdnimg.cn/2020042622455269.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="obama"></p><hr><p>又进入了</p><p><img src="https://img-blog.csdnimg.cn/20200426224651912.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="威尔史密斯"></p><hr><pre><code>​客官：你tm又个P啊！开动！开动！</code></pre><p>小码：好的好的，喜欢的话就关注我哦！哈哈！<br>blog：<a href="https://www.maliaoblog.cn">小码blog</a><br> 微信公众号：小码之光<br> <img src="https://img-blog.csdnimg.cn/20200426225554247.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ghelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtualbox虚拟机安装</title>
      <link href="/2020/0425/"/>
      <url>/2020/0425/</url>
      
        <content type="html"><![CDATA[<h4 id="用虚拟机virtualbox安装ubantu桌面系统"><a href="#用虚拟机virtualbox安装ubantu桌面系统" class="headerlink" title="用虚拟机virtualbox安装ubantu桌面系统"></a>用虚拟机virtualbox安装ubantu桌面系统</h4><ul><li>下载ubantu镜像</li><li>下载安装虚拟机</li><li>新建一个虚拟电脑Linux01</li><li>安装ubantu镜像</li><li>（网络设置）</li></ul><hr><h5 id="01-下载ubantu镜像"><a href="#01-下载ubantu镜像" class="headerlink" title="01 下载ubantu镜像"></a>01 下载ubantu镜像</h5><p>要想在虚拟机里玩ubantu，就要先准备好该系统的iso镜像文件，那么我们就直接到了官网去了</p><p><img src="https://img-blog.csdnimg.cn/20200425111147300.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="官网"><br>可是我们点击下载后速度又慢了，比github还慢，原因就不说了。所以当然有更快的方法啦！不一定非要去国外的官网下载，国内的各大高校和巨头都有镜像站提供免费的镜像下载，这里就给大家推荐一番。</p><h6 id="阿里云开发者社区镜像站"><a href="#阿里云开发者社区镜像站" class="headerlink" title="阿里云开发者社区镜像站"></a><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">阿里云开发者社区镜像站</a></h6><p><img src="https://img-blog.csdnimg.cn/20200425111743145.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="阿里镜像站"><br>第一个就是ubantu,这里可以下server或desktop都可以，反正又快又免费！哈哈</p><h6 id="浙大镜像站"><a href="#浙大镜像站" class="headerlink" title="浙大镜像站"></a><a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">浙大镜像站</a></h6><p> 为什么选择浙江大学的镜像站呢？国内有很多这样的镜像站啊。。。。当然是快啦，相比较其他大学的站点，算是比较好了。</p><p><img src="https://img-blog.csdnimg.cn/20200425112624418.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="浙大镜像站"></p><p> 我是在阿里云下的，起初弄不清server和desktop版，就先下了server版，结果就是疑惑了半天，也没出现漂亮的界面。<br> <img src="https://img-blog.csdnimg.cn/20200425112906835.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="命令行"></p><hr><h5 id="02-安装oracle-virtualbox虚拟机"><a href="#02-安装oracle-virtualbox虚拟机" class="headerlink" title="02 安装oracle virtualbox虚拟机"></a>02 安装oracle virtualbox虚拟机</h5><p>这个就有点难下了，我没在镜像站里找，在网盘下的。(VMware需要许可证)这里大家可以搜一搜，分享<a href="https://pan.baidu.com/s/13mubMuemzTbLApTyxJXQVQ" target="_blank" rel="noopener">VM</a></p><p>提取码：vz1h</p><p>下载好安装包后，打开就行了</p><p><img src="https://img-blog.csdnimg.cn/20200425115703159.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="安装完成"></p><hr><h5 id="03-新建虚拟电脑Linux01"><a href="#03-新建虚拟电脑Linux01" class="headerlink" title="03 新建虚拟电脑Linux01"></a>03 新建虚拟电脑Linux01</h5><p>点击新建，选择要安装的系统，之后就是一路默认。</p><p><img src="https://img-blog.csdnimg.cn/20200425120535645.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="新建"><br> 内存最好配置在2G以上</p><p><img src="https://img-blog.csdnimg.cn/20200425120650265.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="内存"></p><hr><h5 id="04-安装ubantu镜像"><a href="#04-安装ubantu镜像" class="headerlink" title="04 安装ubantu镜像"></a>04 安装ubantu镜像</h5><p>虽然已经有一个虚拟电脑了(其实就是占用宿主机的磁盘空间)，这个时候只有硬件上的支持，还没有系统文件的调用。所以咋们进入启动Vbox界面的设置项</p><p><img src="https://img-blog.csdnimg.cn/20200425121253258.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="设置"></p><p>红色箭头那点击进入，再点击注册项，即可从宿主机文件里选择下载好的ubantu镜像文件</p><p><img src="https://img-blog.csdnimg.cn/20200425121517698.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="注册"><br>ok,配置好后，再启动虚拟电脑，就进入ubantu系统安装界面了，而不是命令行。</p><p><img src="https://img-blog.csdnimg.cn/2020042512174573.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="ubantu界面"></p><pre><code> 接下来就是安装了 </code></pre><p><img src="https://img-blog.csdnimg.cn/20200425122022310.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 这里可以选择试用或者安装ubantu，安装后启动就直接进入虚拟电脑工作界面了。</p><p><img src="https://img-blog.csdnimg.cn/20200425122834737.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="ubantu"><br> 界面还是很漂亮的，不过virtualbox是小型机，界面不能全屏，如果可能还是选VMware虚拟机吧，试过，感觉就是香！哈哈！</p><hr><h5 id="05-网络设置"><a href="#05-网络设置" class="headerlink" title="05 网络设置"></a>05 网络设置</h5><p> 这里就不过多讲了，建好后可以配置网络，有自己的cdn节点。推荐<a href="https://www.bilibili.com/video/BV1bA411b7vs" target="_blank" rel="noopener">程序羊</a></p><hr><p>附：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码csdn</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubantu </tag>
            
            <tag> virtualbox虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitpage CDN加速配置与深入</title>
      <link href="/2020/0421/"/>
      <url>/2020/0421/</url>
      
        <content type="html"><![CDATA[<h3 id="github-page-cdn加速服务深入了解"><a href="#github-page-cdn加速服务深入了解" class="headerlink" title="github page cdn加速服务深入了解"></a>github page cdn加速服务深入了解</h3><ul><li>CDN介绍</li><li>CDN提供商</li><li>github page cdn加速服务配置</li><li>CDN加速服务深入</li></ul><h4 id="CDN介绍"><a href="#CDN介绍" class="headerlink" title="CDN介绍"></a>CDN介绍</h4><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术…..</p><p>上面是百度的介绍，啰嗦了一大堆，说白了就是让坐在电脑前的用户就近的获取需要的网络资源，而不用跑去访问遥远的服务器了。既然这么好，那就用呗！国内外都有一些这样的CDN服务提供商，但是大家都知道，访问外面的网络很费劲的。国内的一些CDN提供商也有不少，服务也不错，就给大家推荐一下。</p><h4 id="CDN提供商"><a href="#CDN提供商" class="headerlink" title="CDN提供商"></a>CDN提供商</h4><h6 id="阿里云CDN-DCDN全站加速"><a href="#阿里云CDN-DCDN全站加速" class="headerlink" title="阿里云CDN/DCDN全站加速"></a>阿里云CDN/DCDN全站加速</h6><p><img src="https://img-blog.csdnimg.cn/20200421103618200.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="阿里云CDN">阿里云的CDN加速服务应该算是不错了，支持国内外和全球加速，这里选择全站加速会比较好一点。</p><h5 id="腾讯云CDN"><a href="#腾讯云CDN" class="headerlink" title="腾讯云CDN"></a>腾讯云CDN</h5><p>巨头们总是这么滴强。。。腾讯云内同样提供比较哟西的CDN加速服务，提供商不一样，可能CDN操作的流程会略有不同。<br><img src="https://img-blog.csdnimg.cn/20200421104213353.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="腾讯CDN"></p><h5 id="又拍云CDN"><a href="#又拍云CDN" class="headerlink" title="又拍云CDN"></a>又拍云CDN</h5><p>又拍云服务提供商也还行吧，反正试了下没啥效果，这里最好在域名提供商哪里选择CDN服务。<br><img src="https://img-blog.csdnimg.cn/20200421104446548.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="又拍云CDN"></p><h4 id="Github-page-cdn配置"><a href="#Github-page-cdn配置" class="headerlink" title="Github page cdn配置"></a>Github page cdn配置</h4><p>在没有CDN的时候是这样的<br><img src="https://img-blog.csdnimg.cn/20200421104655773.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="无CDN测速">火红的大火鸡，非常差的访问去访问github节点。之后我选择阿里云的CDN去加速访问，在这之前可能要准备一个域名来操作啦。</p><p>现在我们进入阿里云的CDN，在域名管理处添加要加速的域名，如’<a href="http://www.maliaoblog.cn&#39;,这时候会提示没有备案，不用管，继续操作。在源站信息配置上，有三种选择，分别是OSS，域名，IP，如果你还填要加速的域名的话，显然会有重定向的麻烦，所以这里的源站在阿里云帮助文档里就讲了，源站就是github" target="_blank" rel="noopener">www.maliaoblog.cn&#39;,这时候会提示没有备案，不用管，继续操作。在源站信息配置上，有三种选择，分别是OSS，域名，IP，如果你还填要加速的域名的话，显然会有重定向的麻烦，所以这里的源站在阿里云帮助文档里就讲了，源站就是github</a> page服务器的域名或IP地址，这里还没有涉及到回源host的设置，大家尽管放心操作。之后在端口处选择443端口（以https协议访问，需要添加Https证书，如SSL的），加速区域选不包含中国大陆的，即海外节点加速，最后点击下一步。</p><p><img src="https://img-blog.csdnimg.cn/20200421110442442.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="CDN配置"><br>到这里基本上就完成了，返回的时候刷新一下，能看到CNAME地址！需要在域名解析到这个CNAME地址。</p><p><img src="https://img-blog.csdnimg.cn/20200421111013463.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="CDN运行正常">只有解析到这个CNAME地址后，过几分钟，阿里云才能进行CDN加速服务。之后以这个加速域名去测速，速度就会提升了。注意，是以这个加速了的域名访问，那访问的就是阿里云帮我们提供的CDN节点，那当然会更快啦。</p><h4 id="CDN加速服务深入"><a href="#CDN加速服务深入" class="headerlink" title="CDN加速服务深入"></a>CDN加速服务深入</h4><p>其实也没有多大的深入，就是在弄明白一个问题：github page还需要自定义域名吗？我们加没加速对博客站点的访问？</p><h5 id="ping了一下，没加速对github-io的访问"><a href="#ping了一下，没加速对github-io的访问" class="headerlink" title="ping了一下，没加速对github.io的访问"></a>ping了一下，没加速对github.io的访问</h5><p><img src="https://img-blog.csdnimg.cn/20200421112042708.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="io还是原样"><br>github.io为美国的节点，直接访问当然没多快呀，如果ping加速域名的话，会访问阿里美国的CDN的节点，如果要回源的话，访问的请求会从节点发送出去。这就等于加速了从电脑前的客户所在地到节点该段的速度，走的是访问CDN节点的路线。</p><p><img src="https://img-blog.csdnimg.cn/2020042111291429.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="流程图">接着我再以加速域名测速，肯定是红色少了</p><p><img src="https://img-blog.csdnimg.cn/20200421113044946.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="鸡儿绿了"><br>访问请求最终还是要得到最后的服务器的回应，也就是给我们网页资源。为此我又进行了测试。</p><h6 id="路由测试"><a href="#路由测试" class="headerlink" title="路由测试"></a>路由测试</h6><p><img src="https://img-blog.csdnimg.cn/20200421115105784.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="路由测试"></p><h6 id="DNS测试"><a href="#DNS测试" class="headerlink" title="DNS测试"></a>DNS测试</h6><p><img src="https://img-blog.csdnimg.cn/202004211152004.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="DNS测试">)如果加速域名DNS解析到github.io的话，github.io又有节点，那整个访问就快了。真的是这样的吗？还要不要.io自定义域名呢？page通过产生的github.io就可以访问到博客，自定义域名只是放到另一个展示(published)的地方(site)，那既然我们需要买域名去覆盖，那就要解析一个到github.io的CNAME的记录了。这么多，浏览器可能产生重定向的问题，以至于要不断刷新页面。但可以用一下，至少不要跑老远去DNS解析，输入域名，浏览器就老老实实交出页面啦。<br><a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github page </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接远程服务器出现乱码</title>
      <link href="/2020/0419/"/>
      <url>/2020/0419/</url>
      
        <content type="html"><![CDATA[<h2 id="连接远程服务器后出现命令行乱码"><a href="#连接远程服务器后出现命令行乱码" class="headerlink" title="连接远程服务器后出现命令行乱码"></a>连接远程服务器后出现命令行乱码</h2><p>真是巧了，最近遇到的事儿净跟编码有关，好像中了毒一样。话不多说，看乱码。<br><img src="https://img-blog.csdnimg.cn/20200419212122295.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="linux命令行乱码">大家已经看到了，连上服务器后的写个文件的目录命令，就只拉出了四个字，呃，不对，还有一个零蛋。好，这种乱码现象其实已经多见少怪了，然而还是有原因的，不然我怎么会写个博客记录一下。值得注意的就是在命令行出现乱码的情况很少，还是敲了命令之后，何况有的小伙伴还不熟悉linux系统的操作，更不知道怎么办了。慌了手脚，求救网页标签都打开了好几个，还是不知道咋弄，于是小伙伴只好四下求救大佬。<br>今天我就带大家一块干了。。</p><h3 id="so-到了面对编码的时候了"><a href="#so-到了面对编码的时候了" class="headerlink" title="so 到了面对编码的时候了"></a>so 到了面对编码的时候了</h3><p> 大家还记得上次讲过的编码格式问题吧，这次就不是转成Ansy格式了，要在secureCRT把编码格式转成utf-8格式，为什么呢？因为默认的secureCRT命令行不是utf-8,也不是中文字符集，所以就要改一改。如果小伙伴用的是中文破解版的，点击菜单栏中选择里会话选项，英文为option,界面如下，在外观(appearance)那里的字符编码选择那选择utf-8<br> <img src="https://img-blog.csdnimg.cn/20200419214524425.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="option会话选项"><br> 字体选择自己喜欢的，但是要中文字符集gb2312</p><p><img src="https://img-blog.csdnimg.cn/20200419214829854.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字体">OK啦，解决问题啦，就有如下对比</p><p><img src="https://img-blog.csdnimg.cn/20200419214956728.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="命令输入"><br>这样就顺顺利利地干了它了，哈哈，心里是不是很爽啊。如果大家对界面背景不满意同样可以调节，比如背景为黑色，命令前景为白色或黑客绿(瞎装逼色)，看图</p><p><img src="https://img-blog.csdnimg.cn/20200419215401157.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="黑客绿"> <code>如果小伙伴还弄不明白，那只能献上本人亲自为大家制作的动图了（不信你看不懂）</code></p><p><img src="https://img-blog.csdnimg.cn/20200419221542948.gif#pic_center" alt="亲力亲为动图"><br>好啦，以上就是小码码的学习心得，希望对大家有帮助，喜欢的话就点赞，留言哦，哈哈。<br>附<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码码官方博客</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matery主题优化问题</title>
      <link href="/2020/0409/"/>
      <url>/2020/0409/</url>
      
        <content type="html"><![CDATA[<h1 id="matery主题优化时解析出bug"><a href="#matery主题优化时解析出bug" class="headerlink" title="matery主题优化时解析出bug"></a>matery主题优化时解析出bug</h1><ul><li><p>matery是个好的主题这个我就不详细地说了，但是优化也难</p></li><li><p>越好的主题、越丰富的主题，插件越多，配置越多，就容易出错</p></li><li><p>最要命的是这种静态网页的部署还要用最原始的方法进行，先在命令行生成静态文件，然后发送给要命的github</p></li><li><p>总之bug数不胜数，大部分出错的原因基本都一致，无非就是在yml文件里乱弄出的bug</p></li><li><p>但是我优化主题时碰上了难得的bug，就分享给大家，省的大家走弯路</p><h2 id="page-ForEach-is-not-a-function后接一大片路径"><a href="#page-ForEach-is-not-a-function后接一大片路径" class="headerlink" title="page.*.ForEach is not a function后接一大片路径"></a>page.*.ForEach is not a function后接一大片路径</h2></li></ul><p><img src="https://img-blog.csdnimg.cn/20200409184120112.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="page bug"><br>这里的*就是图中的categorioes,我叫他page bug。就光看那么多行根本摸不着头脑，想着是肯定是配置出了问题，于是就打开配置文件查看。其实这个问题很少见，一般都不是config配置文件的问题。弄了半天，谁也没想到是页面文件categorioes里的index.md文件有问题。我的配置如下：<br><img src="https://img-blog.csdnimg.cn/2020040918524995.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="index.md配置"><br>一般都很少进入里面配置什么的，但是为了优化主题，让它更好看，就进入里面瞎搞乱改，网上也没什么指导如何优化配置的好文章，所以自然会遇到稀奇bug。上面的配置就出错了，出在categorioes的属性的配置，用这个主题，categories文件(需要事先new一个才有)好像不准添加属性，换成小写c也不行，之后做了如下更改。</p><p><img src="https://img-blog.csdnimg.cn/20200409190637167.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="删除属性后"><br>去掉那个C后，那个bug就没了，一切顺畅生成页面。四不四很无语，就这个鬼东西弄了一整天，不是说，就是这个静态页面配置太苛刻了，用md和yml去写，缩进不对都是要出错的。这给广大怀着博客梦的IT客破了一大盆冷水，太难了！<img src="https://img-blog.csdnimg.cn/20200409202700413.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="🆗"></p><p>我还试了在其他页面文件中的md文件里设置categories属性，结果都🆗。。。</p><p><img src="https://img-blog.csdnimg.cn/20200409191736240.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="tags文件里md文件配置了没问题"><br>tags文件里md文件配置了没问题,我是说categorioes属性，图片里没有，配置tags属性也没事(没打双引号都没事)。</p><pre><code>那到底是什么样的优化造成的魔王级的bug呢？</code></pre><p>hexo主题本来就不会自带页面的配置优化，需要自己弄，就matery来说吧，除了归档页面，其他的页面都不会出现和用这个主题的人一样相似布局，所以接下来就告诉大家怎么弄。</p><pre><code>就是在index.md文件里配置，只需添加如下几行：在categories里：type: &#39;categories&#39;                layout: &#39;categories&#39;        (注意：后空格)其他类推</code></pre><p>这样在各个页面就有自己配置了，如下</p><p><img src="https://img-blog.csdnimg.cn/20200409195433492.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="配置了friendst页面"><br>这是弄好了友链页面后的效果，能看到基本上是有个排版了。但框框内却出现了乱码，很巧的是出现乱码的地方都是汉字该出现的地方。所以大家应该知道了，又是编码的问题。这次我们还用notepad++更改编码友链的josn格式,如果没有notepad++或不知道如何更改编码格式，请参考<a href="https://blog.csdn.net/Gobullin/article/details/105349236" target="_blank" rel="noopener">批处理文件编码出错</a>原来友链的josn的编码格式为Ansi,我们需要utf-8格式。欧克，行了，如下：<img src="https://img-blog.csdnimg.cn/20200409200717571.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="乱码解决"></p><h3 id="谈谈hexo"><a href="#谈谈hexo" class="headerlink" title="谈谈hexo"></a>谈谈hexo</h3><p>hexo这样的博客虽然用了很流行的框架，但部署起来还是很费劲，就是用上去很费劲，powerful的博客框架还是太少了，什么都追求免费服务，哪有这么样的好事，这就导致了开发出优质的框架的人太少了。现在大牛的程序员都快是古董，做个IT技术更倾向于商业化，应用型。以上就是分享，另附<a href="https://www.maliaoblog.cn">个人博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> bug问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决执行批处理文件后出现的问题</title>
      <link href="/2020/0406/"/>
      <url>/2020/0406/</url>
      
        <content type="html"><![CDATA[<h1 id="执行批处理文件后出现的乱码问题"><a href="#执行批处理文件后出现的乱码问题" class="headerlink" title="执行批处理文件后出现的乱码问题"></a>执行批处理文件后出现的乱码问题</h1><p>用windows批处理总是很放便的，特便是在抢时间的情况下用批处理开启程序，运行大量命令等等。但对于刚接触的新手来说，可能是一件费劲的事！有时候还会遇到问题，比如今天要讲的执行批处理文件后出现的乱码问题。如下图：<br><img src="https://img-blog.csdnimg.cn/20200406190912897.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="批处理文件"><br>文件里的命令的意思就是在命令行输出“垃圾快跑”四个字，然后运行后如下</p><p><img src="https://img-blog.csdnimg.cn/20200406191232149.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="运行结果"><br>运行后出现的“致富喽”几个字。。。其实我也不知道是什么字。接着面对乱码的问题，大家想一想就明白估计是文件的编码格式出了问题，强调一下啊，是编码格式。在这里就要讲一个东西，就是windows的cmd命令行本身用的是Ansi编码，但用记事本打开或者说文件本身的编码其实不是Ansi编码，有可能是Utf-8。那这里就有两种解决方法。</p><h4 id="一、使用notepad-转换编码格式"><a href="#一、使用notepad-转换编码格式" class="headerlink" title="一、使用notepad++转换编码格式"></a>一、使用notepad++转换编码格式</h4><p> 既然要用到notepad++，相信大家应该不会陌生，notepad++功能强大，可以说比sublime text好用，这里之所以不推荐sublime text，是因为它没有编码格式的转换功能，甚至没有Ansi格式的编码，最后建议选择notepad++。考虑到有人没用过，下面就送上notepad++的网盘下载地址：<a href="https://pan.baidu.com/s/1Rz4RTcvTAktiXpQHY90kqQ" target="_blank" rel="noopener">notepad++下载</a>    提取码：xnl1</p><p> <img src="https://img-blog.csdnimg.cn/20200406193206198.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="notepad++"><br> notepad++支持多种语法高亮和编码及文件兼容，是程序哥的必备良器。打开notepad++后，默认为utf-8格式，点击文件，选择打开，选择你要打开的批处理文件，看到菜单栏的编码选项(已经很醒目了)，之后点击编码，选择转换为Ansi格式，再在文件选项中点击保存。</p><p> <img src="https://img-blog.csdnimg.cn/20200406194032449.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="Notepad++"><br> 在命令行后执行或直接点开批处理文件，解决乱码了</p><p> <img src="https://img-blog.csdnimg.cn/20200406194216646.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="二、另存为"><a href="#二、另存为" class="headerlink" title="二、另存为"></a>二、另存为</h4><p> 用记事本打开bat文件后，选择另存为，之后点击选择Ansi格式编码，同样能解决问题。<br> <img src="https://img-blog.csdnimg.cn/20200406202619497.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="另存为">打开运行批处理文件后，就没出现过乱码啦。</p><p>以上就是解决类似问题的几个方法，可以的话就留言评论，希望大家多多留言哦。<br>另附：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">个人博客</a></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C语言实现链表</title>
      <link href="/2020/0405/"/>
      <url>/2020/0405/</url>
      
        <content type="html"><![CDATA[<h1 id="用C语言实现链表，附代码注释"><a href="#用C语言实现链表，附代码注释" class="headerlink" title="用C语言实现链表，附代码注释"></a>用C语言实现链表，附代码注释</h1><p>这里给已经在学C和数据结构的小伙伴提供一些弹药支持，虽然不知道管不管用，在这里大佬就勿扰了吧！哈哈！</p><p>在实现一个简单的链表前需要用到哪些知识点呢？</p><ul><li>C语言基础知识，比如要用到的结构体、指针、函数、运算</li><li>一点数据结构的知识，在学习数据结构也能看到链表的身影，我们这里实现的是单项链表</li><li>有手，有脑</li></ul><p>现在上代码：</p><pre><code># include&lt;stdio.h&gt;# include&lt;malloc.h&gt;//创造链表 //定义一个节点类型typedef struct node{    int data;    char name[10];    struct node *next;}noDe,* pnoDe; // 输入函数 pnoDe funkin(void){     pnoDe pHead = (pnoDe)malloc(sizeof(noDe));    //定义头指针和尾指针分别指向头和尾节点      pnoDe ptail = pHead;    ptail-&gt;next = NULL;    int n,score;    //有效节点的数量      char name[10];        printf(&quot;please funkin a number:&quot;);    scanf(&quot;%d&quot;,&amp;n);             // 连续输入学生及成绩数据     for(int i=0;i&lt;n;i++){        pnoDe pNew = (pnoDe)malloc(sizeof(noDe));        printf(&quot;please scanf the score of number %d :&quot;,i+1);        scanf(&quot;%d %s&quot;,&amp;(pNew-&gt;data),pNew-&gt;name);        /*核心代码*/        ptail-&gt;next = pNew;       //让尾节点指针指向新节点         ptail = pNew;    //让尾指针指向新节点 ,并移动到下一个节点         ptail-&gt;next = NULL;    //让新节点指针域为空     }        return pHead;} // 输出函数 void out(pnoDe pHead){    int k = 1;    pnoDe p = pHead-&gt;next;    while(p != NULL){        printf(&quot;\nfunkout number %d: &quot;,k);        printf(&quot;score= %d\nname= %s\n&quot;,p-&gt;data,p-&gt;name);        p = p-&gt;next;        k++;    }    return;}int main(void){    pnoDe pHead = NULL;    pHead = funkin();    out(pHead);    return 0;    } </code></pre><p>代码并不难懂，大概就是先输入需要创建的节点数或有效数据个数，之后创建了一个会构造链表的函数，并返回头指针。这个时候链表其实已经创建好了，并且已经放入了数据。之后，输出函数out()会输出数据。ok，就是这么简单！觉得可以就点赞加关注，博主会定期更新哦！哈！最后附上个人博客链接：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">csdn博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致访客</title>
      <link href="/2020/0327/"/>
      <url>/2020/0327/</url>
      
        <content type="html"><![CDATA[<p>这是经过多天努力的结果，这个站点就界面来说，不怎么酷炫。但是是我一直想做的东西–建一个与众不同的个人网站，每天可以像发微博一样自由地推送我写好的博客文章。对于<a href="http://www.maliaoblog.cn，我很珍惜能拥有它，还是经过自己的不断尝试，一点一点地做出来的，就如心血的结晶。" target="_blank" rel="noopener">www.maliaoblog.cn，我很珍惜能拥有它，还是经过自己的不断尝试，一点一点地做出来的，就如心血的结晶。</a></p><h1 id="来访"><a href="#来访" class="headerlink" title="来访"></a>来访</h1><pre><code>I&#39;m so proud for your visit!我想说，感谢你能来见证我博客的诞生，正因为有你的加入，才能有我的博客的成长。以后大家可以通过我的博客官网看到我最新的动态，我会在这个站点和你面对面。</code></pre><h1 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h1><p>博客会不定期更新，我会不断的努力写出好的文章作品。</p><h1 id="为什么叫码力奥"><a href="#为什么叫码力奥" class="headerlink" title="为什么叫码力奥"></a>为什么叫码力奥</h1><pre><code>可能因为马里奥比较出名吧！作为产码达人，一定要起一个好名字。</code></pre><h1 id="以后站点会变换吗？"><a href="#以后站点会变换吗？" class="headerlink" title="以后站点会变换吗？"></a>以后站点会变换吗？</h1><pre><code>可能吧！但现在算是比较稳定了，起初，我想在站点加入更多功能插件，可是条件限制各方面因素，就只能到这！另外博客的站点是建在外网的，所以访问比较慢！这里就体谅一下吧！一个人建站比较幸苦的。</code></pre><h1 id="加油！"><a href="#加油！" class="headerlink" title="加油！"></a>加油！</h1><pre><code>毕竟建站不是我最终的想法，想着继续努力地学习成长，以后拥有更加幸福的生活。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客简介 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
