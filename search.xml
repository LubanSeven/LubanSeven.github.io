<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在服务器上安装halo博客</title>
      <link href="/2021/0228/"/>
      <url>/2021/0228/</url>
      
        <content type="html"><![CDATA[<h4 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h4><p>本来是想弄<code>Coding</code>实现和<code>Github</code>双部署博客的，所以<code>www</code>的域名停止访问，可是最后<code>Coding</code>也没能部署完成，关键就是<code>Page</code>之后的仓库域名不符合条件，最后项目也署失败，所以干脆直接放弃了，索性弄一个动态的。</p><p><img src="https://img-blog.csdnimg.cn/20210301181502657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="coding">)<img src="https://img-blog.csdnimg.cn/20210301181521291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="bushu"><br>买了一台1核1G的云服务器，不是在阿里云买的，比较便宜些，也没便宜多少，就十几块钱吧，如果在阿里云开发者计划上购买能续费三年，主要是只买了一年的，以后续费就不好续了，优惠价买的，原价贵的要死，只能说上个云太难了。装了个CentOS系统镜像，起初准备搭建一个PHP博客，原因是<code>handsome</code>主题十分美观简洁，但是要付费(建议购买正版，有配套服务，我没钱所以用盗版)，选好了后台用的<code>typecho</code>，前端主题准备用<code>handsome(盗版)</code>。等到安装好<code>LAMP</code>之后，发现这个博客后台框架并不咋滴，虽然有很多人用，本身硬件就不行，运行起来特别慢，要下载好多插件，还要动手改源码，对于一个不懂<code>php</code>的新手来说很不友好。过了几天直接换成<code>halo</code>框架，操作很简单，如果选择这种的，根本不需要安装<code>LAMP</code>，<code>halo</code>是一个Java动态开源的博客项目，所以直接到官网下载一个项目<code>JAR</code>包就行，放到服务器上，只需要配置好Java环境，一道<code>nohup java -jar halo-1.4.2.jar &amp;</code>命令就运行起来了，速度快，  特别方便！而且<code>halo</code>的后台页面比较美观，功能齐全，不像<code>typecho</code>还要弄一个插件美化一下，一个有几十<code>KB</code>的，有几十<code>M</code>的，明显增加了服务器运行负担。</p><h4 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h4><p>另外服务器在<code>ICP备案</code>之后才能进行域名解析，一般要十天左右完成！所以买了服务器和域名就尽早备案，别耽误博客上线时间。可以把博客放到服务器上运行，之后就是安装博客，和前端博客的美化，<code>halo</code>主题有不少，可以到主题仓库挑选，下载压缩包或者远程拉取都行。</p><h4 id="handsome主题"><a href="#handsome主题" class="headerlink" title="handsome主题"></a>handsome主题</h4><p>如果你选择安装<code>typecho</code>购买<code>handsome</code>主题的话，建议直接让他给你买好服务器安装好，一条龙服务嘛，毕竟花了钱的！但如果你只是买主题的话，安装操作会比较麻烦一点，首先配置好环境，需要<code>LAMP</code>或者<code>LNMP</code>，反正<code>Mysql</code>和<code>php</code>是一定要安装的，<code>Php</code>和<code>Mysql</code>服务要一直开启，若遇到<code>yum</code>没用相应的安装包，安装包版本低的情况，可以更换<code>yum</code>包管理器的安装源。</p><pre class="line-numbers language-shell"><code class="language-shell">cd /etc/yum.repos.d/ # 进入yum源配置文件夹,根据centos版本下载对应的新源# 如果wget命令不生效，说明还没有安装wget工具wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -O http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all #清除缓存yum makecache #生成缓存，会把新下载CentOS-Base.repo源生效yum -y update #更新<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很多软件包在yum官方源里面没有的，也可以使用epel源,也就是安装epel-release软件包。EPEL (Extra Packages for Enterprise  Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS等系统。</p><pre class="line-numbers language-shell"><code class="language-shell">yum install epel-release #安装epel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Mysql注意事项"><a href="#Mysql注意事项" class="headerlink" title="Mysql注意事项"></a>Mysql注意事项</h4><p>在安装<code>Mysql</code>时，注意CentOS7放弃了<code>MySQL</code>，而改使用MariaDB，MariaDB数据库管理系统是<code>MySQL</code>的一个分支，主要由开源社区在维护 。开发这个分支的原因之一是甲骨文公司收购了<code>MySQL</code>后，有将<code>MySQL</code>闭源的潜在风险， 因此社区采用分支的方式来避开这个风险。MariaDB的目的是完全兼容<code>MySQL</code>，包括API和命令行，使之可以成为<code>MySQL</code>的代替品。 在存储引擎上，从10.0.9版起使用<code>XtraDB</code>来代替<code>MySQL</code>的<code>InnoDB</code>。 MariaDB由<code>MySQL</code>的创始人麦克尔主导开发，他早前曾将自己创建的公司MySQL AB卖给了SUN公司，此后，随着SUN被甲骨文收购。</p><pre class="line-numbers language-shell"><code class="language-shell">yum list | grep mariadb #查看yum源中mariadb安装包列表yum install mariadb-5.5.56-2.el7.x86_64 #安装相应版本rpm -qa | grep MariaDB  #查看mariadb安装包systemctl enable mysqld #开机启动mysql服务systemctl start mysqld.service #开启服务(systemctl status查看服务)#然后创建typecho博客需要的数据库typecho(默认)和用户名、密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h4><p>由于<code>halo</code>项目的默认端口为<code>8090</code>，所以需要进行服务器端口的映射，不然访问不到，将<code>80</code>端口映射到<code>8090</code>，如下：</p><pre class="line-numbers language-shell"><code class="language-shell">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8090 #映射端口80到8090iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8090 #映射端口443到8090service iptables restart #重启防火墙<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>备案之后可以进行域名解析就完事了，通过域名能访问就正常。 另外你也可以深入了解一下<code>halo</code>框架的具体实现，学习学习，确实是一个不错的Java项目。 另外你也可以深入了解一下<code>halo</code>框架的具体实现，学习学习，确实是一个不错的Java项目。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程(五)-线程池</title>
      <link href="/2021/0127/"/>
      <url>/2021/0127/</url>
      
        <content type="html"><![CDATA[<h5 id="线程池-前言"><a href="#线程池-前言" class="headerlink" title="线程池-前言"></a>线程池-前言</h5><p>系统启动一个线程的成本较高，而使用线程池可以提高性能，尤其在菜鸡大量短期线程时。与数据库连接池类似，线程池在系统启动时创建大量空闲线程，程序将一个<code>Runnable</code>对象或<code>Callable</code>对象传给线程池，线程池就会执行他们的<code>run()</code>或<code>call()</code>方法，当执行结束后线程不会死亡，而是回到线程池变成空闲状态，等待执行<code>run</code>或<code>call</code>方法。</p><p>此外，使用<code>线程池</code>可以有效控制系统并发的数量，当系统包含大量的并发线程时，将导致系统性能降低，而线程池的最大线程数可以有效控制并发数量。</p><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>用<code>Executors</code>工厂类创建线程池，该工厂类包含如下几个静态工厂方法来创建线程池：</p><ul><li><code>newCachedThreadPool()</code>：创建一个具有缓存功能的线程池。</li><li><code>newFixedThreadPool(int n)</code>：创建一个可重用的、具有固定线程数的线程池。</li><li><code>newSingleThreadExecutor()</code>：创建只有一个线程的线程池，相当于上一个方法参数n=1。</li><li><code>newScheduledThreadPool(int Size)</code>：创建具有指定线程数<code>size</code>的线程池，它可以在指定延迟后执行线程任务。</li><li><code>newSingleThreadScheduledExecutor()</code>：创建只有一个线程的线程池，它可以在指定延迟后执行线程任务。</li></ul><p>前三个方法返回一个<code>ExecutorService</code>对象，代表一个线程池，后两个方法返回一个<code>ScheduledExecutorService</code>线程池，它是<code>ExecutorService</code>的子类，可以延迟后执行线程。以下是Java8新增的方法：</p><ul><li><code>ExecutorService newWorkStealingPool(int parallelism)</code>：创建持有足够线程的线程池来支持给定的并行级别(数目)。</li><li><code>ExecutorService newWorkStealingPool()</code>：上一个简化版的方法，<code>cpu</code>有多少，相当于上一个方法的参数传入多少。</li></ul><p>随着硬件的发展，多核<code>cpu</code>的出现，这两个方法可以利用<code>cpu</code>的并行能力，生成的<code>WorkStealing</code>池相当于后台线程池。</p><p><code>ExecutorService</code>代表亟待执行线程的线程池，只要有空闲的线程就会立即执行线程任务。程序只要将一个<code>Runnable</code>或<code>Callable</code>对象交给线程池，该线程池会尽快执行线程。而<code>ExecutorService</code>提供了如下几个方法：</p><ul><li><code>Future&lt;?&gt; submit(Runnable t)</code>：将一个<code>Runnable</code>对象交给线程池，线程池将在有空闲线程时执行<code>Runnable</code>对象。<code>Future</code>对象将在线程run方法执行结束后返回<code>null</code>，可以调用<code>Future</code>的<code>isDone()</code>，<code>isCancelled()</code>方法获取<code>Runnable</code>的执行状态。</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable t,T r)</code>：将一个<code>Runnable</code>对象交给线程池，线程池将在有空闲线程时执行<code>Runnable</code>对象。其中<code>r</code>显式指定执行结束后端返回值，所以<code>Future</code>对象将在<code>run</code>方法执行结束后返回<code>r</code>。</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; t)</code>：将一个<code>Callable</code>对象交给线程池，线程池将在有空闲线程时执行<code>Callable</code>对象。其中<code>Future</code>代表<code>Callable</code>对象的<code>call</code>方法的返回值。</li></ul><p><code>ScheduledExecutorService</code>是可在延迟后或可周期性执行线程的线程池，提供了如下四个方法：</p><ul><li><code>ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; c,long delay,TimeUnit u)</code>：指定<code>c</code>任务将在<code>delay</code>延迟后执行。</li><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable c,long delay ,TimeUnit u)</code>：指定<code>c</code>任务将在<code>delay</code>延迟后执行。</li><li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable c,long initialDelay,long period,TimeUnit u)</code>：指定<code>c</code>任务将在<code>initialDelay</code>延迟后执行，依次在<code>initialDelay+period</code>、<code>initialDelay+2*period</code>···处重复执行。</li><li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable c,long initialDelay,long delay,TimeUnit u)</code>：创建并执行一个在给定初始延迟后的定期操作，随后在每次执行中止和下一次执行开始之间都存在给定的延迟，具有周期性。如果任务遇到异常，就会取消后续执行。</li></ul><p>在使用完一个线程池后应该调用其<code>shutdown()</code>方法，该方法启动线程池关闭序列，不会接收新的线程任务，将已提交的线程任务完成后结束所有线程；类似的另外一个方法<code>shutdownNow()</code>，该方法将停止所有正在执行和等待的任务，并返回等待执行的任务列表。</p><p>综上，线程池执行任务的过程如下：</p><ul><li>调用<code>Executor</code>类的静态工厂方法创建一个<code>ExecutorService</code>对象，即线程池。</li><li>创建<code>Runnable</code>或<code>Callable</code>实现类的实例，作为线程执行任务。</li><li>调用线程池大小的<code>submit</code>方法来提交<code>Runnable</code>或<code>Callable</code>实例。</li><li>想要关闭线程池时，调用其<code>shutdown()</code>方法。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        ExecutorService pool <span class="token operator">=</span> ExecutorS<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Runnable t <span class="token operator">=</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"： "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里没有直接创建启动线程来执行Runnable对象，是通过线程池执行</span>        pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        pool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//两个线程将交替执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ForkJoinPool拆分任务"><a href="#ForkJoinPool拆分任务" class="headerlink" title="ForkJoinPool拆分任务"></a><code>ForkJoinPool</code>拆分任务</h5><p>Java提供的<code>ForkJoinPool</code>是<code>ExecutorService</code>的实现类，能将一个任务拆分成多个<code>小任务</code>并行计算，再把结果合并，是比较特殊的线程池。<code>ForkJoinPool</code>提供了如下两个构造器：</p><ul><li><code>ForkJoinPool(int p)</code>：创建一个包含<code>p</code>个并行线程的<code>ForkJoinPool</code>。</li><li><code>ForkJoinPool()</code>：以<code>Runtime.availableProcessors()</code>方法的返回值作为<code>p</code>参数创建线程池。</li></ul><p>Java8又增加了<code>通用池</code>功能，<code>ForkJoinPool</code>提供了两个<code>静态方法</code>：</p><ul><li><code>ForkJoinPool commonPool()</code>：该方法返回一个通用池，通用池的运行不会受<code>shutdown()</code>和<code>shutdownNow()</code>的影响，除非退出JVM，中止虚拟机工作。</li><li><code>int getCommonPoolParallelism()</code>：该方法返回通用池并行级别(数量)。</li></ul><p>创建了<code>ForkJoinPool</code>实例后，就可调用<code>submit(ForkJoinTask t)</code>或<code>invoke(ForkJoinTask t)</code>方法执行任务，其中<code>ForkJoinTask</code>代表一个可并行、合并的任务。<code>ForkJoinTask</code>是一个抽象类，<code>RecursiveAction</code>和<code>RecursiveTask</code>是它的两个抽象子类，<code>RecursiveAction</code>代表没有返回值的任务，<code>RecursiveTask</code>代表有返回值的任务。</p><h5 id="线程相关类"><a href="#线程相关类" class="headerlink" title="线程相关类"></a>线程相关类</h5><p>Java为线程安全提供了一些工具类，如<code>ThreadLocal</code>类，它代表一个线程局部变量，通过把数据放在<code>ThreadLocal</code>就可以让每个线程创建一个该变量的副本，从而避免并发访问的线程安全问题。</p><h6 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a><code>ThreadLocal</code>类</h6><p>工具类<code>ThreadLocal</code>支持泛型，通过该类可以简化多线程编程的并发访问。它提供如下三个<code>public</code>方法：</p><ul><li><code>T get()</code>：返回此线程局部变量中当前线程副本中的值。</li><li><code>void remove()</code>：删除此线程局部变量中的值。</li><li><code>void set(T value)</code>：设置此线程局部变量中线程副本中的值。</li></ul><p><code>ThreadLocal</code>和同步机制一样，都是为了解决多线程中对变量访问的冲突问题。在同步机制中，通过对对象加锁来实现安全访问，该变量为多个线程所共享；而<code>ThreadLocal</code>从另一个角度解决并发访问，它将所访问的资源复制多份，每个线程拥有一份，从而避免了线程之间的访问冲突。</p><p><code>ThreadLocal</code>不能代替同步机制，同步机制是同步多个线程对同一资源的访问，是多个线程之间进行通信的方法；<code>ThreadLocal</code>是为了隔离多个线程对资源的共享，根本上避免线程为竞争资源的冲突。</p><h6 id="包装线程不安全的集合"><a href="#包装线程不安全的集合" class="headerlink" title="包装线程不安全的集合"></a>包装线程不安全的集合</h6><p>之前讲过的Java集合<code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code>、<code>TreeMap</code>等线程不安全的集合，当线程并发访问时可能会集合数据的完整。所以需要包装成安全的集合，<code>Collections</code>通过了如下<code>静态方法</code>：</p><ul><li><code>static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</code>：返回指定<code>Collection</code>对应的线程安全的集合<code>Collection</code></li><li><code>static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>：返回指定<code>List</code>对象对应的线程安全的<code>List</code>对象。</li><li><code>static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code>：返回指定<code>Map</code>对象对应的线程安全的<code>Map</code>对象。</li><li><code>static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code>：返回指定<code>Set</code>对象对应的线程安全的<code>Set</code>对象。</li><li><code>static &lt;K,V&gt; sortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m)</code>:返回指定<code>SortedMap</code>对象对应的线程安全的<code>SortedMap</code>对象。</li><li><code>static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)</code>：返回指定<code>SortedSet</code>对象对应的线程安全的<code>SortedSet</code>对象。</li></ul><p>需要包某个集合包装成线程安全的集合，应该在创建后立即包装。</p><pre class="line-numbers language-java"><code class="language-java">HashMap m <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//包装成线程安全的HashMap</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h6><p>在<code>java.util.concurrent</code>包下提供了大量支持高效并发访问的集合接口和实现类，这些线程安全的集合类可分为：</p><ul><li>以<code>Concurrent</code>开头的集合类，如<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentLinkedQueue</code>。</li><li>以<code>CopyOnWrite</code>开头的集合，如<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code>。</li></ul><p><code>Concurrent集合</code></p><p>其中以<code>Concurrent</code>开头的集合类代表了支持并发访问的集合，它们可以支持多个线程并发写入访问，而且都是安全的，读取操作不必锁定。以<code>CopyOnWrite</code>开头的集合采用了复杂算法保证不会锁住整个集合，因此在并发写入时有很好的性能。</p><p>当多个线程共享一个公共集合时，<code>ConcurrentLinkedQueue</code>是一个恰当的选择，它不允许使用<code>null</code>元素，实现了多线程无需等待访问。</p><p>默认情况下，<code>ConcurrentHashMap</code>支持16给线程并发写入，当超过16个线程时，可能有一些线程需要等待，程序可通过设置<code>concurrencyLevel</code>构造参数(默认为16)来支持更多并发写入。Java8又新增了多个方法增加<code>ConcurrentHashMap</code>功能，大致分为三类：</p><ul><li><code>forEach（forEach,forEachKey,forEachEntry）</code></li><li><code>search（search,searchKeys,searchValues）</code></li><li><code>reduce（reduce,reduceToDouble,reduceKeys,reduceValues）</code></li></ul><p>此外还添加了<code>mappingCount()</code>，<code>newKeySet()</code>等方法，增强后的<code>ConcurrentHashMap</code>更合适作为缓存实现类。</p><p><code>CopyOnWriteArrayList集合</code></p><p>由于<code>CopyOnWriteArraySet</code>底层封装了<code>CopyOnWriteArrayList</code>，因此它的实现机制类似于<code>CopyOnWriteArrayList</code>集合。</p><p>当线程对<code>CopyOnWriteArrayList</code>集合进行读取操作时，线程会直接读取集合本身，无需加锁和阻塞；当线程对<code>CopyOnWriteArrayList</code>集合进行写入操作时(包括add(),remove(),set())，该集合会在底层复制一份新的数组，接下来对新数组执行写入操作。由于写入操作是对数组副本进行的，所以保证了线程安全。</p><p>然而线程安全并不是没有代价，<code>CopyOnWriteArrayList</code>执行写入操作时要多次复制数组，所以性能较差，但是读取和写入操作的数组不是同一个，因此读取操作就很快又安全，比较适合用来读取缓存。</p><blockquote><p>这是多线程的最后一篇，估计也是Java的最后一篇，以后可能就不会给大家整理Java基础的文章了，但会在Java道路上一直陪伴大家，谢谢大家的关注！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程(四)-线程通信</title>
      <link href="/2021/0123/"/>
      <url>/2021/0123/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>当线程在系统内运行时，程序无法精准控制线程轮换执行，Java提供了一些机制来保证线程协调运行。</p><h5 id="synchronized线程通信相关方法"><a href="#synchronized线程通信相关方法" class="headerlink" title="synchronized线程通信相关方法"></a><code>synchronized</code>线程通信相关方法</h5><p>借助<code>Object</code>类提供的<code>wait()</code>,<code>notify()</code>,<code>notifyAll()</code>三个方法(不属于Thread类)，但这三个必须由同步监视器调用，，这可以分成以下情况：</p><ul><li>对于同步方法，该类的默认实例(this)就是同步监视器，所以可以在同步方法中直接调用这三个方法。</li><li>对于同步代码块，同步监视器是<code>synchronized</code>后括号里的对象，所以要使用该对象调用。</li></ul><p>关于这三个方法的解释：</p><ul><li><code>wait()</code>：让当前线程等待，直到其他线程调用该同步监视器的<code>notify()</code>或<code>notifyAll()</code>方法来唤醒线程。无参则一直等待，带参则等待<code>long millis</code>毫秒时间自动唤醒。</li><li><code>notify()</code>：唤醒在此同步监视器上等待的单个线程，如果有多个线程在等待同步监视器，则随机唤醒其中一个线程。只有当前线程主动放弃锁，被唤醒线程才获得执行。</li><li><code>notifyAll()</code>：唤醒在此同步监视器上等待的所有线程。</li></ul><h5 id="使用Condition的线程通信"><a href="#使用Condition的线程通信" class="headerlink" title="使用Condition的线程通信"></a>使用<code>Condition</code>的线程通信</h5><p>如果不使用<code>synchronized</code>关键字保证线程同步，而使用<code>Lock</code>对象保证线程同步，则系统中不存在隐式的同步监视器，也就不能使用<code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>方法进行线程通信。因此，当使用<code>Lock</code>对象来保证同步时，Java提供了<code>Condition</code>类来保证协调，使用<code>Condition</code>可以让那些已经得到<code>Lock</code>对象却无法执行的线程释放<code>Lock</code>对象，同时也能唤醒其他处于等待的线程。</p><p><code>Condition</code>将同步监视器的方法(wait()，notify()，notifyAll())分成不同的对象，便于与<code>Lock</code>对象结合，<code>Lock</code>代替了同步方法和代码块，<code>Condition</code>代替了同步监视器功能。<code>Condition</code>实例被绑定在<code>Lock</code>对象上，想要获得<code>Lock</code>对象的<code>Condition</code>实例，就要调用<code>Lock</code>对象的<code>newCondition()</code>方法。</p><p><code>Condition</code>类提供如下方法：</p><ul><li><code>await()</code>：类似隐式同步监视器的<code>wait()</code>方法，导致当前线程等待，直到其他线程调用该<code>Condition</code>的<code>signal()</code>或<code>signalAll()</code>方法来唤醒该线程。衍生的方法有很多，<code>awaitUninterruptibly()</code>，<code>awaitUntil(Date deadline)</code>。</li><li><code>signal()</code>：唤醒在此<code>Lock</code>对象上等待的单个线程，若有多个线程等待，则随机唤醒其中一个。</li><li><code>signalAll()</code>：唤醒所有在此<code>Lock</code>对象等待的所有线程，只有当前线程放弃对该<code>Lock</code>对象的锁定后才可以执行被唤醒的线程。</li></ul><h5 id="使用阻塞队列-BlockingQueue-的线程通信"><a href="#使用阻塞队列-BlockingQueue-的线程通信" class="headerlink" title="使用阻塞队列(BlockingQueue)的线程通信"></a>使用阻塞队列(<code>BlockingQueue</code>)的线程通信</h5><p>Java5提供了一个<code>BlockingQueue</code>接口，是<code>Queue</code>的子接口，但它的主要途径并不是<code>容器</code>，而是作为线程同步的工具。<code>BlockingQueue</code>具有一个特征：当生产者线程试图向<code>BlockingQueue</code>中放入元素时，如果该队列已满，则该线程被阻塞，当消费者线程试图从<code>BlockingQueue</code>中取出元素时，如果该队列为空，则该线程被阻塞。</p><p>程序的两个线程交替向<code>BlockingQueue</code>中放入，取出元素，就能控制线程通信。<code>BlockingQueue</code>提供了如下两个方法：</p><ul><li><code>put(T t)</code>：把T元素放入<code>BlockingQueue</code>中，如果该队列已满，则阻塞该线程。</li><li><code>take()</code>：从<code>BlockingQueue</code>的头部取出元素，如果该队列的元素已空，则阻塞该线程。</li></ul><p><code>BlockingQueue</code>继承了<code>Queue</code>接口，当然也可以使用<code>Queue</code>接口中的方法。</p><ul><li>在队尾插入元素。包括<code>add(T t)</code>，<code>offer(T t)</code>，<code>put(T t)</code>方法，当队列已满，这三个方法分别会抛出异常，返回false，阻塞队列。</li><li>在队首删除并返回元素。包括<code>remove()</code>、<code>poll()</code>、<code>take()</code>方法，当队列为空时，这三个方法分别会抛出异常，返回false，阻塞队列。</li><li>在队首仅仅取出元素。包括<code>element()</code>、<code>peek()</code>方法，当队列为空，方法分别抛出异常和返回false。</li></ul><p>可用如下表格表示：</p><table><thead><tr><th></th><th align="center">抛出异常</th><th align="center">返回false</th><th align="center">阻塞线程</th><th align="center">指定超时时长</th></tr></thead><tbody><tr><td>队列已满时，队尾插入元素</td><td align="center">add()</td><td align="center">offer()</td><td align="center">put()</td><td align="center">offer(e,time,unit)</td></tr><tr><td>队列已空时，队首删除元素</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time,unit)</td></tr><tr><td>队列已空时，队首取出元素</td><td align="center">element()</td><td align="center">peek()</td><td align="center"></td><td align="center"></td></tr></tbody></table><p><code>BlockingQueue</code>包含以下几个实现类：</p><ul><li><code>ArrayBlockingQueue</code>：基于数组实现的<code>BlockingQueue</code>队列。</li><li><code>LinkedBlockingQueue</code>：基于链表实现的<code>BlockingQueue</code>队列。</li><li><code>SynchronousQueue</code>：同步队列，对该队列的存取必须交替进行。</li><li><code>PriorityBlockingQueue</code>：不是标准的阻塞队列，与<code>PriorityQueue</code>类似，该队列调用<code>remove()</code>，<code>poll()</code>，<code>take()</code>方法取出元素时，并不是取出队列中存在时间最长的元素，而是最小的元素。判断元素大小可根据元素(实现<code>Comparable</code>接口)的本身大小进行自然排序，也可使用<code>Comparator</code>自定义排序。</li><li><code>DelayQueue</code>：底层基于<code>PriorityBlockingQueue</code>实现，要求元素都实现<code>Delay</code>接口，接口里只有一个<code>long getDelay()</code>方法，<code>DelayQueue</code>根据元素的<code>getDelay()</code>方法的返回值进行排序。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>Strings<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"阻塞队列"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"阻塞队列"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"阻塞队列"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队列已满，阻塞线程</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程组和未处理异常"><a href="#线程组和未处理异常" class="headerlink" title="线程组和未处理异常"></a>线程组和未处理异常</h5><p>Java使用<code>ThreadGroup</code>来表示线程组，它可以对一批线程进行管理，允许程序直接对线程进行控制。如果没有显式指定创建的线程属于哪个线程组，则属于默认线程组。默认情况下，子线程和创建它的线程属于同一线程组。一旦线程加入了指定的线程组，则该线程一直属于该线程组，直至死亡不能改变。</p><p><code>Thread</code>类提供了如下几个构造器来设置创建的线程属于哪个线程组：</p><ul><li><code>Thread(ThreadGroup group,Runnable target)</code>：以target的run方法作为线程执行体创建新的线程，属于<code>group</code>线程组</li><li><code>Thread(ThreadGroup group,Runnable target,String name)</code>:同样的，只不过指定了创建的线程名字。</li><li><code>Thread(ThreadGroup group,String name)</code>：创建新线程，指定线程名。</li></ul><p>虽然不能改变所在指定的线程组，但可以通过<code>getTreadGroup()</code>方法返回所属线程组，返回值是<code>ThreadGroup</code>对象。而<code>ThreadGroup</code>类提供了两个构造器创建相应实例：</p><ul><li><code>ThreadGroup(String name)</code>：以指定的线程组名字来创建新的线程组。</li><li><code>ThreadGroup(ThreadGroup parent,String name)</code>：以指定的的名字和父线程组创建新的线程组。</li></ul><p>通过以上构造器可以发现，线程组必然有一个名字，这个名字可以通过<code>ThreadGroup</code>的<code>getName()</code>方法获取，但是不允许改变线程组的名字，也就没有set方法。除了构造器，<code>ThreadGroup</code>还提供了几个方法来操作线程组里的所有线程：</p><ul><li><code>activeCount()</code>：返回线程组中活动线程的数目。</li><li><code>interrupt()</code>：中断此线程组的所有线程。</li><li><code>isDaemon()</code>：判断该线程组是否是后台线程组。</li><li><code>setDaemon()</code>：把线程组设置为后台线程组，若后台线程组的最后一个线程死亡，则线程组自动毁灭。</li><li><code>setMaxPriority(int p)</code>：设置线程组的最高优先级。</li></ul><p>此外，线程组对于出现的异常也提供了一个方法<code>void uncaughtException(Thread t,Throwable e)</code>，该方法可以处理该线程组内的任意线程所抛出的未处理异常。如果线程抛出一个异常，JVM会在线程结束前自动查找对应的<code>Thread.UncaughtExceptionHandler</code>对象，如果找到该异常处理器对象，则会调用该对象的<code>uncaughtException(Thread t,Throwable e)</code>方法处理异常。</p><p><code>Thread.UncaughtExceptionHandler</code>是<code>Thread</code>类的一个静态内部接口，里面只有一个方法<code>uncaughtException(Thread t,Throwable e)</code>，<code>t</code>代表异常的线程，<code>e</code>代表抛出的异常。<code>Thread</code>类提供了如下方法来设置异常处理器：</p><ul><li><code>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler h)</code>：为该线程类的所有实例设置默认异常处理器。</li><li><code>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler h)</code>：为线程实例设置异常处理器。</li></ul><p><code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionHandler</code>接口，所以每个线程的<code>线程组</code>都将作为<code>默认的异常处理器</code>。当一个线程抛出异常时，JVM会先查找线程实例指定的异常处理器，否则会调用所属线程组对象的<code>uncaughtException()方法</code>(<code>默认的异常处理器</code>)处理异常。</p><p><code>线程组默认异常处理器处理过程如下：</code></p><ul><li>如果该线程组有父线程组，则调用父线程组的<code>uncaughtException()</code>方法处理。</li><li>如果该线程所属的默认线程组有默认异常处理器，那么就调用该异常处理器处理。</li><li>如果该<code>异常</code>是<code>ThreadDeath</code>的对象，则不做任何处理，否则将异常跟踪栈的信息打印到<code>System.err</code>输出流，并结束该线程。</li></ul><pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">MyHandler</span> <span class="token keyword">implements</span> <span class="token class-name">Thread<span class="token punctuation">.</span>UncaughtExceptionHandler</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//自定义处理器</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">uncaughtException</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span>Throwable e<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token string">" 出现异常 "</span><span class="token operator">+</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExHandler</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setUncaughtExceptionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyExHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ArithmeticException</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序已结束！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不会正常结束，所以不会输出</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上诉代码虽然捕获了异常，但是出现不会正常结束。因为与<code>try...catch</code>异常捕获不同，异常处理器对异常进行处理后会将异常抛给上一级调用者，而<code>catch</code>捕获异常不会。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO流(三)-NIO</title>
      <link href="/2021/0121/"/>
      <url>/2021/0121/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-IO流-三-NIO"><a href="#Java-IO流-三-NIO" class="headerlink" title="Java-IO流(三)-NIO"></a>Java-IO流(三)-<code>NIO</code></h3><p>在前面所介绍的输入输出流都是阻塞式的输入、输出，即当数据源中没有数据时，它会阻塞该线程。传统的输入、输出都是通过字节的移动来处理的，就是输入输出系统一次只能处理一个字节，因此效率并不高。从JDK1.4开始，Java改进了IO流体系，提供来一些新功能，被称作<code>NIO</code>。新增的功能类被放在<code>java.nio</code>包及子包下，并且对原<code>java.io</code>包中的很多类都以<code>NIO</code>为基础进行改写，新增满足<code>NIO</code>功能。</p><p><code>NIO</code>采用不同的方式来处理输入/输出，用内存映射文件的方式来处理输入/输出，<code>NIO</code>将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件，这种方式比传统的方式快。它有如下包：</p><ul><li><code>java.nio</code>包：主要各种与<code>Buffer</code>相关的类</li><li><code>java.nio.channels</code>包：主要包含与<code>Channel</code>和<code>Selector</code>相关的类</li><li><code>java.nio.charset</code>包：字符集相关类</li><li><code>java.nio.channels.spi</code>：与<code>Channel</code>相关的服务接口</li><li><code>java.nio.charset.spi</code>：包含与字符集相关的服务接口</li></ul><p><code>Channel</code>(通道)和<code>Buffer</code>(缓冲)是新IO中两个核心对象，<code>CHannel</code>是对传统的输入/输出的模拟，在<code>NIO</code>中所有数据都需要通过通道传输；<code>Channel</code>与传统的<code>InputStream</code>、<code>OutputStream</code>区别在于它提供一个<code>map()</code>方法，通过该<code>map()</code>方法可以直接将<code>一块数据</code>映射到内存中。</p><p><code>Buffer</code>可以被理解成一个容器，它本质是一个数组，发送到<code>Channel</code>中都所有对象都必须首先放在<code>Buffer</code>中，而从<code>Channel</code>中读取的数据也必须放到<code>Buffer</code>中。</p><p>除<code>Channel</code>和<code>Buffer</code>外，<code>NIO</code>还提供了将<code>Unicode</code>字符串映射成字节序列以及逆映射操作的<code>Channel</code>类，也提供了非阻塞式输入/输出的<code>Selector</code>类。</p><h5 id="使用Buffer"><a href="#使用Buffer" class="headerlink" title="使用Buffer"></a>使用<code>Buffer</code></h5><p><code>Buffer</code>是一个抽象类，其最常用的子类是<code>ByteBuffer</code>，它可以在底层字节数组上进行<code>get/set</code>操作。对应其他类型的<code>Buffer</code>类有：<code>CharBuffer</code>、<code>ShortBuffer</code>、<code>IntBuffer</code>、<code>LongBuffer</code>、<code>FloatBuffer</code>等。以上类都没有提供构造器，而是提供<code>static XxxBuffer allocate(int capacity)</code>方法，创建一个容量为<code>capacity</code>的<code>XxxBuffer</code>对象。</p><p><code>MappedByteBuffer</code>是<code>ByteBuffer</code>子类，用于表示<code>Channel</code>将磁盘文件的部分或全部内容映射到内存中后得到的结果，相应对象由<code>Channel</code>的<code>map()</code>方法返回。</p><p>在<code>Buffer</code>中有三个重要的概念：容量(Capacity)、界限(limit)、位置(position)</p><ul><li>容量(capacity)：缓冲区的容量(capacity)表示最大数据容量，创建后不能改变。</li><li>界限(limit)：第一个不能被读写的缓冲区位置索引。</li><li>位置(position)：指明下一个可以被读出或写入的缓冲区位置索引，类似记录指针。</li></ul><p><code>Buffer</code>还有一个可选标记<code>mark</code>，允许直接将<code>position</code>定位到该<code>mark</code>处，并满足：</p><blockquote><p>0&lt;=mark&lt;=position&lt;=limit&lt;=capacity</p></blockquote><p><code>Buffer</code>的主要作用就是装入数据，然后输出数据。开始时，<code>position</code>为0，<code>limit</code>为<code>capacity</code>，程序可以通过<code>put()</code>方法向<code>Buffer</code>中放入一些数据，每放入一些数据，Buffer的position相应的向后移动一些。当<code>Buffer</code>装入数据结束后，调用<code>Buffer</code>的<code>flip()</code>方法，该方法将<code>limit</code>设置为<code>position</code>所在位置，并将<code>position</code>设为0，为输出作准备。输出数据后，<code>Buffer</code>调用<code>clear()</code>方法，将position设为0，将<code>limit</code>设为<code>capacity</code>，这样为装数据做准备。</p><blockquote><p>总结来讲：就是<code>flip()</code>方法为取出数据做好准备，<code>clear()</code>方法为装数据做好准备。此外<code>Buffer</code>的常用方法还有<code>capacity()</code>、<code>limit()</code>、<code>hasRemaining()</code>等。</p></blockquote><p>除了有移动<code>position</code>、<code>limit</code>、<code>mark</code>的方法外，<code>Buffer</code>的所有子类还提供了两个重要的方法：<code>put()</code>和<code>get()</code>方法，用于向<code>Buffer</code>中放入和取出数据，可以单个也可以批量。当用这两个方法访问数据时，分为<code>相对</code>和<code>绝对</code>两种：</p><ul><li>相对(relative)：从<code>Buffer</code>的当前<code>Position</code>处开始读取或写入数据，然后<code>Position</code>值按处理元素个数增加。</li><li>绝对(Absolute)：直接根据索引向<code>Buffer</code>中读取或写入数据，使用绝对方式访问<code>Buffer</code>的数据，<code>position</code>值不变。</li></ul><p>通过<code>allocate()</code>方法创建的对象是普通的<code>Buffer</code>对象，<code>ByteBuffer</code>还提供一个<code>allocateDirect()</code>方法来创建直接<code>Buffer</code>，成本会比普通<code>Buffer</code>创建·成本高，但好处是读取效率更高。</p><p>由于只有<code>ByteBuffer</code>提供了<code>allocateDirect()</code>方法，所以只能在<code>ByteBuffer</code>级别上创建直接<code>Buffer</code>。如果需要使用其他类型，则应该将该<code>Buffer</code>转换成其他类型<code>Buffer</code>。直接<code>Buffer</code>更适于长期生存的<code>Buffer</code>，因为创建成本较高。</p><h5 id="使用Channel"><a href="#使用Channel" class="headerlink" title="使用Channel"></a>使用<code>Channel</code></h5><p><code>Channel</code>类似于传统的流对象，但还是有区别。<code>Channel</code>可以直接将指定文件的部分或全部直接映射成<code>Buffer</code>；程序不能直接访问<code>Channel</code>中的数据，读取、写入都不行；<code>Channel</code>只能和<code>Buffer</code>进行交互，也就是说程序要取出数据要通过<code>Buffer</code>，写入数据要还要通过<code>Buffer</code>。</p><p>Java为<code>Channel</code>接口提供了<code>DatagramChannel</code>、<code>FileChannel</code>、<code>Pipe.SinkChannel</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>等实现类，并且有各自相应的功能。所有的<code>Channel</code>都不应该通过构造器来直接创建，而是通过传统的节点<code>InputStream</code>、<code>OutputStream</code>的<code>getChannel()</code>方法来返回对应的<code>channel</code>，不同的节点流获得的<code>Channel</code>不一样。</p><p><code>Channel</code>中最常用的方法是<code>map()</code>、<code>read()</code>、<code>write()</code>，其中<code>map()</code>方法用于将<code>Channel</code>对应的部分或全部数据映射成<code>ByteBuffer</code>；而<code>read()</code>或<code>write()</code>方法都有一系列重载形式，这些方法用于从<code>Buffer</code>中读取或写入数据。</p><p><code>map(FileChannel.MapMode mode,long position,long size)</code>，映射模式有只读、读写等，第二三个参数用于映射数据的范围。在<code>RandomAccessFile</code>中也包含了一个<code>getChannel()</code>方法，<code>RandomAccessFile</code>返回的<code>FileChannel()</code>是只读的还是读写的，取决<code>RandomAccessFile</code>打开文件的模式。</p><h5 id="字符集和charset"><a href="#字符集和charset" class="headerlink" title="字符集和charset"></a>字符集和charset</h5><p>数据是以字节码的形式储存的，明文字符序列经过编码成二进制序列。Java默认使用<code>Unicode</code>字符集，当读取数据到java程序时，就可能出现乱码。JDK1.4提供了Charset来处理字节序列和字符序列之间的转换关系，该类包含了用于创建解码器和编码器的方法，还提供了获取<code>Charset</code>所支持字符集方法，<code>Charset</code>类是不可变的。<code>Charset</code>类还提供了一个<code>availableCharsets()</code>静态方法来获取当前JDK所支持的所有字符集。</p><ul><li>GBK：简体中文</li><li>BIG5：繁体中文</li><li>ISO-8859-1：ISO拉丁字母表</li><li>UTF-8：8位UCS转换格式</li><li>UTF-16BE：16位UCS转换格式，地位地址放高位字节</li><li>UTF-16：16位UCS转换格式</li></ul><p>可以使用<code>System</code>的<code>getProperties()</code>方法访问本地系统的文件编码格式，属性名为<code>file.encoding</code>。</p><p>一旦知道字符集别名，就可以调用<code>Charset</code>的<code>forName()</code>方法来创建对应的<code>Charset</code>对象，<code>forName()</code>的参数是相应字符集的别名。通过对象的<code>newDecoder()</code>和<code>newEncoder()</code>方法分别返回<code>CharsetDecoder</code>和<code>CharsetEncoder</code>对象，代表解码器和编码器，将字符和字节序列相互转换。</p><h5 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h5><p>使用文件锁可以阻止多个进程同时修改一个文件，在NIO中java提供了<code>FileLock</code>来支持文件锁定功能，在<code>FieChannel</code>中提供的<code>lock()/tryLock()</code>方法可以获得文件锁<code>FileLock</code>对象，从而锁定文件。当<code>lock()</code>试图锁定某个文件时，如果无法得到文件锁，程序将一直阻塞；而<code>tryLock()</code>是直接返回文件锁，否则返回<code>null</code>。</p><ul><li><code>lock(long position,long size,boolean shared)</code>：对文件从<code>position</code>位置开始，长度为<code>size</code>的内容加锁。</li><li><code>tryLock(long position,long size,boolean shared)</code>：非阻塞式的加锁方法，参数与上面类似。</li></ul><p>当<code>shared</code>为true时，表明是一个共享锁，它允许多个进程读取该文件，阻止进程获取该文件的排它锁。当为false时，表明是一个排它锁，可提高<code>FileLock</code>的<code>isShared()</code>来判断。注意：直接使用上述两个方法获取的都是<code>排它锁</code>，处理完文件后通过<code>FileLock</code>的<code>release()</code>方法释放文件锁。</p><h5 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h5><p>Java7对原有的<code>NIO</code>进行了改进，主要有：</p><ul><li>提供来全面的文件IO和文件系统访问支持</li><li>基于异步的<code>Channel</code>的IO</li></ul><p>第一个表现为新增的<code>java.nio.file</code>包及各个子包；第二个表现为在<code>java.nio.channels</code>包下增加多个以<code>Asynchronous</code>开头的<code>Channel</code>接口和类。</p><p>早期只能通过<code>File</code>类来访问文件系统，现在引入一个<code>path</code>接口，代表一个与平台无关的平台路径。除此之外，还提供了<code>Files</code>、<code>Paths</code>两个工具类，<code>Files</code>包含了静态的工具方法；<code>Paths</code>包含了两个返回<code>path</code>的静态工厂方法。命名都加上s，代表一个工具类。</p><h6 id="使用FileVisitor遍历文件和目录"><a href="#使用FileVisitor遍历文件和目录" class="headerlink" title="使用FileVisitor遍历文件和目录"></a>使用<code>FileVisitor</code>遍历文件和目录</h6><p><code>Files</code>类提供了如下方法来遍历文件和子目录：</p><ul><li><p><code>walkFileTree(Path start,FileVisitor&lt;? super Path&gt; visitor)</code>：遍历start路径下的所以文件和子目录</p></li><li><p><code>walkFileTree(Path start,Set&lt;FileVisitOption&gt; options,int maxDepth,FileVisitor&lt;? super Path&gt; visitor)</code>：该方法最多遍历<code>maxDepth</code>深度的文件</p></li></ul><h6 id="使用WatchService监控文件变化"><a href="#使用WatchService监控文件变化" class="headerlink" title="使用WatchService监控文件变化"></a>使用<code>WatchService</code>监控文件变化</h6><p>早期是通过一个后台线程每隔一段时间去遍历指定文件目录，如果结果与上一次不同，则发生变化。<code>NIO</code>的<code>Path</code>类提供来一个方法来监听文件变化。</p><p><code>register(WatchService watcher,WatchEvent.kind&lt;?&gt; ...events)</code>：用watcher监听该<code>path</code>代表的目录下的文件变化，<code>events</code>参数指定要监听那些事件。</p><p>获取文件系统的<code>WatchService</code>对象：</p><pre class="line-numbers language-java"><code class="language-java">WatchService watchservice <span class="token operator">=</span> FileSystem<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>newWatchService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来使用<code>WatchService</code>的方法获取文件事件：</p><ul><li><p><code>WatchKey poll()</code>：获取下一个<code>watchkey</code>,没有返回null。</p></li><li><p><code>WatchKey poll(long timeout,TimeUnit unit)</code>：尝试等待<code>timeout</code>时间去获取下一个<code>WatchKey</code>。</p></li><li><p><code>WatchKey take()</code>：获取下一个<code>watchkey</code>，没有就一直等。</p></li></ul><blockquote><p>公众号：菜鸡干Java</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程(二)-控制线程</title>
      <link href="/2021/0120/"/>
      <url>/2021/0120/</url>
      
        <content type="html"><![CDATA[<p>Java线程<code>Thread</code>提供一些工具方便控制线程的执行。</p><h5 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h5><p>Thread提供了让一个线程等待另一个线程完成的方法——join()方法，当程序调用线程的join()方法时，调用线程(比如主线程)将被阻塞，直到被join()方法加入的join线程执行完为止。</p><pre class="line-numbers language-java"><code class="language-java">JoinThread jt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JoinThread</span><span class="token punctuation">(</span><span class="token string">"被join的线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>jt<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//main线程调用了子线程jt的join方法</span>jt<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//jt线程结束，主线程才会执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>join()</code>方法有三种形式：</p><ul><li><code>join()</code>：等待join的线程执行完成</li><li><code>join(long millis)</code>：等待最长<code>millis</code>毫秒时间，若join了的线程还没结束，不再等待。</li><li><code>join(long millis,int nanos)</code>：等待最长<code>millis</code>毫秒加<code>nanos</code>毫微秒时间。</li></ul><h5 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h5><p>顾名思义，在后台运行的线程，为其他线程提供服务，又称<code>守护线程</code>，例如JVM垃圾回收线程。如果前台的线程全部死亡，后台线程也就没有存在的必要了。</p><p>调用线程对象的<code>setDaemon(true)</code>方法可以将指定线程设置为后台线程，<code>Thread</code>类还提供了一个<code>isDaemon()</code>方法，用于判断线程是否为后台线程。主线程默认是前台线程，那子线程默认也是前台线程，后台线程创建的子线程默认是后台线程。需要注意的是，将一个线程设置为后台线程，要在线程启动前设置。</p><pre class="line-numbers language-java"><code class="language-java">DaemonThread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DaemonThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="线程睡眠Sleep"><a href="#线程睡眠Sleep" class="headerlink" title="线程睡眠Sleep"></a>线程睡眠Sleep</h5><p>再多线程(一)里已经提到过线程的sleep会让线程进入<code>阻塞</code>状态，线程的<code>sleep()</code>方法是Thread类的<code>静态方法</code>，它有两种重载形式：</p><ul><li><code>static void sleep(long millis)</code>：让当前线程暂停<code>millis</code>毫秒进入阻塞状态，会受系统精度的影响。</li><li><code>static void sleep(long millis,long nanos)</code>：暂停<code>millis</code>毫秒加<code>nanos</code>毫微秒进入阻塞，同样受精度影响。</li></ul><p>无论有没有其他线程，调用<code>sleep</code>方法的线程都不能得到执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SleepTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间："</span><span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//暂停1秒</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程让步Yield"><a href="#线程让步Yield" class="headerlink" title="线程让步Yield"></a>线程让步Yield</h5><p>与<code>sleep()</code>类似的是，线程<code>yield()</code>也是该类的静态方法，但是不同的是它不会阻塞线程，而是让线程进入<code>就绪</code>状态，等待线程调度器的重新调度(有可能下一次被重新调用)。当调用了<code>yield()</code>方法暂停后，只有优先级与当前线程相同或更高的处于就绪状态的线程才会获得执行机会，而<code>sleep()</code>方法不是，暂停之后不会理会其他线程的优先级。</p><p><code>sleep</code>方法声明抛出了<code>InterruptedException</code>异常，所以调用<code>sleep</code>方法时要么捕获该异常，要么显式声明抛出异常；而<code>yield</code>方法没有声明抛出任何异常。</p><h5 id="设置线程优先级"><a href="#设置线程优先级" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h5><p>线程执行时都具有一定优先级，优先级高的获得较多执行机会。每个线程的优先级与创建它的父线程优先级相同，默认下<code>main</code>线程具有普通优先级，其子线程也具有普通优先级。</p><p><code>Thread</code>类提供了<code>setPriority(int priority)</code>、<code>getPriority()</code>方法来设置和获取线程的优先级，其中<code>setPriority()</code>中的参数可以说1~10的整数，也可以是三个静态常量：</p><ul><li><code>MAX_PRIORITY</code>：10</li><li><code>MIN_PRIORITY</code>：1</li><li><code>NORM_PRIORITY</code>：5</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MyThread low <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    low<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    low<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>MIN_PRORITY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要说明的事，不同系统的优先级范围并不一样，不一定是1~10，所以应该尽量使用静态常量进行设置。</p><blockquote><p>公众号：菜鸡干Java</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程(一)-线程的创建</title>
      <link href="/2021/0119/"/>
      <url>/2021/0119/</url>
      
        <content type="html"><![CDATA[<h4 id="Java多线程-一-线程的介绍和创建"><a href="#Java多线程-一-线程的介绍和创建" class="headerlink" title="Java多线程(一)-线程的介绍和创建"></a>Java多线程(一)-线程的介绍和创建</h4><h5 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h5><p>当一个程序进入内存运行，就变成一个进程，<code>进程是系统进行资源分配和调度的最小单位</code>，具有独立性，动态性和并发性。这里需要说明一点：并发性(concurrency)和并行性(parallel)两个概念，并发是指同一时间只能有一个指令被执行，多个进程指令被快速轮换执行；并行指多条执行同时在多个处理器上被执行。</p><p>多线程指一个进程同时并发处理多个任务，线程是进程的执行单元。进程被初始化后，主线程就被创建，同时还可以创建多个顺序执行流，这些执行流就是线程，线程之间相互独立。线程可以拥有堆栈，变量等，与其他线程共享该进程所有的资源，线程的调度管理由进程本身来完成。</p><h5 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h5><p>线程有五种状态，新建，就绪，运行，阻塞，死亡五种。</p><h6 id="新建和就绪"><a href="#新建和就绪" class="headerlink" title="新建和就绪"></a>新建和就绪</h6><p>使用<code>new</code>创建一个线程后，线程处于新建状态，和对象一样由虚拟机分配内存，并初始化成员变量的值。当调用了<code>start()</code>方法后，线程处于就绪状态，虚拟机为其创建方法调用栈和程序计数器，然而线程并没有开始运行，何时运行则取决于JVM的线程调度器的调度。</p><p>如果不调用<code>start()</code>方法，而是直接执行<code>run()</code>方法，则其他线程无法并发执行，相当于执行了一个普通方法，而不是线程执行体。对于新建状态的线程，只能调用<code>start()</code>方法。</p><h6 id="运行和阻塞"><a href="#运行和阻塞" class="headerlink" title="运行和阻塞"></a>运行和阻塞</h6><p>当一个线程获得CPU资源时，开始执行<code>run()</code>的线程执行体，它不可能一直处于运行状态，需要被中断让其它线程获得执行机会。线程的调度取决于底层平台所采用的策略，如抢占式策略，系统给每个线程一小段时间处理任务，之后会剥夺资源给其他线程，在选择线程时，系统会考虑线程的优先级。</p><p>当线程主动放弃了所占用的资源时，会进入阻塞状态，一般有如下情况：</p><ul><li>调用了<code>sleep()</code>主动放弃</li><li>线程调用了阻塞式IO方法，该方法返回前被阻塞</li><li>试图获得一个被其他线程拥有的同步监视器</li><li>等待通知</li><li>程序调用<code>suspend()</code>方法挂起线程(容易导致死锁)</li></ul><p>被阻塞后需要重新进入就绪状态，等待线程调度器的调用。当发生以下情况线程可重新进入就绪状态：</p><ul><li><code>sleep()</code>方法结束</li><li>阻塞式的IO方法已返回</li><li>成功获得同步监视器</li><li>等待通知时，收到其他线程的通知</li><li>被挂起后调用了<code>resume()</code>方法恢复</li></ul><p>线程进入阻塞后只能回到就绪状态，而就绪和运行状态的转换不受程序控制，由线程调度决定。</p><h6 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h6><p>线程会以三种方式结束：</p><ul><li>run方法或call方法执行完成</li><li>线程抛出未捕获的异常或错误</li><li>调用线程的<code>stop()</code>结束(会产生死锁)</li></ul><p>注意，主线程结束即死亡后，其他线程不受影响，它们和主线程有同样地位。要测线程死没死，可以调用线程的<code>isAlive()</code>方法，当处于<code>就绪</code>，<code>运行</code>,<code>阻塞</code>状态时，返回<code>true</code>；否则返回<code>false</code>，新建也不例外。当线程死亡后就回不来了，不能重新启动。</p><h5 id="创建线程三种方法"><a href="#创建线程三种方法" class="headerlink" title="创建线程三种方法"></a>创建线程三种方法</h5><p>线程对象必须是Thread类或其子类的实例。</p><h6 id="通过继承Thread类创建"><a href="#通过继承Thread类创建" class="headerlink" title="通过继承Thread类创建"></a>通过继承Thread类创建</h6><ol><li>定义子类，重写run方法。run方法体就代表线程需要完成的任务，也叫线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用对象的<code>start()</code>方法启动。</li></ol><p>注意，程序至少创建一个主线程，其线程执行体不是run方法，而是<code>main()</code>方法。</p><p>有三个方法需要介绍：</p><ul><li><code>Thread.currentThread()</code>：Thread类的静态方法，返回正在执行的线程对象</li><li><code>getName()</code>：Thread类的实例方法，可返回线程对象的名字。</li><li><code>setName(String name)</code>：设置线程的名字。</li></ul><h6 id="通过Runnable接口创建"><a href="#通过Runnable接口创建" class="headerlink" title="通过Runnable接口创建"></a>通过<code>Runnable</code>接口创建</h6><ol><li>定义Runnable接口的实现类，并重写该接口的run方法。</li><li>创建实现类的实例，以该实例来创建线程对象。</li><li>调用<code>start()</code>方法。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//MyThread为实现Runnable接口的类</span>MyThread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span><span class="token string">"runnable实现的线程"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实现类的run方法仅作为线程执行体，线程对象则负责执行run方法。通过实现<code>Runable</code>接口，在run方法中获得线程对象，则必须使用<code>Thread.currentThread()</code>方法，而通过继承方法的线程类，直接使用this即可获得线程对象。</p><h6 id="使用Callable和Future创建"><a href="#使用Callable和Future创建" class="headerlink" title="使用Callable和Future创建"></a>使用<code>Callable</code>和<code>Future</code>创建</h6><p>Java5开始提供了一个<code>Callable</code>函数式接口，接口提供了一个<code>call()</code>方法作为线程执行体，它不像run方法，call方法有返回值，而且可以声明抛出异常。然而<code>Callable</code>接口不是<code>Runnable</code>的子接口，所以不能用来直接创建线程对象。</p><p><code>Future</code>接口代表<code>Callable</code>接口里call方法的返回值，Java为Future接口提供了<code>FutureTask</code>实现类，该类实现了<code>Future</code>接口，还实现了<code>Runnable</code>接口，可以用来创建new线程对象，接口里有几个公共方法来控制它关联的<code>Callable</code>任务。比如<code>V get()</code>方法，返回Callable任务里call方法的返回值，该方法将导致阻塞，等线程结束才返回。</p><ol><li>创建<code>Callable</code>实现类，并实现call方法，再创建实现类的实例，该call方法将作为线程执行体。</li><li>使用<code>FutureTask</code>类包装Callable对象。</li><li>使用<code>FutureTask</code>对象作为target，创建线程对象。</li><li>调用<code>FutureTask</code>对象的get方法获得子线程执行完后的返回值。</li></ol><p>使用Lambda表达式直接创建<code>Callable</code>对象，无需先创建实现类，再创建<code>Callable</code>对象。</p><h5 id="三种方式的对比"><a href="#三种方式的对比" class="headerlink" title="三种方式的对比"></a>三种方式的对比</h5><p>线程类继承了Thread类，不能再继承其他父类，并且不能共享实例变量，但访问当前线程简单；而通过接口的方式可以共享实例变量，还可以继承其他类，但是比较繁琐，访问当前线程对象需要使用<code>Thread.currentThread()</code>。以上就是线程的简单介绍和创建，希望有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO(二)输入输出流体系</title>
      <link href="/2020/1104/"/>
      <url>/2020/1104/</url>
      
        <content type="html"><![CDATA[<h4 id="输入输出流体系"><a href="#输入输出流体系" class="headerlink" title="输入输出流体系"></a>输入输出流体系</h4><h4 id="处理流的用法"><a href="#处理流的用法" class="headerlink" title="处理流的用法"></a>处理流的用法</h4><p>使用处理流来包装节点流，程序通过处理流来执行输入输出，让节点流与底层I/O设备、文件交互。如通过<code>PrintStream</code>处理流来包装<code>OutputStream</code>，使用处理流后的输出流更加方便。</p><p>输入输出流体系提供了近40个类，常用的类分成如下：</p><table><thead><tr><th>分类</th><th>字节输入流</th><th>字节输出流</th><th>字符输入流</th><th>字符输出流</th></tr></thead><tbody><tr><td>对象流</td><td><code>ObjectInputStream</code></td><td><code>ObjectOutputStream</code></td><td></td><td></td></tr><tr><td>抽象基类</td><td><code>FilterInputStream</code></td><td><code>FilterOutputStream</code></td><td><code>FilterReader</code></td><td><code>FilterWriter</code></td></tr><tr><td>抽象基类</td><td><code>IuputStream</code></td><td><code>OutputStream</code></td><td><code>Reader</code></td><td><code>Writer</code></td></tr><tr><td>访问文件</td><td><code>FileInputStream</code></td><td><code>FileOutputStream</code></td><td><code>FileReader</code></td><td><code>FileWriter</code></td></tr><tr><td>访问数组</td><td><code>ByteArrayInputStream</code></td><td><code>ByteArrayOutputStream</code></td><td><code>CharArrayReader</code></td><td><code>CharArrayWriter</code></td></tr><tr><td>访问管道</td><td><code>PipedInputStream</code></td><td><code>PipedOutputStream</code></td><td><code>PipedReader</code></td><td><code>PipedWriter</code></td></tr><tr><td>访问字符串</td><td></td><td></td><td><code>StringReader</code></td><td><code>StringWriter</code></td></tr><tr><td>缓冲流</td><td><code>BufferedInputStream</code></td><td><code>BufferedOutputStream</code></td><td><code>BufferedReader</code></td><td><code>BufferedWriter</code></td></tr></tbody></table><p>通常字节流的功能更加强大，因为计算机的数据都是二进制的，而字节流可以处理所有二进制文件；如果要处理文本文件，则应该考虑使用字符流处理。另外还有一些不在<code>java.io</code>包下的字节流，它们具有特殊的功能。表中有四个访问管道的IO流，它们用于实现进程间的通信。四个缓冲流增加了缓冲功能，提高输入输出效率，同时需要使用<code>flush()</code>才能将缓冲区内容写入<code>IO节点</code>。对象流用于实现对象的序列化。</p><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>有两个转换流用于实现字节流转换成字符流，其中<code>InputStreamReader</code>将字节输入流转换成字符输入流，<code>OutputStreamWriter</code>将字节输出流转换成字符输出流。Java使用<code>System.in</code>代表标准输入，它是<code>InputStream</code>类的实例，使用不是很方便，所以用<code>InputStreamReader</code>将其转换成字符输入流；再者，普通的<code>Reader</code>读取输入输入内容不方便，可以将<code>Reader</code>包装成<code>BufferedReader</code>，利用<code>readLine()</code>方法一次读取一行内容。</p><pre class="line-numbers language-java"><code class="language-java">InputStreamReader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="推回输入流"><a href="#推回输入流" class="headerlink" title="推回输入流"></a>推回输入流</h4><p>在IO流体系中有两个流比较特殊，<code>PushbackInputStream</code>和<code>PushbackReader</code>,它们都提供如下三个方法：</p><ul><li><code>voidunread(byte[]/char[] buf)</code>：将一个字节/字符数组内容推入缓冲区，从而能重复读取刚刚读取的内容。</li><li><code>void unread(byte[]/char[] b,int off,int len)</code>：将一个字节/字符数组里从off开始，长度为<code>len</code>字节/字符内容推入缓冲区，从而允许重复读取。</li><li><code>void unread(int b)</code>：将一个字节/字符推入缓冲区，从而允许重复读取。</li></ul><p>这三个方法与<code>InputStream</code>和<code>Reader</code>中的三个方法相对应，它们各有一个推回缓冲区，当调用<code>unread()</code>方法时，系统会把指定数组内容推回缓冲区，并且每次调用<code>read()</code>方法时总是从推回缓冲区读取。当完全读取<code>缓冲区内容</code>后，但还没有装满<code>read()</code>的存放数组时才会从输入流中读取。当创建<code>PushbackInputStream</code>和<code>PushbackReader</code>时需要指定缓冲区大小，而默认大小为1。如果超出大小将会引发IO异常。</p><h4 id="重定向输入输出"><a href="#重定向输入输出" class="headerlink" title="重定向输入输出"></a>重定向输入输出</h4><p>Java的标准输入/输出分别通过<code>System.in</code>和<code>System.out</code>代表，获取输入和输出，输出是输出到屏幕上。在<code>System</code>类下有如下三个重定向的方法：</p><ul><li><code>static void setErr(PrintStream err)</code>：重定向标准错误输出流。</li><li><code>static void setIn(InputStream in)</code>：重定向标准输入流。</li><li><code>static void setOut(PrintStream out)</code>：重定向标准输出流。</li></ul><pre class="line-numbers language-java"><code class="language-java">PrintStream p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span><span class="token function">setOut</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以上代码重定向输出流到一个文本文件中，所以输出时将不会输出到屏幕上，而到了文件中。同样也可以重定向输入，指定从文件输入。</p><h4 id="Java虚拟机读写进程数据"><a href="#Java虚拟机读写进程数据" class="headerlink" title="Java虚拟机读写进程数据"></a>Java虚拟机读写进程数据</h4><p>使用<code>Runtime</code>对象的<code>exec()</code>方法可以运行其他程序，该方法产生一个<code>Process</code>对象，代表程序启动的子进程。<code>Process</code>类提供了如下三个方法，用于让程序和其子进程进行通信。</p><ul><li><code>InputStream getErrorStream()</code>：获取子进程的错误流。</li><li><code>InputStream getInputStream()</code>：获取子进程的输入流。</li><li><code>OutputStream getOutputStream()</code>：获取子进程的输出流。</li></ul><p>需要注意的是，此处的输入输出流应该站在程序的角度上理解，让子进程读取程序中的数据，要用输出流而不是输出流，相当于子进程代替了文件节点一样。</p><h4 id="RandomAccessFile文件随机访问类"><a href="#RandomAccessFile文件随机访问类" class="headerlink" title="RandomAccessFile文件随机访问类"></a><code>RandomAccessFile</code>文件随机访问类</h4><p>与普通的输入输出流不同，<code>RandomAccessFile</code>支持随机任意访问，程序可以直接跳到文件任意地方来读写文件。它允许自由定位文件记录指针，<code>RandomAccessFile</code>可以不从开始地方输出，所以可以在后面追加内容。同时，需要注意的是该类不能读写其他IO流节点，只能读写文件。每一个对象包含一个记录指针，用以标识当前读写处位置。</p><ul><li><code>long getFilePointer()</code>：返回文件记录指针的位置。</li><li><code>void seek(long pos)</code>：将文件记录指针定位到<code>pos</code>位置。</li></ul><p><code>RandomAccessFile</code>包含类似于<code>InputStream</code>的三个<code>read()</code>方法，用法和其他<code>read()</code>方法完全一样，同样也包含类似的<code>write()</code>方法。该类有两个构造器，只是形参不同，一个是使用<code>String</code>参数指定文件名，另一个是使用<code>File</code>参数指定文件名。此外，还需要指定一个<code>mode</code>访问模式参数。</p><ul><li><code>r</code>：只读打开文件。</li><li><code>rw</code>：读写方式打开文件，若不存在则创建文件。</li><li><code>rws</code>：读写方式打开，文件和元数据的更新都同步写入底层储存设备。</li><li><code>rwd</code>：读写方式打开。文件更新都同步写入底层设备。</li></ul><blockquote><p><code>RandomAccessFile</code>依然不能向指定位置插入内容，如果移动文件指针到中间位置，则新输出的会覆盖文件中原有的内容。如果先把插入点后面的内容读入缓冲区，等新内容写入后再把缓冲区内容追加到后面便可实现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> IO流体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO流</title>
      <link href="/2020/1101/"/>
      <url>/2020/1101/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-IO流-一"><a href="#Java-IO流-一" class="headerlink" title="Java-IO流(一)"></a>Java-IO流(一)</h4><p>java的IO通过<code>java.io</code>包下的类和接口来支持，在该包下主要有输入、输出两种IO流，每种输出、输入流又可分为字节流和字符流。此外，Java的IO流使用了一种装饰器设计模式，将IO流分成底层节点流和上层处理流，其中节点流用于和物理储存节点直接关联，不同物理节点获取节点流的方式可能有差异，但程序可以把不同物理节点流包装成统一的处理流，从而允许程序使用统一的输入输出代码来读取不同的物理存储节点的资源。<code>java.nio</code>及其子包提供了一系列<code>API</code>，是对原IO的升级。</p><h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><h5 id="访问文件和目录"><a href="#访问文件和目录" class="headerlink" title="访问文件和目录"></a>访问文件和目录</h5><p>File类是<code>java.io</code>包下代表与平台无关的文件和目录，也就是说它并不能访问文件，需要时使用IO流。<code>File</code>可以使用文件路径字符串来创建<code>File</code>实例，通过调用实例方法来访问，如下：</p><h6 id="访问文件名相关"><a href="#访问文件名相关" class="headerlink" title="访问文件名相关"></a>访问文件名相关</h6><ul><li>String getName()：返回此<code>File</code>对象所表示的文件名或路径名。</li><li>String <code>getPath()</code>：返回此<code>File</code>对象所对应的路径名。</li><li>File <code>getAbsoluteFile()</code>：返回此<code>File</code>对象的绝对路径。</li><li>String <code>getAbsolutePath()</code>：返回<code>File</code>对象对应的绝对路径名。</li><li>String <code>getParent()</code>：返回<code>File</code>对象对应目录的父目录名。</li><li>boolean <code>renameTo(File newName)</code>：重命名文件或目录，成功返回true。</li></ul><p>还有文件检测方法、获取常规文件、文件操作相关和目录操作相关的方法等。注意文件路径用斜杠<code>/</code>表示！</p><h4 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h4><p>在<code>File</code>类的<code>list()</code>方法中可以接收一个<code>FilenameFilter</code>参数，通过该参数可以列出符合条件的文件，这里的<code>FilenameFilter</code>接口和<code>javax.swing.filechooser</code>包下的<code>FileFilter</code>抽象类的功能非常相似，可以把<code>FileFilter</code>当成<code>FilenameFilter</code>实现类，但实际上没有实现该接口。</p><p><code>FilenameFilter</code>接口包含一个<code>accept(File dir,String name)</code>方法，该方法对<code>File</code>所指定的目录或文件进行迭代，如果返回true，则<code>list()</code>方法会列出该子目录或文件。<code>FilenameFilter</code>接口内只有一个抽象方法，因此该接口也是一个函数式接口，则可使用<code>Lambda</code>表达式创建该接口对象。</p><pre class="line-numbers language-java"><code class="language-java">File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> nameList <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>dir<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>name<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">".java"</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Java的IO流"><a href="#Java的IO流" class="headerlink" title="Java的IO流"></a>Java的IO流</h4><p>Java输入/输出源抽象表述为“流”<code>stream</code>，然后通过流的方法访问不同的输入/输出源。<code>stream</code>是从起源到接收<code>sink</code>的有序数据。所有的传统流的类都在<code>java.io</code>包下，以实现输入/输出功能。</p><ol><li><h5 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h5></li><li><p>输入流：只能从中读取数据，而不能写入数据</p></li><li><p>输出流：只能向其写入数据，不能读数据。</p></li></ol><p>Java的输入流主要由<code>InputStream</code>和<code>Reader</code>作为基类，输出流由<code>OutputStream</code>和<code>Writer</code>作为基类。</p><h5 id="2-字节流和字符流"><a href="#2-字节流和字符流" class="headerlink" title="2.字节流和字符流"></a>2.字节流和字符流</h5><p>两者区别在于所操作的数据单元不同，字节流操作的数据单元是8位字节，而字符是16位的字符。字节流主要由<code>InputStream</code>和<code>OutputStream</code>作为基类，字符流由<code>Reader</code>和<code>Writer</code>作为基类。</p><h5 id="3-节点流和处理流"><a href="#3-节点流和处理流" class="headerlink" title="3.节点流和处理流"></a>3.节点流和处理流</h5><p>可以向一个特定的<code>IO</code>设备读写数据的流称为节点流<code>low level stream</code>；处理流则对一个已存在的流进行连接或封装，通过封装后的流来实现数据读写功能，不会连接到实际的数据源，同时它被称作<code>高级流</code>。Java使用处理流来包装节点流是一种典型的装饰器设计模式，通过来包装不同的节点流来消除节点间的差异，以通过更多方法完成输入输出，也叫<code>包装流</code>。</p><p>IO流涉及40多个类，这些类非常有规则，它们都是从以下4个抽象基类派生而成。</p><p><code>IuputStream/Reader</code>：所有输入流的基类，前者是字节输入流，后者是字符输入流。</p><p><code>OutputStream/Writer</code>：所有输出流的基类，前者是字节输出流，后者是字符输出流。</p><p>此外，处理流的功能体现在以下两个方面：</p><ul><li>性能提高：增加缓冲的方式提高IO效率。</li><li>操作便捷：处理流提供大量方法输入输出大批内容。</li></ul><h4 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h4><h5 id="InputStream和Reader"><a href="#InputStream和Reader" class="headerlink" title="InputStream和Reader"></a><code>InputStream</code>和<code>Reader</code></h5><p><code>InputStream</code>包含如下三个方法：</p><ul><li><code>int read()</code>：从输入流读取单个字节，并返回数据</li><li><code>int read(byte[] b)</code>：从输入流中最多读取<code>b.length</code>个字节并存储在数组中，返回实际读取的字节数。</li><li><code>int read(byte[] b,int off,int len)</code>：从off开始读，最多读取<code>len</code>个字节数据，放入b中，返回实际读取字节。</li></ul><p><code>Reader</code>也有三个类似方法，但是读取字符数据。最后要显式关闭IO流，回收资源。</p><h5 id="OutputStream和Writer"><a href="#OutputStream和Writer" class="headerlink" title="OutputStream和Writer"></a><code>OutputStream</code>和<code>Writer</code></h5><ul><li><code>void witer(int c)</code>：将指定字节/字符输出到输出流中，c可以是字节或字符。</li><li><code>void writer(byte[]/char[] buf)</code>：将字节或字符数据输出到指定输出流中</li><li><code>void writer(byte[]/char[] buf,int off,int len)</code>：从off开始，将长度为len的数据输出到输出流。</li></ul><p><code>Writer</code>还包含<code>void writer(String str)</code>,<code>void writer(String str,int off,int len)</code>方法，用字符串代替字符数组。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射篇</title>
      <link href="/2020/1021/"/>
      <url>/2020/1021/</url>
      
        <content type="html"><![CDATA[<h4 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h4><p>对象在运行时会有两种类型，编译时类型和运行时类型，例如：<code>String a = new Name()</code>，编译时为<code>String</code>，运行时为<code>Name</code>。为了准确知道该对象的类型，可以通过<code>instanceof()</code>方法，但是在什么都不知道的情况下，只能通过反射获取该对象的信息。</p><h5 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h5><p>每个类被加载后就会有<code>Class</code>对象生成，通过该对象就可以访问JVM中的这个类了。这里介绍三种获取<code>Class</code>对象的方法：</p><ul><li>使用<code>Class</code>类的<code>forName(String clazzName)</code>静态方法，参数为类的全限定类名。</li><li>调用<code>class</code>属性来获取<code>Class</code>对象，例如：<code>Human.class</code>。</li><li>调用类实例的<code>getClass()</code>方法。该方法在<code>java.lang.Object</code>已定义。</li></ul><h5 id="从Class对象中获取信息"><a href="#从Class对象中获取信息" class="headerlink" title="从Class对象中获取信息"></a>从<code>Class</code>对象中获取信息</h5><p>Class类提供了大量实例方法来获取对应的类信息，一些如下：</p><ul><li>Constructor<T> getConstructor(Class&lt;?&gt; Types)：返回对应类的带参的<code>public</code>构造器。</li><li>Constructor&lt;?&gt;[ ] getDeclaredConstructors()：返回所有构造器，不受访问权限限制。</li><li>Method getDeclaredMethod(String name,Class&lt;?&gt; …parameterTypes)：返回带指定形参的方法，访问权限无关。</li><li>Field getField(String name)：返回对应类的指定名称的<code>public</code>成员变量。</li></ul><h6 id="以下用于访问注解："><a href="#以下用于访问注解：" class="headerlink" title="以下用于访问注解："></a>以下用于访问<code>注解</code>：</h6><ul><li><p><A extends Annotation> A getAnnotation(Class<A> annotationClass)：用于获取指定类型的注解，不存在返回<code>null</code></p></li><li><p><A extends Annotation> A getDeclaredAnnotation(Class<A> annotationClass)</p></li><li><p>Annotation[ ] getAnnotations()：返回对应类上所有注解。</p></li><li><p><A extends Annotation> A[ ] getAnnoationByType(Class<A> annotationClass)：获取修饰该类的、指定的多个注解，例如重复注解。</p></li></ul><h6 id="如下方法访问内部类："><a href="#如下方法访问内部类：" class="headerlink" title="如下方法访问内部类："></a>如下方法访问<code>内部类</code>：</h6><p>Class&lt;?&gt;[] getDeclaredClasses()：返回类中的全部内部类。</p><h6 id="访问外部类方法："><a href="#访问外部类方法：" class="headerlink" title="访问外部类方法："></a>访问<code>外部类</code>方法：</h6><ul><li>Class&lt;?&gt; getDeclaringClass()：返回对应类所在的外部类。</li><li>Class&lt;?&gt;[] getInterfaces()：返回对应类实现的全部接口。</li><li>Class&lt;? super T&gt; getSuperclass()：返回对应类的父类的<code>Class</code>对象。</li></ul><h6 id="以下用于获取对应类的修饰符、所在包、类名："><a href="#以下用于获取对应类的修饰符、所在包、类名：" class="headerlink" title="以下用于获取对应类的修饰符、所在包、类名："></a>以下用于获取对应类的修饰符、所在包、类名：</h6><ul><li>int getModifiers()：返回修饰符，返回的整数用<code>Modifier</code>工具类来解码。</li><li>Package getPackage()：获取类的包名。</li><li>String getName()：返回类名</li><li>String getSimpleName()：返回类名简称。</li></ul><p>还有方法判断类是否为一个接口或注解的，如：<code>boolean isAnnotation()</code>。上述大量方法都是分好的，很有规律。之所以有大量重复类名的方法，是因为在获取<code>Method</code>的时候，类重载了许多方法，想要获取指定的方法必须给出相应的形参列表：</p><pre class="line-numbers language-java"><code class="language-java">clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而获取构造器时无需传入构造器名，只需要给出形参列表即可。</p><h4 id="Java8新增的方法参数反射"><a href="#Java8新增的方法参数反射" class="headerlink" title="Java8新增的方法参数反射"></a>Java8新增的方法<code>参数反射</code></h4><p>Java8在<code>java.lang.reflect</code>包下新增一个<code>Executable</code>抽象基类，该对象代表可执行的类成员，同时该类派生了<code>Constructor</code>、<code>Method</code>两个子类。抽象基类提供了获取修饰方法或构造器注解信息的方法，通过<code>getModifiers()</code>方法获取该方法或构造器的修饰符。此外有两个方法来得到方法和形参名及个数：</p><ul><li>int getParameterCount()：获取构造器或方法的形参个数。</li><li>Parameter[] getParameters()：获取该构造器或方法的所有形参。</li></ul><p>同时在获取形参<code>parameter</code>之后，还提供几个方法获取形参的参数信息：</p><ul><li>getModifiers()：获取形参修饰符。</li><li>String getName()：获取形参名</li><li>Type getParameterizedType()：获取带泛型的形参。</li><li>Class&lt;?&gt; getType()：获取形参类型</li><li>boolean isNamePresent()：返回类的<code>class</code>文件中是否包含方法的形参名信息。</li><li>boolean isVarArgs()：判断参数是否为个数可变的形参</li></ul><h4 id="使用反射生成并操作对象"><a href="#使用反射生成并操作对象" class="headerlink" title="使用反射生成并操作对象"></a>使用反射生成并操作对象</h4><p><code>Class</code>对象可以获得类的方法(Method对象)，构造器(Constructor对象)，成员变量(Field对象)，这三个类都位于<code>java.lang.reflect</code>包下，并实现了<code>java.lang.reflect.Member</code>接口，程序可以提供<code>Method</code>调用方法，通过<code>Constructor</code>调用构造器创建实例，能提供<code>Field</code>对象访问并修改成员变量值。</p><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><p>通过反射来生成对象有以下两种方式：</p><ul><li>通过<code>Class</code>对象的<code>newInstance()</code>方法来创建实例，前提是要有默认构造器。</li><li>先获取<code>Constructor</code>对象，再调用它的<code>newInstance()</code>方法创建，特点是可以指定构造器创建。</li></ul><pre class="line-numbers language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>clazzName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二种方法获取指定构造器可以通过<code>getConstructor()</code>方法来获取指定构造器。</p><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><p>通过调用<code>Class</code>对象的<code>getMethod()</code>方法可以获取对应的<code>Method</code>对象，每个对象对应一个方法。<code>Method</code>对象有一个<code>invoke()</code>方法，签名如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Object invoke(Object obj,args)</span>Method m <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>Name<span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span>config<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行名为Name的方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当通过<code>invoke</code>方法调用对应方法时，需要有调用该方法的权限。若是<code>private</code>方法，可以先调用<code>Method</code>的<code>setAccessible(boolean f)</code>方法，f为<code>true</code>，则该<code>Method</code>使用时取消访问权限检查。</p><h5 id="访问成员变量"><a href="#访问成员变量" class="headerlink" title="访问成员变量"></a>访问成员变量</h5><p>通过<code>Class</code>对象的<code>getField()</code>可以获取该类的成员变量，<code>Field</code>对象提供了如下方法来读取或设置成员变量值：</p><ul><li><code>getXxx(Object obj)</code>：获取obj对象的该成员变量的值。<code>Xxx</code>对应8种基本类型，引用类型则取消后面<code>Xxx</code>。</li><li><code>setXxx(Object obj,Xxx val)</code>：将obj对象的成员变量设置成val值，同理。</li></ul><p>使用两个方法可以访问指定对象的所有成员变量，包括<code>private</code>修饰的成员变量。</p><h5 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h5><p><code>java.lang.reflect</code>包下还提供一个<code>Array</code>类，<code>Array</code>对象可以代表数组，创建数组。</p><ul><li><p>static Object <code>newInstance</code>(Class&lt;?&gt; componentType,int length)：创建一个指定元素、长度的数组。</p></li><li><p>static xxx <code>getXxx</code>(Object array,int index)：返回<code>array</code>数组中第index个元素。引用类型为<code>get(Object array,int index)</code></p></li><li><p>static void <code>setXxx</code>(Object array,int index,Xxx val)：将数组第index个元素的值设为val，如果数组元素为引用类型则方法变成<code>set</code>。</p></li></ul><pre class="line-numbers language-java"><code class="language-java">Object arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//多维再添加数字</span>Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"某菜鸡"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object o <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="用反射生成JDK动态代理"><a href="#用反射生成JDK动态代理" class="headerlink" title="用反射生成JDK动态代理"></a>用反射生成JDK动态代理</h4><p>在Java的<code>java.lang.reflect</code>包下提供一个<code>proxy</code>类和<code>InvocationHandle</code>接口，通过使用代理类和接口可以生成JDK动态代理类和对象。</p><h5 id="使用proxy和InvocationHandle创建动态代理"><a href="#使用proxy和InvocationHandle创建动态代理" class="headerlink" title="使用proxy和InvocationHandle创建动态代理"></a>使用<code>proxy</code>和<code>InvocationHandle</code>创建动态代理</h5><p><code>Proxy</code>提供了用于创建动态代理类和对象的静态方法，它是所有动态代理类的父类。如果在程序中为一个或多个接口动态生成实现类，就可以使用<code>Proxy</code>来创建动态代理类；如果需要为一个或多个接口动态创建实例，也可以使用<code>Proxy</code>来创建动态代理实例。</p><ul><li><p>static Class&lt;?&gt; getProxyClass(ClassLoader loader,Class? &gt;interface)：创建一个代理类对应的<code>Class</code>对象，该代理类将实现<code>interfces</code>所指定的多个接口。</p></li><li><p>static Object newProxyInstance(ClassLoder loder,Class&lt;&gt;[] interfaces,InvocationHandler h)：创建一个动态代理对象，该对象实现了一些接口，执行代理对象的每个方法时都会被替换执行<code>InvocationHandle</code>对象的<code>invoke</code>方法。</p></li></ul><p>采用第一个方法生成代理类的时候，如果需要通过代理类创建对象，依然需要传入一个<code>InvocationHandler</code>对象，即一个代理对象关联一个<code>InvocationHandler</code>对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">person</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span>Method m<span class="token punctuation">,</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"方法"</span><span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="动态代理和AOP"><a href="#动态代理和AOP" class="headerlink" title="动态代理和AOP"></a>动态代理和<code>AOP</code></h5><p>由于JDK动态代理只能为接口创建动态代理，所以下面先提供一个Dog接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Dog</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GDog</span> <span class="token keyword">implements</span> <span class="token class-name">Dog</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> info<span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"狗"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> run<span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"疾跑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果直接使用代理类为该接口创建动态代理对象，则动态代理对象的所有方法的执行效果将完全一样。下面提供一个<code>DogUtil</code>类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DogUtil</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//拦截器方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第一个通用方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通用方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>借助于<code>Proxy</code>和<code>InvocationHandler</code>就可以实现，当调用info方法和run方法时，系统将自动把两个通用方法插入<code>info</code>和<code>run</code>方法中执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Object target<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTarget</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span>Method m<span class="token punctuation">,</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        DogUtil d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DogUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProxyFactory</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//为target生成动态代理对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">getProxy</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        MyInvocationHandler h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        h<span class="token punctuation">.</span><span class="token function">setTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getIInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//返回动态代理</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面动态代理工厂类提供一个<code>getProxy()</code>方法，该方法为<code>target</code>对象生成一个动态代理对象，这个对象与<code>target</code>实现了同样的接口。当调用动态代理对象的指定方法时，实际上将变为执行<code>MyInvocationHandler</code>对象的<code>invoke</code>方法。执行步骤为：</p><ol><li>创建<code>DogUtil</code>实例</li><li>执行<code>DogUtil</code>实例的<code>method1()</code>方法</li><li>使用反射以<code>target</code>作为调用者执行该方法</li><li>执行<code>DogUtil</code>实例的<code>method2()</code>方法</li></ol><p>当使用动态代理对象来代替<code>target</code>对象时，代理对象的方法既能插入通用方法，但<code>GDog</code>方法又没有像过去一样调用<code>method1</code>和<code>method2</code>方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Dog target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GDog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Dog dog <span class="token operator">=</span> <span class="token punctuation">(</span>Dog<span class="token punctuation">)</span>MyProxyFactory<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        dog<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dog<span class="token punctuation">.</span>run<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dog</code>为实际动态代理对象，实现了Dog接口，动态代理可以很容易实现<code>解耦</code>，这种动态代理在<code>AOP</code>中称为<code>AOP</code>代理，<code>AOP</code>代理包含了目标对象的全部方法。代理中的方法与目标对象的方法有差异：<code>AOP</code>代理包含的方法可以在执行目标方法之前、之后插入一些通用处理。</p><h4 id="反射与泛型"><a href="#反射与泛型" class="headerlink" title="反射与泛型"></a>反射与泛型</h4><p><code>String.class</code>的类型实际上是<code>Class&lt;String&gt;</code>，如果类型未知，则使用<code>Class&lt;?&gt;</code>，反射中使用泛型可以避免生成的对象需要类型转换。前面介绍了<code>Array</code>类创建数组，其实并不常用，<code>newInstance()</code>返回一个数组，而不是<code>Object</code>对象，如果要当<code>String[]</code>数组使用则要强制类型转换。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">newInstance</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> componentType<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> dimension<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果改为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">newInstance</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> componentType<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则无需类型转换，但是得到参数可变的接收了。</p><h5 id="使用反射获取泛型信息"><a href="#使用反射获取泛型信息" class="headerlink" title="使用反射获取泛型信息"></a>使用反射获取泛型信息</h5><p>得到成员变量对应的<code>Field</code>对象后就可以获得具体的数据类型了，首先应该获得所含的成员变量：</p><pre class="line-numbers language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> a <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取成员变量的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果成员变量是含有泛型类型，则使用如下方法获取：</p><pre class="line-numbers language-java"><code class="language-java">Type t <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就可以将<code>Type</code>对象强制转换成<code>ParametericedType</code>对象(被参数化的类型)，它提供了两个方法：</p><ul><li><code>getRawType()</code>：返回原始类型，没有泛型信息。</li><li><code>getActualTypeArguments()</code>：返回泛型参数的类型。</li></ul><p><code>getType()</code>方法只能获取普通类型的成员变量的数据类型，而带泛型的成员变量，应该使用<code>getGenericType()</code>方法。<code>Type</code>是<code>java.lang.reflect</code>包下的接口，代表所有类型的高级接口，<code>Class</code>是<code>Type</code>接口的实现类。<code>Type</code>包括原始类型、参数化类型、数组类型、类型变量和基本类型。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载篇</title>
      <link href="/2020/1018/"/>
      <url>/2020/1018/</url>
      
        <content type="html"><![CDATA[<h4 id="Java类加载"><a href="#Java类加载" class="headerlink" title="Java类加载"></a>Java类加载</h4><p>这部分知识比较深入底层，将重点介绍类加载和反射，会提到JDK动态代理、<code>AOP</code>，反射等诸多知识点。当调用Java命令允许程序时，该命令会启动多个线程，它们都处于该Java虚拟机进程里。所有线程、变量处于同一个进程里，它们都使用JVM进程的内存区。当出现以下情况，进程将终止：</p><ul><li>程序结束</li><li>使用<code>System.exit()</code>或<code>Runtime.getRuntime().exit()</code>代码</li><li>未捕获到异常</li><li>强制结束进程</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        A a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span>a<span class="token operator">++</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出7</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        A b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出6</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码表明，不同的进程之间是不会共享资源的，运行<code>Test1</code>和<code>Test2</code>是运行两次进程，所以第二次依然重新初始化A类。</p><h5 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h5><p>当需要使用某个类时，系统会通过加载、连接、初始化三个步骤完成对<code>类的初始化</code>。<code>类加载</code>指的是类加载器将类的<code>class</code>文件读入内存，并为之创建一个<code>java.lang.Class</code>对象。类加载器通常由JVM提供，也称<code>系统类加载器</code>，除此之外，开发者可以通过继承<code>ClassLoader</code>基类来创建类加载器。使用不同类加载器，可以从不同来源加载类的数据通常有以下来源：</p><ul><li>本地加载<code>class</code>文件</li><li>JAR包中加载<code>class</code>文件</li><li>网络加载</li><li>把一个Java源文件动态编译并加载</li></ul><h5 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h5><p>创建了<code>Class</code>对象后，系统将二进制数据合并到JRE中，这一过程可分为三个阶段：</p><ol><li>验证：验证加载的类是否有正确的内部结构</li><li>准备：为类变量分配内存，并设置默认值</li><li>解析：将类的二进制数据中的符号引用替换成直接引用</li></ol><h5 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h5><p>在初始化阶段，JVM负责对类进行初始化，主要对<code>类变量</code>进行初始化。初始化有两种方式：</p><ul><li>声明变量时就指定初始值</li><li>使用静态代码块指定初始值</li></ul><p>JVM初始化一个类是按照一定规则进行的，如下：</p><ul><li>如果没有加载和连接，则先加载并连接该类</li><li>如果父类没有初始化，则优先初始化其父类</li><li>如果有初始化语句，则系统先执行初始化语句</li></ul><p>所以JVM总是最先初始化<code>java.lang.Object</code>类，并顺着继承链依次加载并初始化类。程序通过以下6种方式来使用某个类和接口时，系统就会初始化该类或接口：</p><ul><li>创建类实例。包括：使用<code>new</code>关键字；反射创建；反序列化创建。</li><li>调用类方法。</li><li>访问类变量或赋值。</li><li>反射强制创建某个类或接口对应的<code>java.lang.Class</code>对象。(如果还未初始化该类)</li><li>初始化某类的子类。</li><li>使用<code>java.exe</code>命令运行某个类。</li></ul><p>对于<code>final</code>型的类变量，如果该类变量的值在编译时就确定下来，那么这个类变量相当于“宏变量”。因此使用静态类变量也不会导致该类初始化，相当于使用常量。如果<code>final</code>修饰的变量不能确定下来，必须等到运行时确定，则将使该类初始化。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类加载器负责将<code>.class</code>文件加载到内存中，并生成一个<code>java.lang.Class</code>实例，一旦一个类被加载到JVM中，同一个类就不会被再次载入。所谓<code>同一个类</code>指的是有唯一标识的类，唯一标识是用全限定类名作为载入标识。在JVM中一个类用其全限定类名和其类加载器作为其全限定类名，例如：(类、package、加载器实例)。</p><p>当JVM启动时，会形成由三个类加载器组成的<code>初始类加载器层次结构</code>，加载顺序如下。</p><ul><li>Bootstrap ClassLoader：根类加载器(不是Java实现，一般无法访问)</li><li>Extension ClassLoader：扩展类加载器</li><li>System ClassLoader：系统类加载器</li></ul><p><code>Bootstrap ClassLoader</code>也叫引导(启动)类加载器，负责加载Java核心类。它不是<code>java.lang.ClassLoader</code>的子类，而是由<code>JVM</code>自己实现。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BootstrapTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        URLS<span class="token punctuation">[</span><span class="token punctuation">]</span> u <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher<span class="token punctuation">.</span><span class="token function">getBootstrapClassPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getURLS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历输出根类加载器的全部URL</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>u<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toExternalForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Extension ClassLoader</code>，<code>ExtClassLoader(sun.misc.Launcher$ExtClassLoader)</code>的实例，负责加载JRE的扩展目录中的JAR包的类，通过这种方式可以为Java扩展核心类以外的功能，只要把开发的类打包成JAR包即可，然后放入<code>JAVA_HOME/jre/lib/ext</code>路径即可。</p><p><code>System ClassLoader</code>，应用类加载器<code>AppClassLoader</code>的实例，它负责在JVM启动时加载来自命令<code>-classpath</code>或<code>CLASSPATH</code>环境变量所指定的JAR包和类路径。可以通过调用<code>ClassLoader</code>的<code>getSystemClassLoader()</code>方法来获取系统类加载器。</p><p>系统类加载器是当前路径，扩展类加载器的加载路径是<code>JAVA_HOME/jre/lib/ext</code>，所以可以说其父加载器为<code>null</code>也不为过，<code>getParent()</code>方法返回<code>null</code>，但根加载器可以作为其父加载器。</p><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><h5 id="加载机制有三种："><a href="#加载机制有三种：" class="headerlink" title="加载机制有三种："></a>加载机制有三种：</h5><ul><li>全盘委托：当某加载器加载一个类时，该类所引用和依赖的其他类也将由该类加载器负责加载。</li><li>父类(双亲)委托：先让父类加载器加载<code>class</code>，如果无法加载则从自己的类路径中加载。</li><li>缓存机制：保证所有已加载过的类都被缓存，当需要使用某个类时，加载器先从缓存区加载该类，如不存在才会加载对应的二进制数据，并将其转换成<code>Class</code>对象存入内存。(所以修改某个类后需重启JVM才会生效)</li></ul><p>一个类加载器查找<code>class</code>和<code>resource</code>时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到<code>Bootstrap ClassLoader</code>，如果<code>Bootstrap ClassLoader</code>找到了，直接返回；如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。 </p><h5 id="JDK搜索类的方式"><a href="#JDK搜索类的方式" class="headerlink" title="JDK搜索类的方式"></a>JDK搜索类的方式</h5><p><code>ClassLoader</code>使用的是<code>双亲委托</code>模型来搜索类的，每个<code>ClassLoader</code>实例都有一个父类加载器的引用(不是所谓的//继承的关系，是一个包含的关系），虚拟机内置的类加载器<code>Bootstrap ClassLoader</code>本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器，但是访问<code>ExtClassLoader</code>的父加载器返回<code>null</code>。</p><p>当一个<code>ClassLoader</code>实例需要加载某个类时，它会试图在亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器<code>Bootstrap ClassLoader</code>试图加载，如果没加载到，则把任务转交给<code>Extension ClassLoader</code>试图加载，如果也没加载到，则转交给<code>AppClassLoader</code>进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出<code>ClassNotFoundException</code>异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的实例对象。</p><p>好处：因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要让子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心API中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器(Bootstrap ClassLoader)加载，所以用户自定义的<code>ClassLoader</code>永远也无法加载一个自己写的String类，除非你改变JDK中ClassLoader搜索类的默认算法。</p><h5 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h5><ol><li>检查是否有载入过。</li><li>如果父类加载器不存在，则使用根类加载器来载入类并返回对应<code>java.lang.Class</code>对象，否则执行第5步；如果存在则使用父类加载器去加载类并返回Class对象，不成功则执行第3步。</li><li>当前加载器从与它相关的类路径中寻找，找到就执行第4步，否则执行第5步。</li><li>从文件中载入Class，成功后同样返回<code>Class</code>对象。</li><li>抛出<code>ClassNotFoundException</code>异常。</li></ol><p>JVM规范中规定如果用户自定义的类加载器将父类加载器强制设置为<code>null</code>，那么会自动将启动类加载器设置为当前用户自定义类加载器的父类加载器。同时，即使用户自定义类加载器不指定父类加载器，那么同样可以加载到/lib下的类。自定义类加载器不指定父类加载器是默认系统类加载器为父类加载器，按照双亲委派加载。若强制父类加载器为<code>null</code>，则其他加载器就可能不被加载。</p><p>加载流程为：系统类加载器–&gt;扩展类加载器–&gt;启动类加载器，强制设置<code>parent</code>为<code>null</code>时关系就已经断了 源代码中走<code>findBootstrapClassOrNull(name)</code>加载</p><h4 id="创建自定义类"><a href="#创建自定义类" class="headerlink" title="创建自定义类"></a>创建自定义类</h4><p>JVM中除根加载器外，其他都是<code>ClassLoader</code>抽象类的子类实例，开发者可以扩展其子类并重写所含方法来实现自定义类加载器。类加载器有两个关键方法：</p><ul><li><code>loadClass(String name,boolean resolve)</code>：类加载器的入口点，根据指定名称加载类，并获取<code>Class</code>对象。</li><li><code>findClass(String name)</code>：根据指定名称查找类。</li></ul><p>如果需要实现自定义类加载器，则可以通过重写以上两个方法来实现。<code>loadClass()</code>方法的执行步骤如下：</p><ul><li>用<code>findLoadedClass(String)</code>来检查是否已经加载类，已加载则返回。</li><li>在父类加载器上调用<code>loadClass()</code>方法。如果父类为<code>null</code>，则使用根类加载器来加载。</li><li>调用<code>findClass(String)</code>方法查找。</li></ul><p>重写<code>finsClass()</code>方法可以避免覆盖默认类加载器的<code>双亲委托</code>、缓存机制，在<code>ClassLoader</code>里还有一个核心方法<code>Class defineClass(String name,byte[] b,int off,int len)</code>，负责将类的字节码文件读入字节数组<code>byte[] b</code>内，并把它转化为<code>Class</code>对象。<code>defineClass()</code>方法管理JVM的许多复杂的实现，不能被重写，因为是<code>final</code>的。除此外还有一些普通方法如下：</p><ul><li><code>findSystemClass(String name)</code>：从本地文件系统装入文件，存在就用<code>defineClass()</code>方法将字节码转换成<code>Class</code>对象。</li><li><code>static getSystemClassLoader()</code>：返回系统类加载器</li><li><code>getParent()</code>：获取父类加载器。</li><li><code>resolveClass(Class&lt;?&gt; c)</code>：链接指定类。</li><li><code>findLoaderClass(String name)</code>:如果已加载该类，则返回<code>Class</code>实例，否则返回<code>null</code>。</li></ul><h5 id="使用自定义类的好处"><a href="#使用自定义类的好处" class="headerlink" title="使用自定义类的好处"></a>使用自定义类的好处</h5><p>它能用来实现以下功能：</p><ul><li>执行代码前自动验证数字签名</li><li>根据提供的密码解密代码，避免反编译</li><li>动态加载类</li><li>把数据以字节码形式加载到应用中</li></ul><h4 id="URLClassLoader实现类"><a href="#URLClassLoader实现类" class="headerlink" title="URLClassLoader实现类"></a>URLClassLoader实现类</h4><p>该类是<code>SystemClassLoader</code>和<code>ExtClassLoader</code>的父类，注意不同上面的所谓“父类”，这里是类之间的继承关系。有如下两个构造器：</p><ul><li><code>URLClassLoader(URL[] urls)</code>：使用默认父类加载器创建一个<code>ClassLoder</code>对象，并从指定路径加载类。</li><li><code>URLClassLoader(URL[] urls,ClassLoader parent)</code>：不同上面的构造器，它可以指定一个父类加载器加载类。</li></ul><p>获得<code>URLClassLoader</code>对象后，就可以调用<code>loadClass()</code>方法来加载指定类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Connection coon<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> Connection <span class="token function">getConn</span><span class="token punctuation">(</span>String url<span class="token punctuation">,</span>String user<span class="token punctuation">,</span>String pass<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>conn <span class="token operator">=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        URL<span class="token punctuation">[</span><span class="token punctuation">]</span> urls <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"file:mysql-connector-java-5.1.30-bin.jar"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        URLClassLoader myClassLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLClassLoader</span><span class="token punctuation">(</span>urls<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//加载MySQL的JDBC驱动，并创建一个实例</span>        Driver driver <span class="token operator">=</span> <span class="token punctuation">(</span>Driver<span class="token punctuation">)</span>myClassLoader<span class="token punctuation">.</span><span class="token function">loaderClass</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建一个设置JDBC连接属性的properties对象</span>        Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span>pass<span class="token punctuation">)</span><span class="token punctuation">;</span>        conn <span class="token operator">=</span> driver<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//连接数据库</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> conn<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getConn</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/mysql"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"root"</span><span class="token punctuation">,</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解篇</title>
      <link href="/2020/1016/"/>
      <url>/2020/1016/</url>
      
        <content type="html"><![CDATA[<h4 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h4><p>从<code>Java5</code>开始，Java增加对元数据的支持，也就是<code>Annotation</code>，不是一般的注释。这些标记在编译、类加载、运行时被读取，并执行相应处理。通过使用注解，开发人员在源文件中嵌入一些补充信息，进而代码分析和部署工具可以通过这些补充信息进行部署。某方面看，<code>Annotation</code>就像修饰符一样，可用于修饰包、方法和构造器、变量等，这些信息被储存在<code>Annotation</code>的”name=value”对中。</p><p><code>Annotation</code>是一个接口，程序可以通反射来获取指定程序元素的<code>Annotation</code>对象，然后通过注解对象来取得里面的元数据。</p><h4 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h4><p>注解必须使用工具提取元数据，工具还会根据元数据增加额外的功能，这种处理访问注解的工具统称<code>APT</code>。5个注解都在<code>Java.lang</code>包下，5个基本注解如下：</p><ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li><li>@SafeVarargs(Java7新增)</li><li>@FunctionalInterface(Java8新增)</li></ul><h5 id="限定重写父类：-Override"><a href="#限定重写父类：-Override" class="headerlink" title="限定重写父类：@Override"></a>限定重写父类：@Override</h5><p><code>@Override</code>就是用来指定方法覆盖的，它强制一个子类必须重写父类方法，告诉编译器检查这个方法，避免低级错误。注意的是：<code>@Override</code>只能修饰<code>方法</code>，不能修饰其他程序元素！</p><h5 id="标识已过时：-Deprecated"><a href="#标识已过时：-Deprecated" class="headerlink" title="标识已过时：@Deprecated"></a>标识已过时：@Deprecated</h5><p>该注解表示<code>类、方法、接口</code>已过时，当其他程序使用已过时的类、方法时，编译器将警告。</p><h5 id="抑制编译器警告：-SuppressWarnings"><a href="#抑制编译器警告：-SuppressWarnings" class="headerlink" title="抑制编译器警告：@SuppressWarnings"></a>抑制编译器警告：@SuppressWarnings</h5><p>顾名思义，注解让编译器不会发出警告，如果修饰在类上，则该类不会有任何警告出现，如果修饰方法，则该方法不会有任何警告出现。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuppressTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> myList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//此处泛型语法警告将被抑制</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Java7堆污染警告和-SafeVarargs"><a href="#Java7堆污染警告和-SafeVarargs" class="headerlink" title="Java7堆污染警告和@SafeVarargs"></a>Java7堆污染警告和@SafeVarargs</h5><p>上次讲泛型的时候，把一个不带泛型的对象赋给一个带泛型的变量时，将有可能引起转换异常，这种错误的原因可以称为<code>堆污染</code>。有些时候，开发者不希望看到该警告，可以用以下三种方法抑制警告：</p><ul><li>@SafeVarargs修饰该方法或构造器</li><li>@SuppressWarnings(“unchecked”)</li><li>编译使用<code>-Xlint:varargs</code></li></ul><h5 id="Java8的函数式接口与-FunctonalInterface"><a href="#Java8的函数式接口与-FunctonalInterface" class="headerlink" title="Java8的函数式接口与@FunctonalInterface"></a>Java8的函数式接口与@FunctonalInterface</h5><p>Java8规定：如果接口中只有一个<code>抽象方法</code>，该接口就是<code>函数式接口</code>。而该注解就是用来指定某个<code>接口</code>必须为函数式接口的，只能含有一个<code>抽象方法</code>。注意：该注解只能修饰接口！</p><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>JDK除了5个基本注解外，还提供了6个元注解，其中5个都用于修饰其他注解定义，其中的<code>@Repeatable</code>专门用于定义<code>Java8</code>新增的重复注解。</p><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>只能用于修饰注解定义，用于指定注解可以保留多长时间。<code>@Retention</code>包含一个<code>RetentionPolicy</code>类型的<code>Value</code>成员变量，使用时指定值。<code>value</code>成员变量的值只能是如下三个：</p><ul><li>RetentionPolicy.CLASS：编译器把注解记录在<code>class</code>文件中，当运行程序时，JVM不可获取注解信息。默认值！</li><li>RetentionPolicy.RUNTIME：编译器把注解记录在<code>class</code>文件中，当运行程序时，JVM可以获取注解信息，程序可以通过反射获取注解信息。</li><li>RetentionPolicy.SOURCE：注解只保留在源代码中，编译器之间丢弃。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>value<span class="token operator">=</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//@Retention(RetentionPolicy.RUNTIME) 也可以,当成员变量为value时，可直接填入值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><p>只能修饰一个注解定义，用于指定被修饰的注解能用于修饰哪些程序单元。。同样它也包含一个名为<code>value</code>的成员变量，其值有：</p><ul><li>ElementType.ANNOTATION_TYPE：指定注解只能修饰注解</li><li>ElementType.CONSTRUCTOR：指定该注解只能修饰构造器</li><li>ElementType.FIELD：只能修饰成员变量</li><li>ElementType.LOCAL_VARIABLE：只能修饰局部变量</li><li>ElementType.METHOD：只能修饰方法</li><li>ElementType.PACKAGE：只能修饰包</li><li>ElementType.PARAMETER：修饰参数</li><li>ElementType.TYPE：可以修饰类、接口、注解或枚举定义</li></ul><p>同样的操作，在括号内指定<code>value</code>值，可以省去<code>name=value</code>形式，直接填入值。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只能修饰成员变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><p>指定修饰的<code>Annotation类</code>将被<code>javadoc</code>工具提取成文档，如果定义<code>Annotation类</code>使用了该注解，则所有使用该<code>Annotation</code>修饰的程序元素的API文档中将包含该<code>Annotation</code>说明。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Test</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//自定义一个注解，该注解信息将被提取进入API文档</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><p>指定被它修饰的<code>Annotation</code>具有继承性，即某个类使用了该<code>Annotation</code>，则其子类将自动被该<code>Annotation</code>修饰。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Inherited</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">i</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用i注解的类，其子类自动含有该注解</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>上面已经提到了自定义注解，跟定义接口差不多，只不过在<code>interface</code>前添加@符号。通常自定义注解可以修饰任何程序元素，比如类、接口、方法等。然而我们可以根据<code>Annotation</code>是否包含成员变量，可以分为两类：</p><ul><li>标记注解：没有成员变量，仅提供标记信息。</li><li>元数据注解：包含成员变量的<code>Annotation</code>，它们可以接收更多的元数据。</li></ul><p>一旦在注解内定义成员变量后，使用时就应该指定成员变量的值，或者直接在注解内指定默认值，可使用<code>default</code>关键字。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MyTag</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"James"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">32</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//int[] ages();</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@MyTag</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> test<span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="提取注解信息"><a href="#提取注解信息" class="headerlink" title="提取注解信息"></a>提取注解信息</h4><p>Java使用<code>Annotation</code>接口来代表程序元素前的注解，该接口是所有注解的的父接口，同时在<code>java.lang.reflect</code>包下新增<code>AnnotatedElement</code>接口，该接口表示可以接收注解的程序元素。该接口的实现类主要有：</p><ul><li>Class：类定义</li><li>Constructor：构造器定义</li><li>Field：类的成员变量</li><li>Method：类的方法</li><li>Package：类的包</li></ul><p>包同时还包含一些反射功能的工具类，<code>AnnotatedElement</code>接口是所有程序元素的父接口，所以程序通过反射获取某个类的<code>AnnotatedElement</code>对象之后，就可以调用对象的几个方法来访问<code>Anntation</code>信息。</p><ul><li><A extends Anntation> A getAnnotation(Class<A> annotationClass)：返回指定类型的注解，不存在返回<code>null</code></li><li><A extends Anntation> A getDeclaredAnnotations(Class<A> annotationClass)：获取直接修饰该程序元素、指定类型的<code>Annotation</code>，不存在返回<code>null</code>。</li><li>Annotation[ ] getAnnotation()：返回该程序元素上存在的所有注解</li><li>Annotation[ ] getDeclaredAnnotations()：返回直接修饰该程序元素的指定<code>Annotation</code>。</li><li>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)：判断该程序元素上是否有指定类型的注解。</li></ul><p>使用第一种的自定义注解，即没有成员变量的注解，它的作用是标记。如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Testable</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的<code>@Testable</code>注解用于标记哪些方法是可以测试的，该注解可以作为<code>JUnit</code>测试的补充。</p><h4 id="Java8新增注解"><a href="#Java8新增注解" class="headerlink" title="Java8新增注解"></a>Java8新增注解</h4><h5 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h5><p>在Java8以前，同一程序元素前最多只能使用一个类型的<code>Annotation</code>，如果需要使用多个相同类型的注解，则必须使用<code>Annotation</code>容器。Java8以前为如下形式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Results</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"James"</span><span class="token punctuation">,</span>location<span class="token operator">=</span><span class="token string">"james.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"Kameron"</span><span class="token punctuation">,</span>location<span class="token operator">=</span><span class="token string">"kameron.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>@Results</code>注解只包含一个名为<code>value</code>、类型为<code>Result[]</code>的成员变量，指定多个<code>@Result</code>作为<code>value</code>的属性的数组元素。改进后为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"James"</span><span class="token punctuation">,</span>location<span class="token operator">=</span><span class="token string">"james.jsp"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"Kameron"</span><span class="token punctuation">,</span>location<span class="token operator">=</span><span class="token string">"kameron.jsp"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述即为重复注解，可以被多次使用修饰某一程序元素。开发此类重复注解需要使用<code>@Repeatable</code>修饰。</p><h5 id="新增TypeAnnotation注解"><a href="#新增TypeAnnotation注解" class="headerlink" title="新增TypeAnnotation注解"></a>新增<code>TypeAnnotation</code>注解</h5><p>Java8为<code>ElementType</code>枚举增加了<code>TYPE_PARAMETER</code>、<code>TYPE_USE</code>两个枚举值，这样允许定义枚举时使用<code>@Target(ElementType.TYPE_USE)</code>修饰，这种注解被称为<code>TypeAnnotation 类型注解</code>，<code>TypeAnnotation</code>可用在任何用到类型的地方。比如：</p><ul><li>创建对象时(new)</li><li>类型转换时</li><li>实现接口时</li><li><code>throws</code>声明抛出异常时</li></ul><p>以上情况都会用到类型，因此可以使用注解来修饰。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">)</span><span class="token annotation punctuation">@NotNull</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TypeTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@NotNull</span> FileNotFoundException<span class="token punctuation">{</span>        Object a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NotNull</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token string">"菜鸡一号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token annotation punctuation">@NotNull</span> String<span class="token punctuation">)</span> info<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要想让这些<code>TypeAnnotation</code>起作用，开发者需要自己实现<code>Type Annotation</code>检查框架或者使用第三方框架。</p><h4 id="编译时处理注解"><a href="#编译时处理注解" class="headerlink" title="编译时处理注解"></a>编译时处理注解</h4><p><code>APT(Annotation Processing Tool)</code>是一种注解处理工具，它对源代码进行检查，并找出源文件所包含的<code>Annotation</code>信息，做额外处理。使用<code>APT</code>的目的是简化开发者的工作量，因为APT可以在编译程序源代码的同时生成一些附属文件，比如源文件、类文件、XML文件等，内容与源代码文件相关。简而言之，APT可以替代对代码信息和附属文件的维护工作。</p><p><code>Java.exe</code>工具有一个<code>-processor</code>选项，可指定一个<code>Annotation</code>处理器，如果指定了这个处理器，那么这个处理器会在编译时提取并处理源文件中的注解。每个注解处理器都需要实现<code>javax.anntation.processing</code>包下的<code>Processor</code>接口。不过实现该接口必须实现所有方法，因此会采用继承<code>AbstractProcessor</code>方式来实现注解处理器。一个处理器可以处理一种或多种<code>Annotation</code>类型！</p><pre class="line-numbers language-java"><code class="language-java">javac <span class="token operator">-</span>processor HibernateAnnotationProcessor Person<span class="token punctuation">.</span>java<span class="token comment" spellcheck="true">//路径下生成一个Person.hbm.xml文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>XML</code>文件根据源代码文件中的<code>Annotation</code>生成，这是使用APT的结果！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型篇</title>
      <link href="/2020/1013/"/>
      <url>/2020/1013/</url>
      
        <content type="html"><![CDATA[<h4 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h4><p>上次讲了集合，就是放对象的容器，但是集合并不知道对象的具体数据类型，所以很容易发生异常。比如：</p><pre class="line-numbers language-java"><code class="language-java">List a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"as"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token operator">></span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//强制转换错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 泛型<code>generics</code>是JDK 5中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。这样不仅大大减少了代码量，还利于避免不必要的异常！</p><h4 id="泛型菱形语法"><a href="#泛型菱形语法" class="headerlink" title="泛型菱形语法"></a>泛型<code>菱形</code>语法</h4><p>从Java7开始，在用构造器创建对象时后面不用再带上泛型了，简化了代码，例如：</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="定义接口、类和泛型方法"><a href="#定义接口、类和泛型方法" class="headerlink" title="定义接口、类和泛型方法"></a>定义接口、类和泛型方法</h4><p>Java5为接口和类增加了泛型支持，从而可以在创建集合对象时传入类型实参。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StrList</span> <span class="token keyword">extends</span> <span class="token class-name">List</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>String x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StrList</span> <span class="token keyword">extends</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>String x<span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">human</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//定义一个泛型类</span>    <span class="token keyword">public</span> T man<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">human</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">human</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>man<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">human</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">":"</span><span class="token operator">+</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，定义一个泛型接口，可以衍生出多个类型子接口，同样一个带泛型的父类可以衍生出许多子类，当使用这些接口和父类时，不能再包含类型形参！但是可以不传入类型实参，例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">human</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//返回字符串类型</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要重写继承父类的子类方法，则需要注意类型。对于泛型，只是允许程序员在编译时检测到非法的类型而已。但是在运行期时，其中的泛型标志会变化为<code>Object</code>类型。</p><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><p>方法想定义自己的泛型形参也是允许的，这样还提供了对泛型方法的支持。&lt;&gt;括号内为<code>类型形参</code>声明！</p><p>格式为：<code>修饰符 &lt;T,V&gt; 返回值类型 方法名(形参列表){...}</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> ele<span class="token punctuation">,</span>Collection<span class="token operator">&lt;</span>T<span class="token operator">></span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>T ele<span class="token operator">:</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>            a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Object<span class="token operator">></span> ao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> as <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">test</span><span class="token punctuation">(</span>as<span class="token punctuation">,</span>ao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="泛型构造器"><a href="#泛型构造器" class="headerlink" title="泛型构造器"></a>泛型构造器</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Output</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">Output</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Output</span><span class="token punctuation">(</span><span class="token string">"发"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Output</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Output</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//实参是Double类型出错</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>泛型构造器可以认为是泛型方法的特殊一种，不过大致上它们都差不多！</p><h4 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符?"></a>类型通配符<code>?</code></h4><p>使用泛型类时，都应该为这个泛型类传入实参，否则会提出警告。类型通配符一般是使用<code>?</code>代替具体的类型参数，它可以匹配任何类型，List&lt;?&gt;在逻辑上是List<Number>等所有具体类型实参的父类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种类型通配符的<code>List</code>仅表示它是各种泛型List的父类，并不能直接添加元素。例如：</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于无法得知c中的元素类型，所以不能向其中添加对象，除了添加<code>null</code>。</p><h5 id="类型通配符上限"><a href="#类型通配符上限" class="headerlink" title="类型通配符上限"></a>类型通配符上限</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getNumber</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token operator">></span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"data :"</span> <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>&lt;? extends T&gt;</code>表示该通配符所代表的类型是T类型的子类(或本身)，<code>&lt;? super T&gt;</code>表示该通配符所代表的类型是T类型的父类。</p><h5 id="类型通配符下限"><a href="#类型通配符下限" class="headerlink" title="类型通配符下限"></a>类型通配符下限</h5><p>类型通配符下限通过形如<code>List&lt;? super Number&gt;</code>来定义，表示类型只能接受<code>Number</code>本身及其父类类型，如<code>Object</code>类型的实例。</p><h4 id="泛型方法与类型通配符的区别"><a href="#泛型方法与类型通配符的区别" class="headerlink" title="泛型方法与类型通配符的区别"></a>泛型方法与类型通配符的区别</h4><p>什么时候用类型通配符，什么时候用泛型方法呢？</p><ul><li>通配符能用来支持灵活的子类化</li><li>泛型方法允许类型形参用来表示一个或多个参数或参数与返回值之间的依赖关系</li><li>类型通配符可以在方法名中定义形参类型，也可以定义变量类型；但泛型方法的类型形参必须在显示声明</li></ul><h4 id="设定类型形参的上限"><a href="#设定类型形参的上限" class="headerlink" title="设定类型形参的上限"></a>设定类型形参的上限</h4><p>泛型不仅允许使用通配符形参上限，还可以设置类型形参的上限。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//Number及其子类</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Apple<span class="token operator">&lt;</span>Integer<span class="token operator">></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Apple<span class="token operator">&lt;</span>String<span class="token operator">></span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//String不是Number的子类，将引起异常</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义了一个<code>泛型类</code>，形参上限是<code>Number</code>及其子类，传入一个<code>String</code>类将导致编译错误。如果需要设定多个上限和接口，表示该形参类型既是父类及其子类，并且实现了多个上限接口。需要注意的是所有<code>接口上限</code>必须在类上限之后，<code>类上限</code>始终在前面。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token operator">&amp;</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="擦除和转换"><a href="#擦除和转换" class="headerlink" title="擦除和转换"></a>擦除和转换</h4><p>严格泛型代码里，带泛型声明的类总应该带着类型参数。但是允许使用带泛型声明的类时，不指定类型实参，如果没有指定的话，则该类型参数被称作<code>raw type</code>原始类型，默认声明为该类型参数的第一个上限类型！</p><p>当把一个带泛型信息的对象赋给另一个没有泛型信息的变量时，泛型信息将抛弃，称<code>擦除</code>。比如一个<code>List&lt;String&gt;</code>类型转给<code>List</code>类型，该<code>List</code>的类型上限变为<code>Object</code>。 如果将<code>List</code>对象赋给一个<code>List&lt;String&gt;</code>对象，不会引起编译错误，但是提示<code>未经检查的转换</code>。</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List list <span class="token operator">=</span> a<span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> ls <span class="token operator">=</span> list<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引起警告</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ls<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//转换将引起错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型与数组"><a href="#泛型与数组" class="headerlink" title="泛型与数组"></a>泛型与数组</h4><p>数组元素类型不能包含类型变量或形参，除非无上限类型通配符，但可以声明元素类型包含类型变量或形参的数组。比如：只能说明<code>List&lt;String&gt;[]</code>形式的数组，不能创建<code>ArrayList&lt;String&gt;[10]</code>这样的数组。</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//没有问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java工具类</title>
      <link href="/2020/1012/"/>
      <url>/2020/1012/</url>
      
        <content type="html"><![CDATA[<blockquote><p>公众号：菜鸡干Java</p></blockquote><h5 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h5><p><code>Collections</code>提供了如下方法用于对<code>List</code>集合排序：</p><ul><li>void reverse(List list)：反转顺序</li><li>void shuffle(List list)：随机排序</li><li>void sort(List list)：按升序排序</li><li>void sort(List list ,Comparator)：根据<code>Comparator</code>的顺序指定排序</li><li>void swap(List list,int i,int j)：指定元素之间交换</li><li>void rotate(List list,int d)：当d为正时，将集合后d个元素整体移到前面；为负时，将前d个元素整体移到后面</li></ul><h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><p><code>Collections</code>还提供了如下方法用于查找和替换元素：</p><ul><li>int binarySearch(List list,Object o)：二分搜索指定<code>List</code>集合，获得对象的索引，前提是集合是有序的。</li><li>Object max(Collection c)：根据自然排序，返回最大元素</li><li>Object max(Collection c,Comparator comp)：根据指定排序，返回集合中的最大元素</li><li>Object min(Collection c)：根据自然排序，返回最小元素</li><li>Object min(Collection c,Comparator comp)：根据指定排序，返回集合中的最小元素</li><li>void fill(List list,Object o)：使用o替换集合中所有元素   </li><li>int frequency(Collection c,Object o)：返回集合中o出现的次数</li><li>int indexOfSubList(List list,List sublist)：返回子List在集合中第一次出现的位置，若没有则返回-1</li><li>int lastIndexOfSubList(List list,List sublist)：返回子List在集合中最后一次出现的位置，若没有则返回-1</li><li>boolean replaceAll(List list,Object old,Object new)：使用一个新元素替换所有指定旧元素</li></ul><h5 id="同步控制的线程安全"><a href="#同步控制的线程安全" class="headerlink" title="同步控制的线程安全"></a>同步控制的线程安全</h5><p><code>Collections</code>工具类提供了多个<code>synchronizedXxx()</code><strong>类方法</strong>，该方法将指定集合包装成线程同步的集合。在Map集合中，线程不安全的有<code>HashSet</code>,<code>HashMap</code>,<code>TreeMap</code>,<code>TreeSet</code>,<code>ArrayList</code>,<code>ArrayDeque</code>,<code>LinkedList</code>等，现在可以用该方法包装成线程安全的。</p><pre class="line-numbers language-java"><code class="language-java">Collection c <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedCollection</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List a <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set s <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedSet</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Map m <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将创建的对象传入<code>synchronizedXxx()</code>方法，会返回线程安全的<code>List</code>,<code>Map</code>,<code>Set</code>集合对象。</p><h5 id="设置不可变集合"><a href="#设置不可变集合" class="headerlink" title="设置不可变集合"></a>设置不可变集合</h5><p><code>Collections</code>提供以下三个<strong>类方法</strong>来返回一个不可变集合：</p><ul><li>emptyXxx()：返回一个空的，不可变的集合对象，此处集合可以是<code>List</code>，<code>Set</code>,<code>Map</code>。</li><li>singletonXxx()：返回一个包含指定对象的不可变集合对象，可以是<code>List</code>,<code>Map</code>。</li><li>unmodifiableXxx()：返回集合对象的不可变<code>Map</code>,此处集合可以是<code>List</code>,<code>Set</code>,<code>Map</code>。</li></ul><p>方法的参数为原有的集合对象，返回了一个不可变对象(<code>原有对象的不可变版本</code>)。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> 工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合(四)-Map集合</title>
      <link href="/2020/1011/"/>
      <url>/2020/1011/</url>
      
        <content type="html"><![CDATA[<h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><p><code>Map</code>的key不允许重复，即两个key通过<code>equals</code>方法比较总是返回<code>false</code>。如果把所以的<code>key</code>放在一起来看，它们就是一个<code>Set</code>集合，就是没有顺序，<code>key</code>之间不能重复。而实际上Map确实包含了一个<code>KeySet()</code>方法，用于返回Map集合的所有key组成的<code>Set</code>集合。另外key集与Set集合里的元素的储存形式也很像，Map子类和Set子类在名字上也很相似，比如<code>HashMap</code>与<code>HashSet</code>等接口和子类。Map和Set之间的关系非常密切，但如果把key-value中的<code>value</code>当作<code>key</code>的附庸，就可以当Set来看Map。</p><p>事实上，Map提供了一个<code>Entry</code>内部类来封装<code>key-value</code>对，而储存时只考虑<code>key</code>。从源码上看，Java先实现了<code>Map</code>，然后通过包装一个所有<code>value</code>都为<code>null</code>的Map就实现了<code>Set</code>集合。如果把所有<code>value</code>放在一起，它们又类似一个<code>List</code>集合，元素与元素之间通过索引来查找，只是<code>Map</code>不是通过整数索引查找，而是用一个对象作为索引。如果需要取出元素，则需要提供元素的<code>key</code>索引。</p><p><code>Map</code>接口提供了大量的实现类，典型的如：<code>HashMap</code>，<code>Hashtable</code>，<code>LinkedHashMap</code>等，其中包括一个内部类<code>Entry</code>，该类封装了一个<code>key-value</code>对，类中包含了三个方法：</p><ul><li>Object getKey()：返回该<code>Entry</code>里包含的<code>Key</code>值</li><li>Object getValue()：返回该<code>Entry</code>里包含的value值</li><li>Object setValue(V value)：返回该<code>Entry</code>里包含的value值，并返回新设置的<code>Value</code>值</li></ul><p><code>Map</code>集合最典型的用法就是成对添加和删除<code>key-value</code>对，判断该<code>Map</code>中是否包含指定<code>key</code>，添加新的value会覆盖原有的value。<code>HashMap</code>重写了<code>toString()</code>方法，实际上所有的实现类都重写了该方法调用方法后，总是返回：<code>{key1=balue1,key2=value2...}</code>格式。</p><h4 id="Java8改进HashMap和Hashtable实现类"><a href="#Java8改进HashMap和Hashtable实现类" class="headerlink" title="Java8改进HashMap和Hashtable实现类"></a>Java8改进<code>HashMap</code>和<code>Hashtable</code>实现类</h4><p>其实这种尴尬的关系不是第一次见了，它们的关系如同<code>ArrayList</code>和<code>Vector</code>的关系一样。<code>Hashtable</code>是一个古老的<code>Map</code>实现类，从它的名字就可以看出，没有遵循单词首字母大写的命名规范。它从<code>JDK1.0</code>就已经有了，那时还没有<code>Map</code>接口，所以它包含了两个现在很少用的方法，<code>elements()</code>类似value方法，和<code>keys()</code>方法。同时，Java8改进了<code>HashMap</code>的实现，让它在哈希冲突时依然保持良好的性能。</p><p>区别：</p><ul><li><code>Hashtable</code>是一个线程安全的实现，而<code>HashMap</code>不是，然而性能比<code>Hashtable</code>好。</li><li><code>Hashtable</code>不允许<code>null</code>作为<code>key</code>和<code>value</code>，但<code>HashMap</code>可以。</li></ul><p>其实区别了也没太大意义，因为<code>Hashtable</code>这样古老的类现在用的并不多，如果想要获得线程安全的<code>Map</code>类，可以通过<code>Collections</code>工具类把<code>HashMap</code>转化成线程安全的。</p><h5 id="内部元素储存"><a href="#内部元素储存" class="headerlink" title="内部元素储存"></a>内部元素储存</h5><p>为了成功在<code>HashMap</code>和<code>Hashtable</code>中储存获取对象，用作<code>Key</code>的对象必须实现<code>hashCode()</code>方法和<code>equals()</code>方法，道理和<code>HashSet</code>类似。与<code>HashSet</code>集合不能保证元素顺序一样，两个<code>key</code>相等的标准是通过<code>equals</code>方法返回<code>true</code>，<code>hashCode</code>值也相等。而判断两个<code>value</code>相等的标准更松一点，即<code>equals</code>返回true即可，这种标准在<code>containValue()</code>方法中可以体现。</p><p>同样的，当使用自定义类作为<code>HashMap</code>,<code>Hashtable</code>的<code>key</code>时，如果重写该类的<code>equals()</code>方法，<code>hashCode()</code>方法也应该重写，另一方面讲，<code>HashMap</code>与<code>Hashtable</code>对key的要求和<code>HashSet</code>对元素的要求完全相同。同样的问题，如果<code>key</code>是可变对象，则修改了<code>key</code>将导致无法准确访问被修改的<code>key</code>，而无法访问对应的<code>value</code>值。</p><h4 id="LinkedHashMap实现类-HashMap子类"><a href="#LinkedHashMap实现类-HashMap子类" class="headerlink" title="LinkedHashMap实现类(HashMap子类)"></a>LinkedHashMap实现类(HashMap子类)</h4><p><code>HashSet</code>有一个<code>LinkedHashSet</code>子类，<code>HashMap</code>也有一个<code>LinkedHashMap</code>子类。同样，也是采用链表来维护<code>Map</code>的迭代顺序的，并且迭代顺序与插入顺序一致。只需在插入时保持应有的顺序即可，而避免对其排序所带来的成本。由于要维护顺序，所以性能上稍逊<code>HashMap</code>，然而像上次讲的那样，这也是优点，就是迭代起来比较方便。</p><pre class="line-numbers language-java"><code class="language-java">LinkedHashMap weights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>weights<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">)</span><span class="token punctuation">;</span>weights<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"菜鸡一号"</span><span class="token punctuation">,</span><span class="token number">130</span><span class="token punctuation">)</span><span class="token punctuation">;</span>weights<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"->"</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Java8新增forEach()方法遍历Map</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Properties类-Hashtable的子类"><a href="#Properties类-Hashtable的子类" class="headerlink" title="Properties类(Hashtable的子类)"></a>Properties类(<code>Hashtable</code>的子类)</h4><p>顾名思义，该类在处理属性文件时特别方便，Properties类可以把<code>Map</code>对象中的<code>key-value</code>写入属性文件，也可以从属性文件中加载键值对到<code>Map</code>对象中去。由于属性名和属性值只能是字符串，所以其中的<code>key</code>,<code>value</code>都是字符串类型，<code>Properties</code>相当于一个<code>key</code>,<code>value</code>都是<code>String</code>类型的<code>Map</code>。该类提供了如下三个方法来修改<code>Properties</code>里的<code>key</code>,<code>value</code>值，注意是“修改”，后面会介绍几个读写方法。</p><ul><li>String getProperty(String key)：获取<code>Properties</code>中指定属性名对应的属性值，类似<code>get</code>方法。</li><li>String getProperty(String key,String defaultValue)：功能与上一个类似，但可以指定key不存在时的默认值。</li><li>Object setProperty(String key,String value)：设置属性值，类似<code>put</code>方法</li></ul><p>还有两个读写属性方法：</p><ul><li>void load(InputStream in)：从属性文件(输入流表示)中加载<code>key-value</code>对，并把对加到<code>Properties</code>里。</li><li>void store(OutputStream out,String comments)：将<code>ProPerties</code>中的<code>key-value</code>对输出到指定属性文件中去。</li></ul><pre class="line-numbers language-java"><code class="language-java">Properties p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span><span class="token string">"菜鸡二号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"a.ini"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Properties p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"a.ini"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序在当前路径下生成一个<code>a.ini</code>文件，内容如下：</p><pre class="line-numbers language-ini"><code class="language-ini">#user#Thu Oct 9<span class="token constant">password</span><span class="token attr-value"><span class="token punctuation">=</span>123456</span><span class="token constant">username</span><span class="token attr-value"><span class="token punctuation">=</span>菜鸡一号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SortedMap接口与TreeMap实现类"><a href="#SortedMap接口与TreeMap实现类" class="headerlink" title="SortedMap接口与TreeMap实现类"></a><code>SortedMap</code>接口与TreeMap实现类</h4><p>不难发现，该类与<code>TreeSet</code>和<code>SortedMap</code>的关系一样，<code>TreeMap</code>也是一个红黑树结构，即每个<code>key-value</code>对作为一个节点，而在储存它们时需要进行排序。所以它也有两种排序方式：</p><ul><li>自然排序：<code>key</code>必须实现<code>Comparable</code>接口，且为同一类的对象，否则抛出<code>ClassCastException</code>异常。</li><li>定制排序：在创建<code>TreeMap</code>时，传入一个<code>Comparator</code>对象，该对象负责对<code>TreeMap</code>中的所有<code>key</code>进行排序，但是不要钱实现<code>Comparable</code>接口。</li></ul><p>类似<code>TreeSet</code>判断元素相等的标准一样，两个<code>key</code>通过<code>compareTo()</code>方法返回0，即为相等。如果<code>equals()</code>与<code>compareTo()</code>方法返回结果不一致，<code>TreeMap</code>与Map接口就会冲突。同样，它也有相类似的方法访问<code>key-value</code>对。由于<code>TreeMap</code>本身是有序的，所以它增加了访问第一个、最后一个、前一个和后一个的<code>key-value</code>对方法，并提供了截取几个子<code>TreeMap</code>方法。</p><h4 id="WeakHashMap实现类"><a href="#WeakHashMap实现类" class="headerlink" title="WeakHashMap实现类"></a>WeakHashMap实现类</h4><p><strong>用法</strong>和<code>HashMap</code>类似，区别在于<code>HashMap</code>的<code>key</code>保留了对实际对象的强引用，这表示只要<code>HashMap</code>对象不被销毁，所有<code>key</code>所引用的对象就不会被垃圾回收。但<code>WeakHashMap</code>对象的<code>key</code>所引用的对象没有被其他强引用变量所引用，则引用的对象有可能被垃圾回收，而且<code>WeakHashMap</code>也可能自动删除这些<code>key</code>所对应的<code>key-value</code>。</p><p>每个<code>key</code>只持有对实际对象的弱引用，因此，在垃圾回收该key所引用的实际对象后，集合也会自动删除该键值对。</p><pre class="line-numbers language-java"><code class="language-java">WeakHashMap w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"语文"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"及格"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"数学"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"优秀"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"优秀"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{语文=及格,java=优秀,数学=优秀}</span>Syste<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span><span class="token function">runFinalization</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">{</span>java<span class="token operator">=</span>中等<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面看出，系统进行垃圾回收时，删除了原先的两个键值对，这是由于这两个key都是匿名字符串对象，<code>WeakHashMap</code>只保留了它们的弱引用，所以垃圾回收时将自动删除这两个键值对。如果想使用key来保留对象的弱引用，则不要让key所引用的对象有任何强引用！</p><h4 id="IdentityHashMap实现类"><a href="#IdentityHashMap实现类" class="headerlink" title="IdentityHashMap实现类"></a>IdentityHashMap实现类</h4><p><strong>实现机制</strong>和<code>HashMap</code>类似，但在处理两个<code>key</code>相等时比较独特。在<code>IdentityHashMap</code>中，当且仅当两个<code>key</code>严格相等时，即<code>key1 == key2</code>，<code>IdentityHashMap</code>才认为两个key相等。而对于普通<code>HashMap</code>而言，只需要通过<code>equals</code>方法比较，且它们的<code>hashCode</code>值相等即可。</p><p>在提供的方法上，<code>IdentityHashMap</code>提供了与<code>HashMap</code>相类似的方法，也允许使用<code>null</code>作为<code>key</code>和<code>value</code>！同样，它也不能保证键值对之间的顺序，更不能保证它们的顺序以后不会变。</p><pre class="line-numbers language-java"><code class="language-java">IdentityHashMap i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdentityHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"菜鸡"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"菜鸡"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字符串直接量</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>java<span class="token operator">=</span><span class="token number">101</span><span class="token punctuation">,</span>菜鸡<span class="token operator">=</span><span class="token number">90</span><span class="token punctuation">,</span>菜鸡<span class="token operator">=</span><span class="token number">88</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于前两个是字符串对象，所以==比较后返回false，后两个是字符串直接量，Java用常量池管理字符串直接量，则将会返回true，最后一次添加为最终结果。这种问题在之前就讲过，为啥直接量包装成对象==比较会返回true，应该是在包装类那里提到过。</p><h4 id="EnumMap实现类"><a href="#EnumMap实现类" class="headerlink" title="EnumMap实现类"></a>EnumMap实现类</h4><p>这是一个和枚举类一起实现的<code>Map</code>，其中所有的<code>key</code>都必须是单个枚举类的枚举值。在创建<code>EnumMap</code>时，必须隐式或显示的指定它的对应的枚举类。特点有：</p><ul><li>在内部以数组的形式保存元素，十分高效</li><li>有顺序，根据<code>key</code>的自然排序维护键值对。可以通过<code>keySet()</code>,<code>entrySet()</code>,<code>values()</code>方法遍历集合看到！</li><li>不允许将<code>null</code>作为<code>key</code>，但允许作为<code>value</code>。如果只是查询或删除不会抛出异常！</li></ul><p>需要注意的是，在创建<code>EnumMap</code>时，<strong>必须</strong>指定一个枚举值，从而将该<code>EnumMap</code>和指定枚举类关联起来。如果不理解可以参考一下<code>EnumSet</code>集合，类似的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">enum</span> Names<span class="token punctuation">{</span>Jason<span class="token punctuation">,</span>Toray<span class="token punctuation">,</span>Massa<span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        EnumMap e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnumMap</span><span class="token punctuation">(</span>Names<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Names<span class="token punctuation">.</span>Jason<span class="token punctuation">,</span><span class="token string">"就欧森"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Names<span class="token punctuation">.</span>Toray<span class="token punctuation">,</span><span class="token string">"陀螺仪"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出为：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>Jason<span class="token operator">=</span>就欧森<span class="token punctuation">,</span>Toray<span class="token operator">=</span>陀螺仪<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="各Map实现类性能分析"><a href="#各Map实现类性能分析" class="headerlink" title="各Map实现类性能分析"></a>各Map实现类性能分析</h4><p>在讲解Map集合类的过程中，经常性的提到对象之间的比较，<code>value</code>之间的比较及它们的标准；如果是有排序功能的集合，则还会提到实现<code>Comparable</code>接口，或者传入<code>Comparator</code>对象进行排序；而且还会提到是否能保存<code>null</code>值，或能不能把它作为<code>key</code>，<code>value</code>等。</p><p>提到性能，最主要还是集中在<code>HashMap</code>,<code>Hashtable</code>,<code>TreeSet</code>,<code>TreeMap</code>,<code>LinkedHashSet</code>,<code>LinkedHashMap</code>等Map集合类的分析·。然而在分析的时候并不是太难纠结，由于要维护了啥，所以性能略低；由于实现了啥，所以性能有所下降等。在使用<code>TreeMap</code>时有一个好处，key-value总是处于有序状态，无需专门排序，在被添入键值对后，就可以使用<code>KeySet()</code>方法取得<code>key</code>所组成的Set，然后就可以直接使用<code>toArray()</code>方法生成key的数组，接下来使用<code>binarySearch()</code>方法可以在以排序的数组中二分查找对象。EnumMap性能最好，但它只能使用同一个枚举类的枚举值作为key。</p><h4 id="哈希表的存储"><a href="#哈希表的存储" class="headerlink" title="哈希表的存储"></a>哈希表的存储</h4><p>哈希表里可以储存元素的位置称为桶<code>bucket</code>，通常一个桶存放一个元素，此时有最好的性能。哈希算法根据哈希值计算出桶的位置，继而从中取出元素。但发生哈希冲突的时候，一个桶会储存多个元素，这些元素会以链表的形式储存，查找时按顺序搜索，由于<code>HashMap</code>,<code>Hashtable</code>,<code>HashSet</code>都使用哈希算法来决定元素的存储，所以其哈希表包含如下属性：</p><ul><li>容量<code>capacity</code>：哈希表中桶的数量</li><li>初始化容量<code>initial capacity</code>：创建哈希表时桶的数量。<code>HashMap</code>和<code>HashSet</code>都允许在构造器中指定初始化容量。</li><li>尺寸<code>size</code>：当前哈希表的元素数量</li><li>负载因子<code>load factor</code>：其等于<code>size/capacity</code>大小，若为0则表示空，0.5表示半满哈希表。</li></ul><p>另外哈希表还有一个<code>负载极限</code>，它是一个0~1的数，决定了哈希表的最大填满程度。当负载因子到达负载极限时，哈希表会自动成倍增加容量，也就是桶的数量，将原有对象重新分配放入桶内(rehashing)。<code>HashSet</code>,<code>HashMap</code>,<code>Hashtable</code>允许在构造器指定一个负载极限，默认为<code>0.75</code>,这表明<code>负载因子</code>当达到0.75的时候，哈希表会重新分配。</p><p>那为啥是<code>0.75</code>呢？其实都是一种取舍后的办法，要时间还是要空间？哈希表是用来查询的，较高的<code>负载极限</code>可以降低内存开销，然而却增加查询数据时间开销；较低的<code>负载极限</code>可以降低时间开销，却增加的内存的开销。如果已经知道要保存大量数据，创建时指定较大的初始化容量就行了，从而可以避免<code>rehashing</code>。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> Map集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合(三)-List和Queue集合</title>
      <link href="/2020/1009/"/>
      <url>/2020/1009/</url>
      
        <content type="html"><![CDATA[<blockquote><p>公众号： 菜鸡干Java  欢迎关注</p></blockquote><h3 id="Java集合—List集合"><a href="#Java集合—List集合" class="headerlink" title="Java集合—List集合"></a>Java集合—List集合</h3><p>与Set集合不同，List集合是有序，可重复的，而且默认以添加顺序设置索引。<code>List</code>子接口是继承了<code>Collection</code>接口，则可以使用其中的方法。</p><p>特别的是<code>List</code>增加了根据索引插入、替换、删除集合元素的方法，此外，Java8为<code>List</code>接口添加了两个默认方法：</p><ul><li>void replaceAll()：根据指定规则重新设置List集合的所有元素</li><li>void sort(Comparator c)：根据参数对List集合的元素排序</li></ul><pre class="line-numbers language-java"><code class="language-java">List books <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>books<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ledon"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>books<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Android"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>books<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>o1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>o2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字符串将由短到长排序</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span><span class="token punctuation">;</span>books<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>e<span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//[5,7]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>值得注意的是</strong>：<code>List</code>判断两个对象相等，只要通过<code>equals</code>方法比较返回true即可，不像<code>Set</code>集合，还需要判断哈希值是否相等来避免重复。</p><p>删除元素时，<code>List</code>会调用对象的<code>equals</code>方法依次与集合元素比较，如果返回true，则会删除该元素。如果重写了<code>equals</code>方法，使它总是返回true，则List总会删除第一个元素。在使用<code>set(index,object)</code>方法时，index不能超过集合的长度，也不能改变长度。</p><p>List不仅有<code>iterator()</code>方法，还有<code>listIterator()</code>方法，该方法返回一个<code>ListIterator</code>对象，<code>ListIterator</code>接口继承了<code>Iterator</code>接口，提供了专门的方法操作<code>List</code>，增加了如下方法(类似Iterator的方法)：</p><ul><li>boolean hasPrevious()：返回该集合是否还有上一个元素</li><li>Object previous()：返回上一个元素</li><li>void add(Object o)：在指定位置插入一个元素</li></ul><p>不难发现该接口还能向前迭代，不止能删除元素，并且还能通过<code>add()</code>方法，添加元素。</p><h4 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h4><p>它们两个封装了 一个动态的Object[ ]数组，允许再分配。<code>ArrayList</code>及<code>Vector</code>对象使用<code>initialCapacity</code>参数来设置数组的长度，当超出数组容量时，<code>initialCapacity</code>会自动增加，可使用<code>ensureCapacity(int minCapacity)</code>方法一次性增加<code>initialCapacity</code>。如果事先知道元素的个数，可指定初始大小；如果没有指定初始容量，默认为10。</p><p><code>ArrayList</code>和<code>Vector</code>提供了两个方法重新分配<code>Object[]</code>数组：</p><ul><li>void ensureCapacity(int minCapacity)：将<code>ArrayList</code>和<code>Vector</code>集合的<code>Object[]</code>数组长度增加到大于或等于minCapacity值</li><li>void trimToSize()：调整<code>ArrayList</code>及<code>Vector</code>的数组长度为当前元素个数，减少占用空间</li></ul><p><code>ArrayList</code>和<code>Vector</code>的用法几乎完全相同，<code>Vector</code>也是实现了<code>List</code>接口，从<code>JDK1.0</code>就有了，很古老！此外，<code>ArrayList</code>是线程不安全的，原理一样；但<code>Vector</code>是线程安全的，即无需保证线程的同步性，因而<code>Vector</code>的性能比<code>ArrayList</code>低。但是还是用<code>ArrayList</code>更多，要想线程安全，也可以把<code>ArrayList</code>变成线程安全。</p><h4 id="Stack类-Vector的子类"><a href="#Stack类-Vector的子类" class="headerlink" title="Stack类(Vector的子类)"></a>Stack类(Vector的子类)</h4><p>翻译过来就是“栈”，模拟进栈<code>push</code>，出栈<code>pop</code>等操作。作为集合的一种，它也是储存对象(Object)的，有如下方法：</p><ul><li>Object peek()：返回栈顶元素，但并不弹出该元素，元素还会在栈内</li><li>Object pop()：返回栈顶元素，并弹出栈</li><li>void push(Object item)：推元素进栈</li></ul><p><code>Stack</code>继承了<code>Vector</code>，所以它也非常古老，线程安全、性能较差。后面还会介绍一种“栈”结构——ArrayDeque，它不仅实现了<code>List</code>接口，还实现了<code>Deque</code>接口，如果需要栈结构，可以使用它而不是<code>Stack</code>。</p><h4 id="固定长度的List"><a href="#固定长度的List" class="headerlink" title="固定长度的List"></a>固定长度的List</h4><p>有一种操作数组的工具类<code>Arrays</code>，该工具类提供了<code>asList()</code>方法，该方法把一个数组或指定个数的对象换成一个<code>List</code>集合，这个集合不是以上所介绍的集合类的实例，不是<code>ArrayList</code>的，不是<code>Vector</code>的，而是<code>Arrays</code>的内部类<code>ArrayList</code>的实例。<code>Arrays.ArrayList</code>是一个固定长度的<code>List</code>集合，不允许添加、删除操作，只能遍历访问，否则程序将出现<code>UnsupportedOperationException</code>异常。</p><h3 id="Java集合-Queue集合"><a href="#Java集合-Queue集合" class="headerlink" title="Java集合-Queue集合"></a>Java集合-Queue集合</h3><p>在<code>Queue</code>接口中定义了如下的方法：</p><ul><li>void add(Object e)：添加元素到队尾</li><li>boolean offer(Object e)：将指定元素加入队列的尾部，成功返回true</li><li>Object element()：获取队列头部的元素，但不是删除该元素</li><li>Object remove()：获取头部元素，并删除该元素</li><li>Object peek()：获取队列头部的元素，但不是删除，如果为空返回null</li><li>Object poll()：获取并删除头部元素，为空，返回null</li></ul><p>Queue有一个<code>PriorityQueue</code>实现类，除此外还有一个<code>Deque</code>接口，代表双端队列，即两端可以添加删除元素。其实现类为<code>ArrayDeque</code>和<code>LinkedList</code>两个实现类。</p><h4 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue类</h4><p>PriorityQueue并不是一个标准的队列，其保存队列的顺序是重新排序了的(按元素的大小)，显然不符合队列的规则。如果调用<code>poll</code>方法，可以看到元素从小到大移出队列。另外需要注意的是，<code>PriorityQueue</code>不允许插入null元素！</p><p>它的排序有两种，自然排序、定制排序，排序规则与<code>TreeSet</code>类似：</p><ul><li>自然排序：自然排序时，元素必须实现了<code>Comparable</code>接口，而且是同一类的实例。</li><li>定制排序：创建队列时，传入一个<code>Comparator</code>对象，该对象负责排序，但是不要求元素实现<code>Comparable</code>接口</li></ul><h4 id="Deque接口与ArrayDeque"><a href="#Deque接口与ArrayDeque" class="headerlink" title="Deque接口与ArrayDeque"></a>Deque接口与ArrayDeque</h4><p><code>Deque</code>接口是<code>Queue</code>的子接口，允许对队列两端进行操作，同时，还可以当作“栈”来使用，因为它还有<code>pop</code>、<code>push</code>方法。典型的实现类是<code>ArrayDeque</code>，一个基于数组的双端队列，在创建<code>Deque</code>时，同样可以指定一个<code>numElement</code>元素个数参数，指定Object[ ]数组的长度；如果不指定，则默认长度为16。</p><p><code>ArrayList</code>与<code>ArrayDeque</code>的实现原理差不多，底层采用一个动态的、可再分配的数组实现，初始化可指定初始长度等，当元素个数超出容量时，系统会重新分配一个<code>Object[]</code>数组储存元素。</p><h4 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h4><p><code>LinkedList</code>实现了<code>List</code>接口，是<code>List</code>集合，还实现了<code>Deque</code>接口，可以当双端队列使用，还能当”栈”使用。 但它的实现机制与<code>ArrayList</code>、<code>ArrayDeque</code>的不一样，它两是用数组实现，而<code>LinkedList</code>是以链表的形式来保存元素，随机访问性能较差，但插入、删除操作比较溜！</p><h3 id="线性表性能分析"><a href="#线性表性能分析" class="headerlink" title="线性表性能分析"></a>线性表性能分析</h3><p>一般来说，数组由一块连续的内存来保存数据，所以数组随机访问性能好，类似的，以数组为底层实现的类，随机访问性能都比较好；而链表的插入、删除操作性能好。综合来讲，还是用<code>ArrayList</code>比较妥。</p><ul><li><p>如果需要遍历：对于<code>ArrayList</code>，<code>Vector</code>集合，使用随机访问方法遍历即可；对于<code>LinkedList</code>集合，采用<code>Iterator</code>迭代器遍历比较好。</p></li><li><p>如果经常要执行插入、删除操作，可以使用<code>LinkedList</code>集合，而使用以数组为底层的线性表要重新分配内部数组大小，性能较差。</p></li><li><p>如果有多个线程同时访问，可以使用工具类包装成线程安全的集合。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合(二)-Set集合</title>
      <link href="/2020/1003/"/>
      <url>/2020/1003/</url>
      
        <content type="html"><![CDATA[<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>Set集合和Collection基本相同，没有提供额外的方法，主要是行为上的不同，Set不允许包含重复元素，否则<code>add()</code>方法会返回<code>false</code>。接下来将主要介绍四种<code>Set</code>类，<code>HashSet</code>，<code>TreeSet</code>，<code>LinkedHashSet</code>，<code>EnumSet</code>四种。</p><h4 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h4><p>HashSet使用<code>hash算法</code>来储存集合中的元素，具有很好的查找和存取性能，它的特点如下：</p><ol><li>不能保证元素的顺序，可能变化</li><li><code>HashSet</code>不是同步的，如果多个线程同时访问并修改一个<code>HashSet</code>，则必须保证其同步。</li><li>集合的元素可以是<code>null</code></li></ol><p>当向<code>HashSet</code>集合中存入一个元素时，<code>HashSet</code>会调用对象的<code>hashCode()</code>方法来得到该对象的<code>hashCode</code>值，然后根据该<code>hashCode</code>值决定该对象在<code>HashSet</code>中的位置。但是如果两个元素通过<code>equals()</code>方法返回<code>true</code>，而它们的<code>hahCode()</code>方法返回值不相等，<code>HashSet</code>将会把他们储存在不同的位置，依然可以添加成功。也就是说，HashSet集合判断元素相等的标准是通过<code>equals</code>方法比较相等，并且两个对象的<code>hashCode</code>值一样。</p><pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Class <span class="token class-name">B</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Class <span class="token class-name">C</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> Class <span class="token class-name">HashSet</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        HashSet books <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        books<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        books<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        books<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        books<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        books<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        books<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//添加两A,B,C对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>B<span class="token annotation punctuation">@1</span> <span class="token punctuation">,</span>B<span class="token annotation punctuation">@1</span> <span class="token punctuation">,</span>C<span class="token annotation punctuation">@2</span> <span class="token punctuation">,</span>A<span class="token annotation punctuation">@54d</span> <span class="token punctuation">,</span>A<span class="token annotation punctuation">@8773f2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从上面看出，即使A对象equals方法返回true，依然被当作两个对象；即使两个B对象<code>hashCode</code>方法返回值一样，但HashSet集合储存了两个hash值一样的对象。如果equals返回true，但是会放在不同的地方，不太好。如果hash值一样，但equals返回的false也麻烦了，集合会尝试保存把对象保存在同一个位置，并采用链式结构来保存多个对象，这样会导致利用哈希值查找的时候，性能下降。</p><p>所以总结一句：如果需要把对象保存到HashSet集合中去，重写类的<code>equals</code>和<code>hashCode</code>方法，保证equals返回true时，hashCode返回值一样。</p><p>HashSet中每个能储存元素的位置通常称为桶(bucket)，如果有多个元素的哈希值相同，但它们通过equals方法返回<code>false</code>，就需要在一个桶内放多个元素，然而这样会导致性能下降。</p><h5 id="重写hashCode方法步骤"><a href="#重写hashCode方法步骤" class="headerlink" title="重写hashCode方法步骤"></a>重写hashCode方法步骤</h5><ol><li>把对象内的每个参与<code>equals</code>方法比较的实例变量计算处一个<code>int</code>类型的哈希值</li></ol><table><thead><tr><th>实例变量类型</th><th>计算方式</th><th>实例变量类型</th><th>计算方式</th></tr></thead><tbody><tr><td>boolean</td><td>hashCode = (f ? 0 : 1)</td><td>float</td><td>hashCode = Float.floatToIntBits(f)</td></tr><tr><td>整型byte、char、short、int</td><td>hashCode = (int)f</td><td>double</td><td>long L = Double.doubleToLongBits(f);<br/>hashCode  = (int)(L^(L&gt;&gt;&gt;32));</td></tr><tr><td>Long</td><td>hashCode = (int)(f^(f&gt;&gt;&gt;32));</td><td>引用</td><td>hashCode = f.hashCode();</td></tr></tbody></table><p>  2.用第一步计算出的多个哈希值组合计算出一个哈希值返回，例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">return</span> f1<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>f2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//f1,f2为实例变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为避免直接相加产生的偶然，可以为各实例变量的哈希值乘以任意质数后再相加。但还有一点需要了解的是，这样并不能完全保证之后就不会产生两个相同的对象，向HashSet中添加可变对象后，后面修改了可变对象的实例变量，可能导致它和集合中其他元素相同，甚至不能正确访问(储存在不同位置，hash值不一样)。</p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>HashSet还有一个子类<code>LinkedHashSet</code>，同样也是根据元素的<code>hashCode</code>值来决定元素的储存位置，不同的是它使用链表维护元素的次序，这样可以以插入顺序保存元素。<code>LinkedHashSet</code>需要链表维护次序，所以性能略低于<code>HashSet</code>，但优势在于遍历集合内元素上。另外注意一点，它还是<code>Set</code>，所以依然不允许元素重复！</p><pre class="line-numbers language-java"><code class="language-java">LinkedHashSet names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"James"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Jodan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//James,Jodan</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="TreeSet-SortedSet的实现类"><a href="#TreeSet-SortedSet的实现类" class="headerlink" title="TreeSet(SortedSet的实现类)"></a>TreeSet(SortedSet的实现类)</h4><p>既然是实现类，那<code>SortedSet</code>就是<code>TreeSet</code>的接口了，顾名思义，<code>TreeSet</code>可以让元素处于一定次序状态。与<code>HashSet</code>相比，TreeSet额外提供了如下方法：</p><ul><li>Comparator comparator()：如果TreeSet采用定制排序，则返回定制排序所使用的Comparator，如果采用自然排序，则返回<code>null</code></li><li>Object first()：返回第一个元素</li><li>Object last()：返回最后一个元素</li><li>Object lower(Object e)：返回处于指定元素(任意元素，不需要在集合中)之前的元素</li><li>Object higner(Object e)：返回处于指定元素之后(更大的元素)的元素</li><li>SortedSet subSet(Object e1,Object e2)：返回从e1到e2的子集合(不包含e1,e2)</li><li>SortedSet headSet(Object max)：返回子集合，元素都小于max</li><li>SortedSet tailSet(Object min)：返回子集合，元素大于等于min</li></ul><p>综上，大概就是提供了访问第一个、最后一个、前一个、后一个元素的方法，并提供了三个截取子集合的方法。与此同时，<code>TreeSet</code>采用红黑树的数据结构来储存数据，默认情况下使用<code>自然排序</code>。它的排序规则有以下两种：</p><h5 id="1-自然排序"><a href="#1-自然排序" class="headerlink" title="1.自然排序"></a>1.自然排序</h5><p>TreeSet调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种就是自然排序。Java提供了<code>Comparable</code>接口，该接口内定义了一个<code>compareTo(Object o)</code>方法，方法返回一个整数。实现接口就必须实现该方法。当一个对象之间进行比较时，例如：obj1.compareTo(obj2)，如果返回0，则表明这两个对象相等；如果返回一个正整数，则obj1大于obj2；如果返回一个负整数，则obj1小于obj2。</p><p>下面提供了实现<code>Comparable</code>接口的类，并提供了比较大小的标准。</p><ul><li>BigDecimal、BigInteger以及所有数值类型对应的包装类：按数值大小比较</li><li>Character：按字符的<code>Unicode</code>进行比较</li><li>Boolean：true对应的包装类实例大于<code>false</code>对应的包装类实例</li><li>String：按字符串中字符的<code>Unicode</code>值比较</li><li>Date、Time：后面的时间、日期比前面的日期大</li></ul><p>所以TreeSet会自动地给集合中地大小进行排序，但前提是对象实现了<code>Comparable</code>接口，否则将不可行。还有一点需要说明，大部分类在实现compareTo(Object o)方法时，都需要将被比较对象强制类型转换成相同类型，否则无法比较。然而当添加一个对象到集合中去时，集合会调用对象<code>compareTo()</code>方法与集合中的其他元素进行比较，比较要是同一类的对象。</p><p>如果向TreeSet添加对象是自定义对象，则可以向TreeSet中添加多种类型对象，但这并不表明这是最好的选择，也不推荐这样干，当取出对象时，元素之间会报<code>ClassCastException</code>异常。</p><p>当把一个对象加入集合中时，集合调用对象的<code>compareTo</code>方法与容器的其他对象比较，然后根据红黑树结构找到它的储存位置。如果两个对象通过<code>compareTo(Object obj)</code>方法比较相等，新对象将无法添加到集合中。总之，如果要不报错，TreeSet中只能添加同一种类型的对象。</p><p>对于TreeSet集合而言，判断两个对象相等的唯一标准是：两个对象通过<code>compareTo(Object obj)</code>方法比较相等，返回0，则相等。所以它的添加元素的规则和<code>HashSet</code>一样，假如通过<code>equals</code>方法比较相等，则它们记为同一对象，因此通过<code>compareTo()</code>方法返回0，只能存放一个对象，集合不会让第二个元素进去。同样，如果添加了可变对象，并且还修改了对象的<code>实例变量</code>，将导致集合中对象的顺序变化，然而<code>TreeSet</code>不会调整顺序(甚至会导致删除对象失败，TreeSet性能降低)。</p><h5 id="2-定制排序"><a href="#2-定制排序" class="headerlink" title="2.定制排序"></a>2.定制排序</h5><p>实现定制排序则可以通过<code>Comparator</code>接口，该接口内包含一个<code>int compare(T o1,T o2)</code>方法，用于比较o1、o2的大小，如果返回正整数，则o1&gt;o2；若返回0，则o1=o2；若返回负整数，则o1&lt;o2。但依然不可以添加不同类型的对象。</p><p>在实现定制排序之前，需要提供一个<code>Comparator</code>对象与<code>TreeSet</code>集合关联，由该对象对集合元素进行排序。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">M</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"M(age:"</span> <span class="token operator">+</span> age <span class="token operator">+</span><span class="token string">" )"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//Lambda表达式</span>        TreeSet t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//o1,02这里没有具体类型</span>            M m1 <span class="token operator">=</span> <span class="token punctuation">(</span>M<span class="token punctuation">)</span>o1<span class="token punctuation">;</span>            M m2 <span class="token operator">=</span> <span class="token punctuation">(</span>M<span class="token punctuation">)</span>o2<span class="token punctuation">;</span>            <span class="token keyword">return</span> m1<span class="token punctuation">.</span>age<span class="token operator">></span>m2<span class="token punctuation">.</span>age <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>m1<span class="token punctuation">.</span>age<span class="token operator">&lt;</span>m2<span class="token punctuation">.</span>age <span class="token operator">?</span> <span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Lambda表达式实现了Comparator类型的对象</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出[M(age:9),M(age:5),M(age:-3)]降序排列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="EnumSet类"><a href="#EnumSet类" class="headerlink" title="EnumSet类"></a>EnumSet类</h4><p>专门为枚举类设计的集合类，<code>EnumSet</code>中所有元素必须是指定枚举类型的枚举值。值得一提的是<code>EnumSet</code>集合也是有序的，但它以枚举值在类中的定义顺序来决定集合元素的顺序。<code>EnumSet</code>在内部以位向量的形式储存元素，因此占用内存非常小，运行效率很好，特别是在批量操作时。</p><p><code>EnumSet</code>不允许加入<code>null</code>元素，如果试图插入将会抛出<code>NullPointerException</code>异常。而如果只是判断集合中是否有<code>null</code>元素或删除它，将不会抛出异常，删除的话会返回<code>false</code>，因为没有<code>null</code>元素。</p><p><code>EnumSet</code>集合没有给出任何构造器来创建对象，但还是提供了一些方法去创建的对象的。如下：</p><ul><li>EnumSet allOf(Class elementType)：创建一个包含指定枚举类所有枚举值的集合</li><li>EnumSet complementOf(EnumSet s)：创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新集合包含原集合不包含的、此枚举类剩下的枚举值</li><li>EnumSet copyOf(Collection c)：使用一个普通集合来创建<code>EnumSet</code>类</li><li>EnumSet copyOf(EnumSet e)：创建一个与指定<code>EnumSet</code>具有相同类型、相同元素的EnumSet集合</li><li>EnumSet noneOf(Class elementType)：创建一个元素类型为指定枚举类型的空EnumSet</li><li>EnumSet range(E from ,E to)：创建一个包含从from枚举值到to枚举值范围内枚举值的EnumSet集合</li><li>EnumSet of(E first…E rest )：创建一个包含一个或多个枚举值的EnumSet集合(传入的枚举值必须属于同一个枚举类)</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">enum</span> Colors<span class="token punctuation">{</span>WHITE<span class="token punctuation">,</span>YELLOW<span class="token punctuation">,</span>RED<span class="token punctuation">,</span>GREEN<span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        EnumSet e1 <span class="token operator">=</span> EnumSet<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>Colors<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        EnumSet e2 <span class="token operator">=</span> EnumSet<span class="token punctuation">.</span><span class="token function">noneOf</span><span class="token punctuation">(</span>Colors<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里为[]</span>        e2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Colors<span class="token punctuation">.</span>WHITE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里为[WHITE]</span>        EnumSet e3 <span class="token operator">=</span> EnumSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>Colors<span class="token punctuation">.</span>RED<span class="token punctuation">,</span>Colors<span class="token punctuation">.</span>GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出[RED,GREEN]</span>        EnumSet e4 <span class="token operator">=</span> EnumSet<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>Colors<span class="token punctuation">.</span>YELLOW<span class="token punctuation">,</span>Colors<span class="token punctuation">.</span>GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//[YELLOW,RED,GREEN]</span>        EnumSet e5 <span class="token operator">=</span> EnumSet<span class="token punctuation">.</span><span class="token function">complementOf</span><span class="token punctuation">(</span>e4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这里为[WHITE]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外还可以复制另一个<code>EnumSet</code>集合中的元素来创建新集合，或者复制一个<code>Collection</code>集合元素来创建新的EnumSet集合。当复制<code>Collection</code>集合元素创建时，要求元素都来自<strong>同一个枚举类</strong>，否则抛出<code>ClassCastException</code>异常。</p><pre class="line-numbers language-java"><code class="language-java">Collection c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Colors<span class="token punctuation">.</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Colors<span class="token punctuation">.</span>YELLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>EnumSet e <span class="token operator">=</span> EnumSet<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//[RED,YELLOW]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="各Set实现类的性能分析"><a href="#各Set实现类的性能分析" class="headerlink" title="各Set实现类的性能分析"></a>各Set实现类的性能分析</h4><p><code>HashSet</code>总是比<code>TreeSet</code>的性能好，主要体现在添加、查询元素上，因为<code>TreeSet</code>采用了红黑树来维护集合的次序。而<code>HashSet</code>的子类<code>LinkedHashSet</code>对插入、查询操作比父类要稍慢些，这是由于采用了链表维护的缘故，造成了额外开销。但这并不影响<code>LinkedHashSet</code>发挥威力，然而这恰恰是它的优势，在遍历等批量操作上，<code>LinkedHashSet</code>更快。</p><p><code>EnumSet</code>是所有Set类中性能最好的，缺点是只能保存一个枚举类的枚举值。总的说，Set的这三个实现类都是线程不安全的，即当有多个线程访问时，如果修改了Set集合，将不能同步，必须手动保证同步。方法是在创建Set集合时，通过<code>Collections</code>工具类的<code>sychronizedXxx()</code>方法来包装该集合(之后会提到)。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Set集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类-开篇</title>
      <link href="/2020/0929/"/>
      <url>/2020/0929/</url>
      
        <content type="html"><![CDATA[<blockquote><p>公众号：菜鸡干Java 站点：<a href="https://www.maliaoblog.cn" target="_blank" rel="noopener">https://www.maliaoblog.cn</a></p></blockquote><h4 id="集合介绍"><a href="#集合介绍" class="headerlink" title="集合介绍"></a>集合介绍</h4><p>Java集合类是一种特别的工具类，可以储存对象，并实现了常用的数据结构，另外还能保存具有映射关系的关联数组。集合大致分为<code>Set</code>,<code>List</code>,<code>Queue</code>,<code>Map</code>四种，其中<code>Set</code>代表无序、不可重复，<code>List</code>代表有序、重复，<code>Map</code>则代表具有映射关系，Java5增加了<code>Queue</code>集合，代表一种队列集合实现。Java集合就像一种容器，把多个对象放到容器中。Java5之前，J集合会丢失对象的数据类型，把所有对象都当成<code>Object</code>类型，从Java5开始增加了泛型，集合可以记住容器中对象的数据类型，从而能编写更简洁的代码。</p><p>所有的集合类都位于<code>java.util</code>包下，后来在<code>java.util.concurrent</code>包下提供了多线程集合类。集合类和数组不太一样，数组元素可以是基本数据类型，也可以是对象；而集合只能保存对象(实际保存的是对象的引用变量)。集合类主要由两个接口来实现，<code>Collection</code>和<code>Map</code>，两个<strong>根接口</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0d67f82f0773ddcd5ba284fe0108e62a.png" alt=""></p><p>上图有<code>Map</code>接口的众多实现类，这些类在功能、用法上存在一定的差异，但它们都有一个功能特征，保存的每项数据是<code>Key-value</code>键值对。<code>Map</code>的<code>Key</code>是不可重复的，<code>key</code>用于标识集合集合里的每项数据，如果要查数据，根据<code>Key</code>来获取。添加一个对象到集合中，<code>Set</code>集合无法记住这个元素的顺序，系统无法识别，所以<code>Set</code>里的元素不能重复。</p><p>对于这四种集合，其中常用的有：HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap和TreeMap等实现类。</p><h4 id="Collection和Iterator接口"><a href="#Collection和Iterator接口" class="headerlink" title="Collection和Iterator接口"></a>Collection和Iterator接口</h4><p>Collection接口是<code>List</code>,<code>Set</code>,<code>Queue</code>接口的父接口，如果接口没弄明白，可以看看之前的文章<a href="https://blog.csdn.net/gobullin/article/details/108434921" target="_blank" rel="noopener">Java的异常、多态要点及抽象类和接口</a>。Collection接口定义了如下方法：</p><table><thead><tr><th>boolean add(Object o)</th><th>向集合里添加一个元素，如果添加成功则返回true</th></tr></thead><tbody><tr><td>boolean addAll(Collection c)</td><td>把集合内元素添加到指定集合，成功返回true</td></tr><tr><td>void clear()</td><td>清除集合内所有元素，将集合长度变为0</td></tr><tr><td>boolean contains(Object o)</td><td>返回集合是否包含指定元素</td></tr><tr><td>boolean containsAll(Collection c)</td><td>返回集合是否包含集合c所有元素</td></tr><tr><td>boolean isEmpty()</td><td>返回集合是否为空，长度为0返回true</td></tr><tr><td>Iterator <strong>iterator()</strong></td><td>返回一个Iterator对象用于遍历</td></tr><tr><td>boolean remove(Object o)</td><td>删除指定元素o，如果有多个删除第一个</td></tr><tr><td>boolean retainAll(Collection c)</td><td>从集合中删除集合c里不包含的元素，相当于求和集合c的交集</td></tr><tr><td>int size()</td><td>返回集合里元素个数</td></tr><tr><td>Object[] toArray()</td><td>将一个集合转换成数组</td></tr><tr><td>boolean remove(Collection c)</td><td>从集合中删除集合c里包含的元素</td></tr></tbody></table><p>具体可阅读API文档，里面有详细信息。编译时可能会输出一些警告，提醒没有使用泛型来限制集合内元素类型，不过之后会提到泛型编程。当使用<code>System.out</code>的<code>println</code>方法来输出集合对象时，将输出<code>[e1,e2...]</code>形式，这是因为所有<code>Collextion</code>实现类重写了<code>toString</code>方法，该方法可一次性输出集合中所有元素。如果想依次访问集合中的每一个元素，则需要使用某种遍历方法。</p><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><p>一、<strong>Lambda表达式遍历</strong></p><p>Java8为<code>Iterable</code>接口新增了一个<code>forEach</code>方法，参数类型是一个函数式接口，而<code>Iterable</code>接口是<code>Collection</code>接口的父接口，所以<code>Collection</code>集合类也可以调用该方法。当调用<code>Iterable</code>的<code>forEach(Consumer a)</code>方法时，程序将集合元素传给<code>Consumer</code>的<code>accept(T t)</code>抽象方法，然后用<code>Lambda</code>表达式遍历。</p><pre class="line-numbers language-java"><code class="language-java">Collection names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>obj <span class="token operator">-</span><span class="token operator">></span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token operator">+</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>二、<strong>Java8增强<code>Iterator</code>遍历集合</strong></p><p><code>Iterator</code>接口也是<code>Java</code>集合框架的成员，但它与<code>Collection</code>、<code>Map</code>不一样，它们是用来放对象的，而<code>Iterator</code>则用于遍历<code>Collecton</code>集合中的元素，<code>Iterator</code>对象也被称为<code>迭代器</code>。</p><p><code>Iterator</code>接口定义了如下4种方法：</p><ul><li>boolean hasNext()：如果没有遍历完，则返回<code>true</code></li><li>Object next()：返回集合的下一个元素，注意是<code>Object</code>对象</li><li>void remove()：删除集合上一次next方法返回的元素</li><li>void forEachRemaining(Consumer a):Java8新增的方法，该方法可使用<code>Lambda</code>表达式遍历集合</li></ul><pre class="line-numbers language-java"><code class="language-java">Collection names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator it <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//names.remove(name);将报错</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//迭代时不能改变集合元素的值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Iterator</code>仅用于遍历集合，本身不提供装载对象的能力。如果要创建一个<code>Iterator</code>对象，则必须要有一个被遍历的集合，没有集合那要<code>Iterator</code>何用。迭代器采用<code>快速报错fail-fast</code>机制，一旦检测到集合已被修改，抽象立即发出<code>ConcurrentModificationException</code>异常，而不是显示修改后的结果，这样可以避免在共享资源时而引发异常问题。</p><p>三、<strong>用<code>foreach</code>循环遍历集合</strong></p><p>除了可以使用<code>Iterator</code>接口迭代访问<code>Collection</code>集合里元素之外，使用Java5提供的<code>foreach</code>循环迭代访问更简单。</p><pre class="line-numbers language-java"><code class="language-java">Collection names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>Objection obj <span class="token operator">:</span> names<span class="token punctuation">)</span><span class="token punctuation">{</span>    String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>obj<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与<code>Iterator</code>接口迭代集合元素类似，<code>foreach</code>循环中的迭代变量也不是集合元素本身，系统只是把值赋给变量，同样集合也不能改变。</p><h4 id="使用Lambda表达式遍历Iterator"><a href="#使用Lambda表达式遍历Iterator" class="headerlink" title="使用Lambda表达式遍历Iterator"></a>使用<code>Lambda</code>表达式遍历<code>Iterator</code></h4><p>Java8为<code>Iterator</code>新增<code>forEachRemaining()</code>方法，该方法所需参数同样也是函数式接口，原理类似，调用时将集合元素传给<code>Consumer</code>的accept(T t)方法。</p><pre class="line-numbers language-java"><code class="language-java">Collection names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator it <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">forEachRemaining</span><span class="token punctuation">(</span>obj <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token operator">+</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/d0f679eb042bc432a439c3028ca2295e.png" alt=""><br>本质上还是遍历集合<code>names</code>，所有上面的方法也可以归为遍历集合方法的一种，利用<code>Iterator</code>的<code>forEachRemaining</code>方法和<code>Lambda</code>表达式遍历，又比<code>Iterator</code>自己提供的方法遍历简洁了一点。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口 </tag>
            
            <tag> 集合类 </tag>
            
            <tag> 遍历集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java构造器和初始化块</title>
      <link href="/2020/0924/"/>
      <url>/2020/0924/</url>
      
        <content type="html"><![CDATA[<h3 id="Java构造器和初始化块"><a href="#Java构造器和初始化块" class="headerlink" title="Java构造器和初始化块"></a>Java构造器和初始化块</h3><p>构造器是一个特殊的方法，但定义构造器和普通方法没什么太大区别，该有的都有。不过为了区分还是看看不一样的地方。</p><ul><li>方法名：构造器方法名需要和类名一样</li><li>返回值：构造器不定义返回值，也不用返回<code>void</code>，但是它会返回一个对象(隐式的)</li><li>修饰符：一般设为<code>public</code>权限，可以被其他方法调用</li><li>不是静态的：构造器方法不用<code>static</code>修饰</li></ul><p>在定义一个类时，没有写构造器，系统将默认提供一个无参构造器。构造器是创建一个对象的途径之一。上面的第四点很少有书提到，但是我们也很少见到用<code>static</code>修饰的构造器—静态构造器。这里先讲一个知识点：在<code>static</code>修饰的方法中如果使用<code>this</code>关键字，则关键字无法指向对象。而访问非静态成员是隐式访问，在没有重名下，省略了<code>this</code>关键字，所以静态成员是无法访问非静态成员。回到<code>static</code>修饰，构造器如果用静态的，则不能访问非静态成员，而构造器是用来初始化成员变量的，那怎么初始化，怎么创建对象？最后还要返回对象。其次，创建对象会比较麻烦，<code>new</code>类名加构造器是不可想象的！</p><p>既然构造器不用类名加构造器访问，开始又没有实例对象，那如何访问呢？因此，Java提供关键字<code>new</code>来调用构造器，所以在构造器中关键字<code>this</code>表示构造器正在初始化的对象，当然大多数情况下可以省略，除了构造器中有一个重名的局部变量的情况下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">MyConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> son <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>son <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//构造器会把所有对象的son属性初始化为6</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a>构造器的作用</h4><p>主要作用还是为了<code>初始化</code>，默认初始化把所有数字基本类型实例变量设为0，布尔类型为<code>false</code>，引用类型为<code>null</code>，如果想改变一下，可以在构造器中定义。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">MyConstructor</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//传入两参数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是构造器不是全权负责创建对象，在执行构造器之前，系统已为对象分配了内存，结束后构造器返回对象，让引用指向该对象。</p><h4 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h4><p>如果想保留无参构造器，可以提供多个构造器，形成构造器重载。重载后，构造器的参数列表是不一样的，这样能利用不同的构造器创建不同的对象。如果包含多个构造器，其中一个构造器代码包含另一个，如下。这种情况是可以有简洁的代码代替的，但构造器不能直接被调用，用<code>new</code>关键字又会创建一个对象，则使用<code>this</code>关键字很好解决，<code>this</code>调用另一个重载的构造器。<code>此种方法仅限在构造器中使用</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">dog</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> weight<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">dog</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">,</span><span class="token keyword">int</span> weight<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用另一个构造器的初始化代码</span>        <span class="token comment" spellcheck="true">//其实还可以用以下代码代替,但是不建议</span>        <span class="token comment" spellcheck="true">//this.name = name;</span>        <span class="token comment" spellcheck="true">//this.age = age;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调用父类构造器"><a href="#调用父类构造器" class="headerlink" title="调用父类构造器"></a>调用父类构造器</h4><p>子类继承父类不会获得父类的构造器，但子类构造器可以调用父类构造器的初始化代码，类似上面的调用另一个重载构造器。在一个构造器中调用另一个构造器用<code>this</code>完成，在子类构造器中调用父类构造器则用<code>super</code>完成。<code>super</code>调用必须出现在子类构造器的第一行，因为Java设计子类执行构造器必须先调用父类构造器，所以它是第一行，然后，然后就没<code>this</code>啥事了，因为刚才讲了，再<code>this</code>调用又要执行父类构造器。<code>this</code>与<code>super</code>不能同时使用！</p><p>子类继承了父类的属性和方法，所以在先初始化父类的属性和方法，这样子类才可以初始化自己特有的，因为java中不允许调用没有初始化的成员。 <code>this</code>就是调用本类的其他构造函数，在其他构造函数中也有默认的super()，或者自定义了带参的<code>super</code>，这样就初始化了父类的成员了，所以写了<code>this</code>的构造函数不能再写<code>super</code>了，因为实例化一个对象运行两次<code>super</code>是不安全的。<code>this</code>放在第一行，也是因为要先初始化父类和this代表的构造函数先，因为当前构造函数可能用到那些成员，所以那些成员得要先初始化</p><p>不管是否使用<code>super</code>调用父类构造器，子类总会调用父类构造器一次，有以下情况：</p><ul><li>子类构造器使用<code>super</code>显式调用父类构造器</li><li>子类构造器使用<code>this</code>调用重载构造器，执行前重载构造器先会隐式调用父类构造器</li><li>子类构造器既无<code>super</code>调用，也没有<code>this</code>调用，则系统默认调用父类无参构造器</li></ul><p>创建任何对象时，总是从该类所在继承树最顶层类的构造器开始执行，然后往下执行到本类构造器。如果父类构造器还调用了重载构造器，那就会依次执行多个构造器。</p><h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>跟构造器作用差不多，初始化块也可以进行对象初始化，它比构造器先执行。它也是类的一种成员，修饰符只能用<code>static</code>修饰，被修饰称为静态初始化块，也可以不修饰。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出9，实例变量值为9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类和对象无法调用初始化块，初始化块只在创建对象时隐式执行，而且在构造器之前执行。此外，普通初始化块、声明实例变量指定默认值，都可认为是对象的初始化块，执行顺序和排列顺序一样。</p><p>当创建一个对象时，系统先为对象的所有实例变量分配内存，接着程序开始对实例变量初始化，初始化顺序是：先执行初始化块或声明实例变量时指定初始值，再执行构造器中的初始值。</p><h5 id="初始化块和构造器"><a href="#初始化块和构造器" class="headerlink" title="初始化块和构造器"></a>初始化块和构造器</h5><p>与构造器不同，初始化块是一段固定的代码，不接收参数，因此初始化块对同一个类的所有对象的初始化处理是一样的。所以就这种特点，我们可以利用来初始化相同一段值。构造器中相同一段代码可以提炼出相同初始化块，简化了程序，提高了复用性和可维护性。</p><blockquote><p>实际上在编译Java块后，初始化块会消失，初始化块的代码会被“还原”到构造器中，且位于构造器代码前面！</p></blockquote><p>与构造器类似，创建一个Java对象，不仅会执行该类的普通初始化块和构造器，而且系统会从<code>Object</code>类开始执行，往下执行父类，然后才到该类的初始化块和构造器。如果希望类加载后对整个类进行初始化操作，例如把类变量初始化一下，则需要用静态初始化块。</p><h5 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h5><p>也叫类初始化块，属于类的静态成员，同样需要遵循<code>静态成员不能访问非静态成员的规则</code>。普通初始化块负责对对象执行初始化，类初始化块则负责对类进行初始化。类初始化时，系统执行静态初始化块。静态初始化块是类相关的，系统将在类初始化阶段执行静态初始化块，而不是创建对象时才执行，因此静态初始化块总是比普通初始化块先执行。静态初始化块不能对实例变量进行初始化处理。</p><p>与普通初始化块类似，系统执行类的静态初始化块不仅会执行本类的静态初始化块，还会从源头类<code>Object</code>类开始执行，道理一样。类初始化后，才能使用这个类，然后才能创建对象。一旦类初始化成功，该类在JVM中一直存在，所以创建实例时，无须对类进行初始化。创建实例时，都需要先执行顶层父类的初始化块、构造器，然后执行父类的初始化块、构造器，然后执行本类的初始化块和构造器。<code>静态初始化块-&gt;普通初始化块-&gt;构造器</code></p><p>Java系统加载并初始化某个类时，总是保证该类的所有父类全部加载和初始化！静态初始化块和声明静态变量时所指定的初始值都是该类的初始化代码。JVM第一次主动调用某个类，系统会在类准备阶段为该类所有静态成员分配内存，初始化阶段负责初始化。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//(1)</span>        a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(2)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Test<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出9，如果调换(1)(2)则为6</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造器重载 </tag>
            
            <tag> 初始化块 </tag>
            
            <tag> 静态初始化块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量分类和运行机制及自动装拆箱</title>
      <link href="/2020/0919/"/>
      <url>/2020/0919/</url>
      
        <content type="html"><![CDATA[<h3 id="成员变量和局部变量及运行机制"><a href="#成员变量和局部变量及运行机制" class="headerlink" title="成员变量和局部变量及运行机制"></a>成员变量和局部变量及运行机制</h3><p>两者的区别在于定义变量的位置不同，运行的机制也有差异。成员变量定义在类中，局部变量定义在定义在方法中。</p><p>成员变量分为类变量和实例变量两种，局部变量分为形参(方法内)、方法局部变量和代码块内局部变量，比如循环内的。<br><img src="https://img-blog.csdnimg.cn/20200919203837599.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="变量分类"><br>类变量的生命周期和类一样，从类准备阶段开始，到完全销毁这个类，作用域则与类的生存范围相同。而实例变量从实例被创建起开始存在，直到实例被销毁，作用域对应实例作用域。可以发现，成员变量之所以称为<code>成员变量</code>，是因为其与所在的整体共存亡的。</p><blockquote><p>注意：类变量是属于类的，通过<code>实例.类变量</code>访问的依然是类变量，如果该实例修改了变量值，则其他实例访问时也将使用修改过的变量值。即访问了同一片内存区！</p></blockquote><p>与成员变量不同，局部变量除了形参外，都必须显式初始化；而上面的成员变量可以进行默认初始化，赋值规则与数组动态初始化时赋值规则相同。</p><p>当通过类或对象调用某个方法时，系统1会在调用该方法栈区内为所有形参分配内存，并将实参值赋值给对应形参，即完成形参初始化。</p><p>Java允许局部变量和成员变量同名，如果需要在方法内引用被覆盖的成员变量(局部变量和成员变量同名)，可以使用<code>this</code>关键字。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String name <span class="token operator">=</span> <span class="token string">"猴子"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">outPut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        String name <span class="token operator">=</span> <span class="token string">"悟空"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"悟空"</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"猴子"</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">double</span> age <span class="token operator">=</span> <span class="token number">100000.0</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//100000.0</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Test<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//500</span>        <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">outPut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员、局部变量初始化及运行机制"><a href="#成员、局部变量初始化及运行机制" class="headerlink" title="成员、局部变量初始化及运行机制"></a>成员、局部变量初始化及运行机制</h4><p>在类初始化或对象初始化时，系统会为成员变量分配内存空间，并指定默认初始值。需要关注的是，在创建一个对象时，不需要给类变量分配内存空间，只是为实例变量分配内存空间，因为类初始化时已经分配好了。在创建多个对象时，同样如此，也需要为实例变量分配内存空间，而且，实例变量是单个实例的，与类或其他实例无关。</p><p>局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化，就不会为变量分配内存空间，直到变量被初始化。与成员变量不同，局部变量不属于任何实例或类，因此它被保存在所在的方法栈中。如果变量是基本类型的变量，则会把值直接保存在对应内存中；但是变量是<code>引用类型</code>，则它存放的是地址，地址是所引用的对象或数组的地址。</p><p>局部变量的生命周期是和方法或代码块一致，但所在栈内存无需垃圾回收，因为局部变量只保存基本类型的值或引用，所以所占内存比较小。</p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>基本数据类型不具备对象特性：无成员变量，方法被调用。但有些时候显得不那么好，比如方法需要<code>object</code>类型的参数，并且需要提供实际值，像2，3，4，这就麻烦了。Java提供了包装类概念，并为8种基本数据类型定义了引用类型(基本数据类型的包装类)。</p><table><thead><tr><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><p>上述除<code>Character</code>外，其他包装类可传入参数创建一个包装类对象，</p><p>由于基本数据类型和包装类对象之间转换麻烦，JDK1.5提供了自动装箱和拆箱功能，去解决该问题。</p><p><strong>自动装箱</strong>：基本类型变量赋值给包装类(或者Object变量)；<strong>自动拆箱</strong>：包装类对象赋值给基本类型变量</p><pre class="line-numbers language-java"><code class="language-java">Integer a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//基本类型赋值给Integer对象</span>Object b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把布尔类型赋值给Object对象</span><span class="token keyword">int</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Integer对象拆箱赋值给基本类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虽然包装类是引用类型，但是实例是可以与数值比较的，比较时直接取出包装类的值进行比较。而包装类对象之间比较，只有指向同一对象时返回true。</p><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>Integer a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>Integer b <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true,待会解释</span><span class="token comment" spellcheck="true">//注意，Integer数据范围在-128~127之间，若不在会重新创建实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面来看，系统将整数装箱成实例，会放入一个<code>cache</code>数组(长度为256，Java就是这样设计的)中缓存起来，以后如需自动装箱则直接指向数组元素(若在-128~127之间)，即引用同一个实例对象。这样的缓存设计有利程序的运行性能，节省开销。</p><h4 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h4><p>字符串转基本类型有两种方式：</p><ol><li>包装类的parseXxx(String s)方法(除了Character包装类外)</li><li>对应的构造器方法，Xxx(String s)</li></ol><p>基本类型转字符串则使用<code>String</code>的多个重载<code>valueOf</code>方法。上述代码示例：</p><pre class="line-numbers language-java"><code class="language-java">String str <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一种方法</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//构造器创建对象，之后拆箱赋值给变量b</span><span class="token comment" spellcheck="true">//基本数据类型转字符串</span>String str1 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3.14159f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Java7、8增强包装类"><a href="#Java7、8增强包装类" class="headerlink" title="Java7、8增强包装类"></a>Java7、8增强包装类</h4><p>Java7开始为所有包装类提供静态的<code>compare(v1,v2)</code>方法，则可以通过该方法比较基本值的大小。比如：</p><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Java8再次增强，开始支持无符号算术运算。如为Integer、Long增强了静态的toUnsignedString(int/long v)整型转化成无符号整数对应的字符串、toUnsignedString(int/long v，int radix)转化成指定进制无符号整数对应的字符串。</p><blockquote><p>无符号整数的二进制最高位不再当作符号位看，即最小值为0。例如-2，对应的无符号整数为252</p></blockquote><hr><p>公众号: 菜鸡干Java<br><a href="https://index.maliaoblog.cn/" target="_blank" rel="noopener">流浪舟</a> <a href="https://index.maliaoblog.cn" target="_blank" rel="noopener">https://index.maliaoblog.cn</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量分类 </tag>
            
            <tag> 自动装拆箱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承和组合、单例类及不可变类</title>
      <link href="/2020/0917/"/>
      <url>/2020/0917/</url>
      
        <content type="html"><![CDATA[<h3 id="继承和组合、单例类及不可变类"><a href="#继承和组合、单例类及不可变类" class="headerlink" title="继承和组合、单例类及不可变类"></a>继承和组合、单例类及不可变类</h3><h4 id="继承-inheritance："><a href="#继承-inheritance：" class="headerlink" title="继承 inheritance："></a>继承 inheritance：</h4><p>继承是实现类复用的重要手段，所谓<code>复用</code>，就是可以多次使用，或者再次利用，不用继续重写成员变量和方法。但不代表没有缺点，最不好的地方：破坏封装。子类拓展父类时，若访问权限允许，则可直接访问父类的成员变量和方法，破坏了良好的<code>封装性</code>(Encapsulation) ，造成子类与父类的耦合。</p><p>因而，设计父类时应注意以下几点：</p><ul><li>尽量隐藏内部数据</li><li>不要让子类随意访问</li><li>不要在父类的构造器中调用将被子类重写的方法</li></ul><h4 id="组合-combination"><a href="#组合-combination" class="headerlink" title="组合 combination"></a>组合 combination</h4><p>对于继承而言，子类可以获取父类的public方法，使用子类时，可以访问子类从父类继承的方法；组合则是把旧类对象作为成员变量组合进来。我们不需要看到被组合进来的对象的方法，所以通常用<code>private</code>修饰。在功能上，两者没什么区别。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">beat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"心跳！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"呼吸！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">bird</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> animal a<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">bird</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//复用animal的方法</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"芜湖起飞！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><blockquote><p>使用组合关系实现复用，需要创建两个animal对象，是否意味着开销更大？</p><p>当创建一个子类对象时，系统不仅需要为该子类定义实例变量分配内存空间，而且需要为它父类所定义的实例变量分配内存。采用继承的方式，假设父类定义了两个实例的变量，子类定义了3个变量。创建子类实例时需要为子类分配5块内存空间。当采用组合设计时，先创建父类实例，此时需要分配2快内存，再创建整体类实例，也需要分配3块内存，只是多了一个引用变量来引用所组合的对象。因此，组合和继承设计开销不会有太大差别。</p></blockquote><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>这种类不像其他类，某些时候允许其他类自由创建该类对象没有什么意义，所以要降低对它的访问权限，让这样的类只能创建一个实例。</p><p>方法是把该类的构造方法用<code>private</code>修饰起来，但又需要创建一个对象，所以需要提供一个public方法去用于创建该类的对象，但是不是通过对象来创建对象，而是用类本身去创建，因此方法要用<code>static</code>修饰。</p><p>除此之外，该类还必须缓存对象，记录已创建的对象。同时让该静态方法能访问到，保存对象的成员变量也需要<code>static</code>修饰。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">person</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//静态成员变量来保存对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> person OnlyPerson<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//对构造器隐藏</span>    <span class="token keyword">private</span> <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//公共方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> person <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>OnlyPerson<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            OnlyPerson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> OnlyPerson<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类 immutable"></a>不可变类 immutable</h4><p>不可变类意思是创建该类的实例后，该实例的变量不可变。Java提供的8个包装类和String类都是不可变类！</p><pre class="line-numbers language-java"><code class="language-java">Double d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">5.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面创建了一个Double和String对象，并传入两个值，但程序无法继续修改该值，所以Double和String类没有修改值的方法。</p><p>如果要创建一个不可变类，需要遵守如下规则：</p><ol><li>使用<code>private</code>和<code>final</code>修饰符来修饰该类成员</li><li>提供带参构造器，用于初始化成员</li><li>仅提供get方法</li><li>确保引用的对象不会被修改</li><li>重写hashCode()方法和equals()方法</li></ol><p>与此对应的是可变类，比如JavaBean，提供了getter()和setter方法。</p><h5 id="缓存实例的不可变类"><a href="#缓存实例的不可变类" class="headerlink" title="缓存实例的不可变类"></a>缓存实例的不可变类</h5><p>不可变类的实例状态不可改变，可以方便被多个对象共享，主要是为了减小开销。不同的缓存方式有着不同的性能，可以用数组、集合等来缓存。</p><p>以Java的<code>java.lang.Integer</code>类为例，new一个构造器，每次返回新的<code>Integer</code>对象；如果用valueOf()方法来创建<code>Integer</code>对象，则会缓存该对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCacheTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//new一个对象</span>        Integer a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生成新对象，并缓存该对象</span>        Inreger a2 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer a3 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> a2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a2 <span class="token operator">==</span> a3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>        <span class="token comment" spellcheck="true">//注意：缓存的数只能在-128~127之间</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> 组合 </tag>
            
            <tag> 单例类 </tag>
            
            <tag> 不可变类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String与BigDecimal基础类</title>
      <link href="/2020/0916/"/>
      <url>/2020/0916/</url>
      
        <content type="html"><![CDATA[<h2 id="String与BigDecimal"><a href="#String与BigDecimal" class="headerlink" title="String与BigDecimal"></a>String与BigDecimal</h2><h4 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h4><p>string有11种构造方法</p><p><strong>1. 可变性</strong></p><ul><li>String不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><p><strong>2. 线程安全</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals()  方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool  中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得同一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><pre class="line-numbers language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// false</span>String s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><pre class="line-numbers language-java"><code class="language-java">String s5 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>String s6 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h3><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewStringTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 javap -verbose 进行反编译，得到以下内容：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ...</span>Constant pool<span class="token operator">:</span><span class="token comment" spellcheck="true">// ...</span>   #<span class="token number">2</span> <span class="token operator">=</span> Class              #<span class="token number">18</span>            <span class="token comment" spellcheck="true">// java/lang/String</span>   #<span class="token number">3</span> <span class="token operator">=</span> String             #<span class="token number">19</span>            <span class="token comment" spellcheck="true">// abc</span><span class="token comment" spellcheck="true">// ...</span>  #<span class="token number">18</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>String  #<span class="token number">19</span> <span class="token operator">=</span> Utf8               abc<span class="token comment" spellcheck="true">// ...</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// class java/lang/String</span>         <span class="token number">3</span><span class="token operator">:</span> dup         <span class="token number">4</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// String abc</span>         <span class="token number">6</span><span class="token operator">:</span> invokespecial #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String."&lt;init>":(Ljava/lang/String;)V</span>         <span class="token number">9</span><span class="token operator">:</span> astore_1<span class="token comment" spellcheck="true">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String  Pool 中的字符串对象作为 String 构造函数的参数。</p><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。</p><p>BigDecimal一共有4个构造方法:</p><blockquote><p>BigDecimal(int) 创建一个具有参数所指定整数值的对象。</p><p>BigDecimal(double) 创建一个具有参数所指定双精度值的对象。（不建议采用）</p><p>BigDecimal(long) 创建一个具有参数所指定长整数值的对象。</p><p>BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象</p></blockquote><p>这里不建议采用第二种，原因：</p><p>1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入 newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1，但是它实际上等于0.1000000000000000055511151。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于  0.1（虽然表面上等于该值）。</p><p>2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个  BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法 。</p><pre class="line-numbers language-java"><code class="language-java">BigDecimal a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"2.3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf，如下：</p><pre class="line-numbers language-java"><code class="language-java">BigDecimal a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal<span class="token punctuation">.</span>valueOf</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于常用的加，减，乘，除，BigDecimal类提供了相应的成员方法 </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> BigDecimal <span class="token function">add</span><span class="token punctuation">(</span>BigDecimal value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//加法</span><span class="token keyword">public</span> BigDecimal <span class="token function">subtract</span><span class="token punctuation">(</span>BigDecimal value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//减法 </span><span class="token keyword">public</span> BigDecimal <span class="token function">multiply</span><span class="token punctuation">(</span>BigDecimal value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//乘法</span><span class="token keyword">public</span> BigDecimal <span class="token function">divide</span><span class="token punctuation">(</span>BigDecimal value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//除法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><ol><li>在需要精确的小数计算时再使用BigDecimal，BigDecimal的性能比double和float差，在处理庞大，复杂的运算时尤为明显。故一般精度的计算没必要使用BigDecimal。</li><li>尽量使用参数类型为String的构造函数。</li><li>BigDecimal都是不可变的（immutable）的， 在进行每一次四则运算时，都会产生一个新的对象 ，所以在做加减乘除运算时要记得要保存操作后的值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> BigDecimal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的异常、多态要点及抽象类和接口</title>
      <link href="/2020/0907/"/>
      <url>/2020/0907/</url>
      
        <content type="html"><![CDATA[<p>作者：流浪舟</p><p><a href="https://index.maliaoblog.cn/" target="_blank" rel="noopener">个人站点</a>  <a href="https://index.maliaoblog.cn" target="_blank" rel="noopener">https://index.maliaoblog.cn</a></p><h4 id="一、java异常"><a href="#一、java异常" class="headerlink" title="一、java异常"></a>一、java异常</h4><p>如下图，异常分为两类，错误和异常；异常分为运行异常和可查异常。这里主要掌握异常，因为平时会见的比较多。Exception类在java.lang包下，它是Throwable的子类，同样的Error类也是其子类。Error 用来指示运行时环境发生的错误，例如：JVM 内存溢出。一般地，程序不会从错误中恢复。异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src="https://img-blog.csdnimg.cn/20200906184500463.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>Java 根据各个类库也定义了一些其他的异常，有常用检查性和非检查性异常。</p><table><thead><tr><th align="left"><strong>异常</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">ArithmeticException</td><td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td align="left">ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td align="left">ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td align="left">ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td align="left">IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td align="left">IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td align="left">IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td align="left">IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td align="left">IndexOutOfBoundsException</td><td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td align="left">NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td align="left">NullPointerException</td><td>当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</td></tr><tr><td align="left">NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td align="left">SecurityException</td><td>由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td align="left">StringIndexOutOfBoundsException</td><td>此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td align="left">UnsupportedOperationException</td><td>当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><p>下面的表中列出了在 java.lang 包中的检查性异常类。</p><table><thead><tr><th><strong>异常</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td align="left">应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td align="left">当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td align="left">拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td>InstantiationException</td><td align="left">当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td>InterruptedException</td><td align="left">一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td align="left">请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td align="left">请求的方法不存在</td></tr></tbody></table><p><strong>异常方法</strong></p><p>提一个最常见的，<strong>public void printStackTrace()</strong>，打印toString()结果和栈层次到System.err，即错误输出流，有点类似错误追踪。</p><p><strong>异常捕获</strong></p><p>try/catch 代码块放在异常可能发生的地方，try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 程序代码</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>ExceptionName e1<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//Catch 块</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以有多个catch语句，叫多重捕获。catch 语句包含要捕获异常类型的声明，当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块。</p><p><strong>抛出异常</strong></p><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部，也可以使用 throw 关键字抛出一个异常。需要注意的是，如果有必要抛出多个异常，则可以在后面继续添加用逗号隔开。</p><p><strong>finally关键字</strong></p><p>finally关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在finally代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 程序代码 </span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">1</span> 异常的变量名<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 程序代码 </span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token number">2</span> 异常的变量名<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 程序代码 </span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 程序代码 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二、被搞糊涂的多态"><a href="#二、被搞糊涂的多态" class="headerlink" title="二、被搞糊涂的多态"></a>二、被搞糊涂的多态</h4><h5 id="存在必要条件："><a href="#存在必要条件：" class="headerlink" title="存在必要条件："></a>存在必要条件：</h5><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul><p>比如：</p><pre class="line-numbers language-java"><code class="language-java">Parent p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>(容易忘，容易搞糊涂)：当使用多态方式调用方法时，首先检查父类中是否有该方法，如果有，则去调用子类的同名方法，但不能调用子类独有的方法。多态的好处是可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><h5 id="多态的实现方式："><a href="#多态的实现方式：" class="headerlink" title="多态的实现方式："></a>多态的实现方式：</h5><blockquote><p>方式一：重写：</p><p>方式二：接口</p><p>方式三：抽象类和抽象方法</p></blockquote><h4 id="三、Abstract抽象类和接口"><a href="#三、Abstract抽象类和接口" class="headerlink" title="三、Abstract抽象类和接口"></a>三、Abstract抽象类和接口</h4><h5 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h5><p>抽象类和其他普通类没什么区别，除了不能实例化外，其他功能都还好。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。在Java中，抽象类表示的是一种继承关系，<code>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</code></p><p>声明抽象方法会造成以下结果：</p><ul><li>​        如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>​        任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li></ul><p><strong>需要注意</strong>：抽象类不一定有抽象方法，而有抽象方法一定是抽象类； 构造方法，类方法(用static修饰的方法)不能声明为抽象方法；抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p><h5 id="接口：interface"><a href="#接口：interface" class="headerlink" title="接口：interface"></a>接口：interface</h5><p>接口并不是类，类描述对象的属性和方法，接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口没有构造方法，同样无法被实例化。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</p><p>接口与接口之间则是通过继承来关联，支持多继承！</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">NameOfInterface</span> <span class="token keyword">extends</span> <span class="token class-name">a</span><span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">{</span><span class="token comment" spellcheck="true">//a,b,c接口</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token keyword">int</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">o</span><span class="token punctuation">(</span><span class="token keyword">int</span> ot<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//任何类型 final, static 字段</span>   <span class="token comment" spellcheck="true">//抽象方法(隐式)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口特性：</p><ul><li>接口中每一个方法是隐式抽象的,指定为<strong>public abstract</strong>（只能是public abstract，其他修饰符都会报错）</li><li>接口中可以含有变量，但是会被隐式的指定为<strong>public static final</strong> 变量(并且只能是public）</li></ul><p>接口中每一个方法也是隐式抽象的，声明时不需要abstract关键字，接口中的方法都是公有的<strong>public</strong>。</p><p><strong>抽象类和接口的区别</strong>：</p><ul><li>抽象类中的方法可以有方法体，但是接口中的方法不行(jdk1.8)。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用static修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><blockquote><p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了</p></blockquote><h5 id="接口的实现：implements"><a href="#接口的实现：implements" class="headerlink" title="接口的实现：implements"></a>接口的实现：implements</h5><p>与抽象类不同，当类实现接口的时候，类要实现接口中所有的方法，否则，类必须声明为抽象的类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Mydog</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span><span class="token punctuation">,</span>dog<span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Mydog eats"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重写接口中声明的方法时，需要注意以下：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul><p>在实现接口的时候，也要注意：</p><ul><li>一个类可以同时实现多个接口</li><li>一个类只能继承一个类，但是能实现多个接口</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java异常 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 抽象 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-matery主题代码高亮和部署问题</title>
      <link href="/2020/0822/"/>
      <url>/2020/0822/</url>
      
        <content type="html"><![CDATA[<p>作者：流浪舟(原coderxm,这个名字更好一点)</p><blockquote><p>本篇的内容很简单，就是说说这个主题的两个问题。一个是代码高亮失效的问题，另一个是hexo deploy部署问题。</p></blockquote><h4 id="代码高亮失效"><a href="#代码高亮失效" class="headerlink" title="代码高亮失效"></a>代码高亮失效</h4><p>如果大家用的是<code>hexo-prism-plugin</code>代码高亮插件，那就可能遇到这样的问题。该插件的作者在github issue上讨论过，几年前的事。</p><p><img src="https://img-blog.csdnimg.cn/20200822102743931.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="github issue"><br>解决的办法是安装<code>hexo-inject</code>，进入到博客项目目录，命令行输入：</p><pre><code>npm i hexo-inject -s</code></pre><p><img src="https://img-blog.csdnimg.cn/20200822102818808.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="代码高亮"></p><h4 id="hexo博客部署问题"><a href="#hexo博客部署问题" class="headerlink" title="hexo博客部署问题"></a>hexo博客部署问题</h4><p>其实它是个github上传错误，<code>上传项目到github报错：Permission to xxx/xxx.git denied to xxxxxxx.</code>。出现这个问题是因为git权限问题，有两个或多个git账户,git退出后保留上次git 账户信息。</p><h5 id="解决一：重新设置博客仓库账户为全局"><a href="#解决一：重新设置博客仓库账户为全局" class="headerlink" title="解决一：重新设置博客仓库账户为全局"></a>解决一：重新设置博客仓库账户为全局</h5><pre><code>git config --global user.name 博客本地用户名</code></pre><h5 id="解决二：输入github账户密码获取权限去提交"><a href="#解决二：输入github账户密码获取权限去提交" class="headerlink" title="解决二：输入github账户密码获取权限去提交"></a>解决二：输入github账户密码获取权限去提交</h5><pre><code>git push -u xxx master</code></pre><p>公众号：小码之光<br><a href="https://index.maliaoblog.cn/" target="_blank" rel="noopener">个人站点</a>  <a href="https://index.maliaoblog.cn" target="_blank" rel="noopener">https://index.maliaoblog.cn</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-inject </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery主题美化(四)</title>
      <link href="/2020/0819/"/>
      <url>/2020/0819/</url>
      
        <content type="html"><![CDATA[<h4 id="hexo-matery主题美化-四"><a href="#hexo-matery主题美化-四" class="headerlink" title="hexo-matery主题美化(四)"></a>hexo-matery主题美化(四)</h4><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><blockquote><p>前言</p><p>去掉banner的颜色动画</p><p>添加背景壁纸</p><p>修改滑动条</p><p>修改导航栏、页脚及文章卡片标签的颜色</p><p>修改目录样式</p></blockquote><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><p>这是最后一篇关于hexo-matery博客美化的文章了，大部分都是前端的东西，所以没啥好讲的，对我来说后端更侧重一点，这些天都没怎么写Java代码了。离前一篇博客美化文章已过去一个星期了，因为我回了趟老家，住了一个星期，心里感觉很复杂。我本身技术并不是很强，每天都要实实在在的学习知识，家里条件不好，以后的路真的难走！加油吧！</p><h5 id="一、去掉banner的颜色动画"><a href="#一、去掉banner的颜色动画" class="headerlink" title="一、去掉banner的颜色动画"></a>一、去掉banner的颜色动画</h5><p>有的同学可能不喜欢banner的颜色遮罩，特别是在banner图片的颜色和动画颜色一样时，表现不出图片的美观。去掉后放一张高清小姐姐大图，博客访问量一下迅速爆炸！听我的准没错，那如何去掉这个烦人的彩色动画呢？跟着我：在theme主题目录下，找到<code>matery.css</code>文件,<code>ctrl+F</code>快捷键查找<code>.bg-cover:after</code>，注释掉即可。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* .bg-cover:after {    -webkit-animation: rainbow 60s infinite;    animation: rainbow 60s infinite;} */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="二、添加背景壁纸"><a href="#二、添加背景壁纸" class="headerlink" title="二、添加背景壁纸"></a>二、添加背景壁纸</h5><p>同样在matery.css文件下查找body样式,修改如下：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* background-color: #eaeaea; */</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span><span class="token number">60</span>deg, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">165</span>, <span class="token number">150</span>, <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token number">5%</span>, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">228</span>, <span class="token number">255</span>, <span class="token number">0.35</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token number">0%</span> <span class="token number">0%</span> /     cover, <span class="token url">url("https://x.png")</span>, <span class="token url">url("https://x.jpg")</span> <span class="token number">0</span>px <span class="token number">0</span>px<span class="token punctuation">;</span>    <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#7F95D1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不想要图片，去掉即可，比如：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>    <span class="token property">cursor</span><span class="token punctuation">:</span><span class="token url">url(/cursor.svg)</span>,auto<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span><span class="token number">60</span>deg, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">165</span>, <span class="token number">150</span>, <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token number">5%</span>, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">228</span>, <span class="token number">255</span>, <span class="token number">0.35</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#34495e</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="三、修改滑动条（没试过，好像没用）"><a href="#三、修改滑动条（没试过，好像没用）" class="headerlink" title="三、修改滑动条（没试过，好像没用）"></a>三、修改滑动条（没试过，好像没用）</h5><p>说是说修改滑动条，但是不需要太麻烦，在matery.css中添加样式即可：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 滚动条 */</span><span class="token selector"><span class="token pseudo-element">::-webkit-scrollbar-thumb</span> </span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#FF2A68</span><span class="token punctuation">;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">-webkit-linear-gradient</span><span class="token punctuation">(</span><span class="token number">45</span>deg,<span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>,<span class="token number">255</span>,<span class="token number">255</span>,<span class="token number">.4</span><span class="token punctuation">)</span> <span class="token number">25%</span>,transparent <span class="token number">25%</span>,transparent <span class="token number">50%</span>,<span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>,<span class="token number">255</span>,<span class="token number">255</span>,<span class="token number">.4</span><span class="token punctuation">)</span> <span class="token number">50%</span>,<span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>,<span class="token number">255</span>,<span class="token number">255</span>,<span class="token number">.4</span><span class="token punctuation">)</span> <span class="token number">75%</span>,transparent <span class="token number">75%</span>,transparent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">3</span>em<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token pseudo-element">::-webkit-scrollbar-track</span> </span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ffcaca</span>ff<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">3</span>em<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token pseudo-element">::-webkit-scrollbar</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">8</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">15</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="四、修改导航栏、页脚及文章卡片标签的颜色"><a href="#四、修改导航栏、页脚及文章卡片标签的颜色" class="headerlink" title="四、修改导航栏、页脚及文章卡片标签的颜色"></a>四、修改导航栏、页脚及文章卡片标签的颜色</h5><p>同样的操作，在matery.css中找到<code>.bg-color</code>,修改即可：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span>     <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#3f1b07</span> <span class="token number">0%</span>, <span class="token hexcode">#3f1b07</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*咖啡色*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="五、修改目录样式（没试过）"><a href="#五、修改目录样式（没试过）" class="headerlink" title="五、修改目录样式（没试过）"></a>五、修改目录样式（没试过）</h5><p>在<code>themes\Matery\layout\_partial\post-detail-toc.ejs</code>，在这里修改:</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.toc-widget</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">345</span>px<span class="token punctuation">;</span>    <span class="token property">padding-left</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">255</span>,<span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">10</span>px <span class="token number">35</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">.15</span><span class="token punctuation">)</span>, <span class="token number">0</span> <span class="token number">5</span>px <span class="token number">15</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">.07</span><span class="token punctuation">)</span>, <span class="token number">0</span> <span class="token number">2</span>px <span class="token number">5</span>px -<span class="token number">5</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">.1</span><span class="token punctuation">)</span> <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>公众号：小码之光<br><a href="https://index.maliaoblog.cn/" target="_blank" rel="noopener">个人站点</a>  <a href="https://index.maliaoblog.cn" target="_blank" rel="noopener">https://index.maliaoblog.cn</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新sakura博客园皮肤配置,NewSakura</title>
      <link href="/2020/0814/"/>
      <url>/2020/0814/</url>
      
        <content type="html"><![CDATA[<h1 id="CNblogs-Theme-NewSakura"><a href="#CNblogs-Theme-NewSakura" class="headerlink" title="CNblogs-Theme-NewSakura"></a>CNblogs-Theme-NewSakura</h1><ul><li>基于Sakura美化方案改造的博客园样式：NewSakura</li><li>如使用了本样式，请给个Star。</li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><pre><code>CNblogs-Theme-NewSakura|├─ CNblogs-Theme-NewSakura│    ├─ foot.html 页脚代码│    ├─ main.css 自定义css代码│    ├─ main.js  引用js│    └─ sidebar.html 侧边栏代码├─ README.md└─ img       ├─ 效果1.JPG       └─ 效果2.JPG</code></pre><p> 有js权限，期间将侧边栏、页脚和css代码粘贴进博客园设置内即可！代码文件内有相应注释，根据它修改即可。</p><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>依次分重点：</p><ul><li>新增暗黑白昼模式，白天暗黑刺激</li><li>首页及随笔页头图随机切换</li><li>音乐播放器，使用Aplayer插件</li><li>看板娘，原先的主题已失效，现已修改</li><li>自动生成文章目录，基本功能</li><li>导航菜单子目录，照葫芦画瓢添加</li><li>图片灯箱、滚动进度条</li><li>文章打赏</li><li>鼠标点击粒子效果</li><li>其他网站链接，非必需</li><li>将首页底部不必要的滚动条去掉</li><li>修改了文章评论区的框框大小，原先的过大变形</li><li>暗黑白昼切换不影响评论区，暗黑字白，白昼字黑</li><li>修改了分类页面样式，为了在暗黑后看的清楚美观</li></ul><p>注意：目前Sakura还不支持响应式，所以还需大家帮忙喽！</p><h2 id="主题预览"><a href="#主题预览" class="headerlink" title="主题预览"></a>主题预览</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0ZWUuY29tL3VwbG9hZHMvaW1hZ2VzLzIwMjAvMDgxMi8xNTA3NTJfNzQ3NWIwNWZfNTcxODU3MC5qcGVn?x-oss-process=image/format,png" alt="效果1"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0ZWUuY29tL3VwbG9hZHMvaW1hZ2VzLzIwMjAvMDgxMi8xNTA3NDlfNTA0NWVjZTBfNTcxODU3MC5qcGVn?x-oss-process=image/format,png" alt="效果2"></p><h2 id="主题部署"><a href="#主题部署" class="headerlink" title="主题部署"></a>主题部署</h2><div class="info"><p>快速搭建出与本博客一样的样式，    请看下面这句说明，当然前提是得有<span style="color: red">js权限</span></p></div><p>部署和本博客一样的主题，请直接下载整个主题，对应的改下<strong>文件链接地址</strong> ，把<strong>css</strong>、<strong>侧边栏</strong>、<strong>页脚</strong>代码粘贴的你的博客后台就行。为了个性化定制，如果你想个性化定制博客，请往下看基本部署。</p><h3 id="基本部署"><a href="#基本部署" class="headerlink" title="基本部署"></a>基本部署</h3><ul><li><p>前提：已经开通<code>js</code>权限</p></li><li><p>设置皮肤选择自定义custom</p></li><li><p>引入样式<br>把<strong>main.css</strong>中的代码粘贴到自定义css中，无需个性化操作</p></li><li><p>引入文件<br>放在侧边栏html文件中，本人已为你添加。建议下载该文件并上传博客园，之后只需修改样式引入即可！</p><pre><code>&lt;script src=&quot;https://blog-static.cnblogs.com/files/coderma/main.js&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>顶部菜单设置</p><p>将以下链接替换成自己随笔地址，以下代码在<code>main.js</code>中,建议打开该文件查看并修改</p><pre><code>$(&quot;#navList&quot;).append(&#39;&lt;li&gt;&lt;a id=&quot;blog_nav_myyoulian&quot; class=&quot;menu&quot;href=&quot;https://www.cnblogs.com/coderma/p/1117239.html&quot;&gt;友链&lt;/a&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_myzanshang&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/coderma/p/1133477.html&quot;&gt;赞赏&lt;/a&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_myguanyu&quot; class=&quot;menu&quot; href=&quot;&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;&#39;);</code></pre></li><li><p>菜单icon设置<br>  就是菜单前的小图标，感兴趣的可以去了解一下<a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">Font awesome</a></p><pre class="line-numbers language-javascript"><code class="language-javascript">          <span class="token comment" spellcheck="true">//博客title</span>          <span class="token comment" spellcheck="true">//去掉rss替换成分类</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_rss'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span><span class="token string">'&lt;a id="blog_nav_fenlei" class="menu" href="https://www.cnblogs.com/coderma/p/13458241.html" target="_self">分类&lt;/a>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//可替换以下链接</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#navList"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'&lt;li>&lt;a id="blog_nav_myyoulian" class="menu" href="https://www.cnblogs.com/coderma/p/13413494.html" target="_self">友链&lt;/a>&lt;i>&lt;/i>&lt;/li>&lt;li>&lt;a id="blog_nav_myarchive" class="menu" href="https://www.cnblogs.com/coderma/p/13414527.html" target="_self">归档&lt;/a>&lt;i>&lt;/i>&lt;/li>&lt;li>&lt;a id="blog_nav_myguanyu" class="menu" >关于&lt;/a>&lt;/li>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//添加标签图标</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_sitehome'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-fort-awesome" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//博客园</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myhome'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-home" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//首页</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_newpost'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-edit" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//新随笔</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_contact'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-address-book-o" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//联系</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_fenlei'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-filter" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//分类</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_admin'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-cog" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//管理</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myyoulian'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-link" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//友链</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myarchive'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-archive" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//赞赏</span>          <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myguanyu'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token string">'&lt;i class="fa fa-universal-access" aria-hidden="true">&lt;/i>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关于</span>          <span class="token comment" spellcheck="true">//添加li内嵌ui</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>菜单子目录设置</p><p>  菜单子目录，在<strong>关于</strong>菜单下添加了子目录,相应的样式可自行修改添加</p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token keyword">let</span> guanyu <span class="token operator">=</span> <span class="token string">'&lt;ul class="sub-menu">'</span> <span class="token operator">+</span>      <span class="token string">'&lt;li>&lt;a href=" " target="_self">&lt;i class="fa fa-user-o" aria-hidden="true">&lt;/i>博主&lt;/a>&lt;/li>'</span> <span class="token operator">+</span>   <span class="token comment" spellcheck="true">//添加关于文章链接</span>      <span class="token string">'&lt;li>&lt;a id="blog_nav_theme" onclick="changeTheme();" >&lt;i class="iconfont icon-taohua" aria-hidden="true">&lt;/i> 主题&lt;/a>&lt;/li>'</span> <span class="token operator">+</span>  <span class="token comment" spellcheck="true">//主题/暗黑白昼模式</span>      <span class="token string">'&lt;/ul>'</span><span class="token punctuation">;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#blog_nav_myguanyu'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span>guanyu<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>脚本设置</p><p>为了配置方便，我在侧边栏里设置了一些常用参数，可根据下表选择需要开启和配置</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;   $.silence({      profile: {          enable: true,          avatar: &#39;https://images.cnblogs.com/cnblogs_com/coderma/1820127/o_200803093536logo.png&#39;, //头像，可修改          favicon: &#39;&#39;,          notice: &#39;个人博客地址：https://index.maliaoblog.cn/  欢迎大家来踩&#39;   //通知，可修改      },      catalog: {          enable: true,          move: true,          index: true,          level1: &#39;h2&#39;,          level2: &#39;h3&#39;,          level3: &#39;h4&#39;,      },      signature: {          enable: true,          home: &#39;https://www.cnblogs.com/coderma/&#39;,  //主页链接，可修改          license: &#39;CC BY 4.0&#39;,          link: &#39;https://creativecommons.org/licenses/by/4.0&#39;      },      sponsor: {          enable: true,          paypal: null,          wechat: &#39;&#39;,  //赞助，可修改图片链接          alipay: &#39;&#39;      },      github: {          enable: false,          color: &#39;#fff&#39;,          fill: &#39;#FF85B8&#39;,          link: &#39;https://github.com/coderxm&#39;  //可修改      },    topImg: {      homeTopImg: [    &quot;https://img2020.cnblogs.com/blog/2027366/202008/2027366-20200807133710823-1221571975.jpg&quot;,   //主页顶部图片，可修改                  ],            notHomeTopImg: [    &quot;https://img2020.cnblogs.com/blog/2027366/202008/2027366-20200807132804040-1889645361.jpg&quot;,  //可修改                  ]      },    topInfo: {          title: &#39;Hi,流浪舟&#39;,  //首页标题（可替换）          text: &quot;No one choose this life for me But I don&#39;t mind it&quot;,  //首页横幅语句          github: &quot;https://github.com/coderxm/&quot;,      //github(替换成相应链接)          weibo: &quot;&quot;,          telegram: &quot;&quot;,          music: &quot;&quot;,          twitter: &quot;&quot;,          zhihu: &quot;&quot;,          mail: &quot;&quot;,      }         });&lt;/script&gt;</code></pre><p>参数说明表：</p><table><thead><tr><th align="left">模块</th><th>属性</th><th>说明</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td align="left">profile（基础信息）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>true</td></tr><tr><td align="left"></td><td>avatar</td><td>作者头像</td><td>String</td><td></td></tr><tr><td align="left"></td><td>favicon</td><td>网站标题图标</td><td>String</td><td></td></tr><tr><td align="left"></td><td>notice</td><td>公告</td><td>String</td><td>感谢使用该主题</td></tr><tr><td align="left"></td><td>authorName</td><td>作者姓名</td><td>String</td><td>coderxm</td></tr><tr><td align="left">catalog（博文目录）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>false</td></tr><tr><td align="left"></td><td>move</td><td>是否允许拖拽</td><td>Boolean</td><td>true</td></tr><tr><td align="left"></td><td>index</td><td>是否显示索引</td><td>Boolean</td><td>true</td></tr><tr><td align="left"></td><td>level1</td><td>一级标题</td><td>String</td><td>h2</td></tr><tr><td align="left"></td><td>level2</td><td>二级标题</td><td>String</td><td>h3</td></tr><tr><td align="left"></td><td>level3</td><td>三级标题</td><td>String</td><td>h4</td></tr><tr><td align="left">signature（博文签名）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>true</td></tr><tr><td align="left"></td><td>home</td><td>作者主页</td><td>String</td><td><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">https://www.cnblogs.com</a></td></tr><tr><td align="left"></td><td>license</td><td>许可证名称</td><td>String</td><td>CC BY 4.0</td></tr><tr><td align="left"></td><td>link</td><td>许可证链接</td><td>String</td><td><a href="https://creativecommons.org/licenses/by/4.0" target="_blank" rel="noopener">https://creativecommons.org/licenses/by/4.0</a></td></tr><tr><td align="left">sponsor（博文赞赏）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>false</td></tr><tr><td align="left"></td><td>paypal</td><td>PayPal 收款地址</td><td>String</td><td>null</td></tr><tr><td align="left"></td><td>alipay</td><td>支付宝收款二维码</td><td>String</td><td>null</td></tr><tr><td align="left"></td><td>wechat</td><td>微信收款二维码</td><td>String</td><td>null</td></tr><tr><td align="left">github（GitHub Corners）</td><td>enable</td><td>是否启用</td><td>Boolean</td><td>false</td></tr><tr><td align="left"></td><td>fill</td><td>背景填充色</td><td>String</td><td>[Silence Theme Color]</td></tr><tr><td align="left"></td><td>color</td><td>章鱼猫颜色</td><td>String</td><td>#fff</td></tr><tr><td align="left"></td><td>link</td><td>Github 链接</td><td>String</td><td>null</td></tr><tr><td align="left">topImg（头图）</td><td>homeTopImg</td><td>首页头图</td><td>Array</td><td></td></tr><tr><td align="left"></td><td>notHomeTopImg</td><td>文章和随笔页头图</td><td>Array</td><td></td></tr><tr><td align="left">topInfo(首页头图信息)</td><td>titile</td><td>头部标题</td><td>String</td><td>Hi, 流浪舟!</td></tr><tr><td align="left"></td><td>text</td><td>横幅标题</td><td>String</td><td>No one choose this life for me But I don’t mind it</td></tr></tbody></table></li></ul><p>配置完成后，记得点击「保存」按钮。 </p><h2 id="个性化定制"><a href="#个性化定制" class="headerlink" title="个性化定制"></a>个性化定制</h2><h3 id="新增暗黑白昼模式"><a href="#新增暗黑白昼模式" class="headerlink" title="新增暗黑白昼模式"></a>新增暗黑白昼模式</h3><p>开始的时候是暗黑的，在<strong>关于</strong>下的子菜单栏内，点击主题可切换成白昼模式。 </p><h3 id="菜单新增分类、友链、博主、归档栏"><a href="#菜单新增分类、友链、博主、归档栏" class="headerlink" title="菜单新增分类、友链、博主、归档栏"></a>菜单新增分类、友链、博主、归档栏</h3><p>原理简单，只需先新建随笔即可，并替换链接，点击便可跳转到相应页面。关于分类，去掉了过去的RSS，换成博客园已有的分类，同样的方法，将所有分类链接收录到某一随笔中即可，随笔链接即是分类栏链接。博主一栏写你的信息，归档类似，我相信这样的问题难不倒有大智慧的你！</p><h3 id="首页及文章大图"><a href="#首页及文章大图" class="headerlink" title="首页及文章大图"></a>首页及文章大图</h3><p>首页和随笔以及文章页的头图都是随机切换的，添加图片在侧边栏html配置中。这里类型为随笔的时候头部会显示<strong>标题</strong>、<strong>头像</strong>、<strong>作者</strong>、<strong>发布时间</strong>、<strong>阅读数</strong>，而类型为文章的时候只会显示标题，根据情况选择类型发布。<br>请尽量选择像素1920*1080px的高清大图，这样的话首页图片会更适合。</p><h3 id="随笔预览图"><a href="#随笔预览图" class="headerlink" title="随笔预览图"></a>随笔预览图</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuZ2l0ZWUuY29tL3VwbG9hZHMvaW1hZ2VzLzIwMjAvMDgxMi8xNTA3NDlfNTA0NWVjZTBfNTcxODU3MC5qcGVn?x-oss-process=image/format,png" alt="预览"></p><p>在写随笔或者文章的时候添加摘要图片和摘要文字，<strong>摘要文字一定要添加</strong>，如果不添加摘要图片会给一张默认图片。</p><h3 id="回顶部钩子"><a href="#回顶部钩子" class="headerlink" title="回顶部钩子"></a>回顶部钩子</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//回到顶部特效</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`&lt;a href="#" class="cd-top faa-float animated cd-fade-out" target="_self">&lt;/a>`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> $win <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> oldScrollY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        $win<span class="token punctuation">.</span><span class="token function">scroll</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            oldScrollY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scrollY<span class="token punctuation">;</span>                <span class="token keyword">let</span> height <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>            <span class="token keyword">let</span> top <span class="token operator">=</span> <span class="token string">'-'</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">900</span> <span class="token operator">-</span> height <span class="token operator">+</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldScrollY <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.cd-top'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'top'</span><span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span>                     <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.cd-top'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'top'</span><span class="token punctuation">,</span> <span class="token string">'-900px'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="公告"><a href="#公告" class="headerlink" title="公告"></a>公告</h3><p>公告内容修改在侧边栏基础信息配置中，修改<code>notice</code>，代码中已有提示</p><h3 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h3><p>我个人博客的看板娘是引用别人的，同一个，失效了会及时修复的！将以下代码添加到页脚，当然本人又已经为你添加好了，所以过程非常轻松！</p><pre class="line-numbers language-javascript"><code class="language-javascript">  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h3><p>相信看过我以前文章的同学对这个一定不会陌生，怎么获取id我也不在这里罗嗦了，可以去找我的文章，获取到id之后把下面的id替换掉就可以了！</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/aplayer@1.10.0/dist/APlayer.min.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://blog-static.cnblogs.com/files/zouwangblog/APlayer.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/meting@1.2/dist/Meting.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>player<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aplayer aplayer-withlist aplayer-fixed<span class="token punctuation">"</span></span> <span class="token attr-name">data-id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7660234225<span class="token punctuation">"</span></span> <span class="token attr-name">data-server</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tencent<span class="token punctuation">"</span></span> <span class="token attr-name">data-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>playlist<span class="token punctuation">"</span></span> <span class="token attr-name">data-order</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>random<span class="token punctuation">"</span></span> <span class="token attr-name">data-fixed</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">data-listfolded</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">data-theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orangered<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- end --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="博客logo"><a href="#博客logo" class="headerlink" title="博客logo"></a>博客logo</h3><p>左上角的logo，修改文字需要到<code>main.js</code>里找到以下代码，替换文字即可，如果不喜欢可以注掉,我也觉得没啥好看，main.js里我已经删了！</p><pre class="line-numbers language-javascript"><code class="language-javascript">    <span class="token keyword">var</span> title <span class="token operator">=</span> <span class="token string">'&lt;div class="site-branding">'</span> <span class="token operator">+</span>                    <span class="token string">'&lt;span class="logolink moe-mashiro">'</span> <span class="token operator">+</span>                    <span class="token string">'&lt;ruby>&lt;span class="sakuraso">漂泊&lt;/span>&lt;span class="no">的&lt;/span>&lt;span class="shironeko">流浪舟&lt;/span>'</span> <span class="token operator">+</span>                    <span class="token string">'&lt;rt class="chinese-font">漂泊的流浪舟&lt;/rt>&lt;/ruby>&lt;/a>&lt;/span>'</span> <span class="token operator">+</span>                    <span class="token string">'&lt;/div>'</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="页面滚动进度条"><a href="#页面滚动进度条" class="headerlink" title="页面滚动进度条"></a>页面滚动进度条</h3><p>页面滚动的时候会在顶部出现一个橙色的进度条，修改颜色到页面css里，找到以下代码修改<code>background</code></p><pre><code>.scrollCls {    position: fixed;    top: 0;    height: 3px;    background: orange;    transiton-property: width,background;    transition-duration: 1s,1s;    z-index: 99999;}</code></pre><h3 id="首页个人信息"><a href="#首页个人信息" class="headerlink" title="首页个人信息"></a>首页个人信息</h3><ul><li><p>名称<br>在侧边栏配置中修改<code>topInfo</code>里的<code>title</code></p></li><li><p>座右铭（横幅标题）<br>在侧边栏配置中修改<code>topInfo</code>里的<code>text</code></p></li><li><p>其他网站链接(已注释，大都是推特等国外app，影响美观)<br>在侧边栏配置中修改<code>topInfo</code>里对应的链接地址</p></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最近在博客园和皮肤厮混，发现没几个满意的！这让我追求精致的心受到了打击，最开始用的是这个，后来换了，不过换之前改进了一些！最总发现移动端不行，所以干脆把项目弄到github上，让大家看看！我把这个美化分享了出去，以我目前的前端技术改造这么个样式也很费劲的，毕竟不是专业做前端的！这是我在博客园的一篇美化文章了，博客还是有很多改进的，希望采用这个样式的你能够多多支持，有什么问题都可以提交，我也会及时为大家解决!</p><h2 id="微信公众平台"><a href="#微信公众平台" class="headerlink" title="微信公众平台"></a>微信公众平台</h2><p>微信搜索 “小码之光” 关注，里面有加群，可以一起交流！</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/coderxm/CNblogs-Theme-NewSakura" target="_blank" rel="noopener">GitHub地址</a></p><p><a href="https://gitee.com/openkit/CNblogs-Theme-NewSakura" target="_blank" rel="noopener">Gitee地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sakura </tag>
            
            <tag> 博客园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery主题美化(三)-音乐播放器</title>
      <link href="/2020/0809/"/>
      <url>/2020/0809/</url>
      
        <content type="html"><![CDATA[<h4 id="hexo-matery主题美化-三-音乐播放器"><a href="#hexo-matery主题美化-三-音乐播放器" class="headerlink" title="hexo-matery主题美化(三)-音乐播放器"></a>hexo-matery主题美化(三)-音乐播放器</h4><h5 id="配置音乐播放器"><a href="#配置音乐播放器" class="headerlink" title="配置音乐播放器"></a>配置音乐播放器</h5><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Whether to display the musics.</span><span class="token comment" spellcheck="true"># 是否在首页显示音乐.</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> 非吸底模式有效  <span class="token key atrule">show</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">autoHide</span><span class="token punctuation">:</span> <span class="token boolean important">true    </span><span class="token comment" spellcheck="true"># hide automaticaly</span>  <span class="token key atrule">server</span><span class="token punctuation">:</span> tencent   <span class="token comment" spellcheck="true">#require    music platform: netease, tencent, kugou, xiami, baidu</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> playlist    <span class="token comment" spellcheck="true">#require song, playlist, album, search, artist</span>  <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">7660234225     </span><span class="token comment" spellcheck="true">#require    song id / playlist id / album id / search keyword</span>  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">true       </span><span class="token comment" spellcheck="true"># 开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false   </span><span class="token comment" spellcheck="true"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'blue'</span>     <span class="token comment" spellcheck="true">#歌词的颜色</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span>       <span class="token comment" spellcheck="true"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'random'</span>   <span class="token comment" spellcheck="true"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span>   <span class="token comment" spellcheck="true"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7       </span><span class="token comment" spellcheck="true"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">true  </span><span class="token comment" spellcheck="true"># 列表默认折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选：<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选：<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取示例: 打开网易云音乐，选择喜欢的歌单，然后点击分享,生成插件外链</p></blockquote><p>这就是歌单的id，文件里默认设置的歌单其实也还不错。如果以后继续添加歌曲，更新了歌单，我亲自试过，<code>Aplayer</code>插件也会更新，之前的16首现在加了三首有19首。看了一些人的文章，有的人说不会更新，不知道他有没有试过。对了，如果打开博客播放器插件加载不出来，可能是网速的原因，刷新一下就好，也有可能是没配置好，多看看文章就行。</p><p>参考资料：<br><a href="https://www.cnblogs.com/mfrank/p/12830097.html#autoid-0-4-0" target="_blank" rel="noopener">弗兰克的猫-hexo-matery主题配置</a></p><p><a href="https://www.cnblogs.com/fby698/p/12663089.html" target="_blank" rel="noopener">new落花-Aplayer插件</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery主题 </tag>
            
            <tag> 音乐播放器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery主题优化(二)</title>
      <link href="/2020/0806/"/>
      <url>/2020/0806/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo-matery主题优化-二"><a href="#hexo-matery主题优化-二" class="headerlink" title="hexo-matery主题优化(二)"></a>hexo-matery主题优化(二)</h3><h4 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h4><ul><li>hexo搜索</li><li>hexo代码高亮</li><li>消除文章toc目录的那一竖杠杠</li><li>去掉友链下那不必要的一栏空白</li><li>最后</li></ul><p>前段时间，我好像写过一篇文章讲hexo-matery主题的配置优化，隔了很久，自己都忘了，应该是第一次安装主题的时候。那现在有些一篇关于这样的文章帮助大家继续增强美化自己的博客，因为本人最近也在做这件事，搭博客已经3个月了，选了喜欢的主题，却还是有一点点不满意，虽然创建主题的都是大佬，但是也有瑕疵的地方。更头疼的是，到最后也没人来告诉我们怎么把我们的博客做的漂亮一点，还是要自己来亲手改改，直接弄成博客是自己亲生的一样！到时候也能吹吹！这次不介绍太多，怕一下弄不过来，主要就讲最近接触过的。</p><h4 id="hexo搜索"><a href="#hexo搜索" class="headerlink" title="hexo搜索"></a>hexo搜索</h4><p>如果你已经做了这个搜索可以跳过，没有就一起干！过程非常可乐，呃，是非常简单！前提是使用的是hexo主题，配置了相应的环境。主题最开始弄下来是没有搜索插件的，需要下载，接下来你懂的，用npm包管理工具下载插件(如果不会用，可以搜索相应的文章看看，有需要会专门讲一下npm是何物，不会有同学还没安装好npm吧？不会吧！不会吧！)。进入到当前博客根目录下，在命令行里：</p><pre class="line-numbers language-js"><code class="language-js">npm i hexo<span class="token operator">-</span>generator<span class="token operator">-</span>search <span class="token operator">-</span>s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就这样下好了！同时需要再当前根目录配置文件中添加配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#search</span><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hexo代码高亮"><a href="#hexo代码高亮" class="headerlink" title="hexo代码高亮"></a>hexo代码高亮</h4><p>还是不要用主题里的高亮了，enable就false掉，还是同样的“骚操作”，下一个代码高亮的插件，这里用hexo-prism-matery,相同的手法下载下来后，在根目录下的配置文件里添加：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>  <span class="token comment" spellcheck="true"># preprocess/realtime</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#default false</span>  <span class="token key atrule">custom_css</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="消除文章toc目录的那一竖杠杠"><a href="#消除文章toc目录的那一竖杠杠" class="headerlink" title="消除文章toc目录的那一竖杠杠"></a>消除文章toc目录的那一竖杠杠</h4><p>修改前是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20200806121739895.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="toc那一杠"><br>如果你发现文章的toc目录有一条竖杠，不好看，那么就去掉。之前toc目录一直是这样的，我也不想要了。做博客开始的时候发现了，没太在意，终究是影响了美观。现在就要把目录弄得正常点。来到主题目录下，找到source目录，找到lib目录，里面也是一些css和js文件。其中找到tocbot文件夹，打开它的css文件，找到toc-link::before</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.toc-link</span><span class="token pseudo-element">::before</span></span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token hexcode">#EEE</span><span class="token punctuation">;</span><span class="token property">content</span><span class="token punctuation">:</span><span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>inline-block<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>inherit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*left:0;*/</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span>-<span class="token number">1</span>px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/*之前是2px*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里面可能很乱，就一两行代码，找到后将width值改成0就行了。另外解析的文章目录不完整可能是标题有些不支持：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 是否激活文章 TOC 功能，并配置TOC支持选中哪些标题类型，这是全局配置。</span><span class="token comment" spellcheck="true"># 可以在某篇文章的 Front-matter 中再加上`toc: false`，使该篇文章关闭TOC目录功能</span><span class="token key atrule">toc</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">heading</span><span class="token punctuation">:</span> h2<span class="token punctuation">,</span> h3<span class="token punctuation">,</span> h4<span class="token punctuation">,</span> h5<span class="token punctuation">,</span> h6  <span class="token comment" spellcheck="true">#选中除h1以外的标题，之前没有h6</span>  <span class="token key atrule">collapseDepth</span><span class="token punctuation">:</span> <span class="token number">0 </span><span class="token comment" spellcheck="true"># 目录默认展开层级</span>  <span class="token key atrule">showToggleBtn</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 是否显示切换TOC目录展开收缩的按钮</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="去掉友链下那不必要的一栏空白"><a href="#去掉友链下那不必要的一栏空白" class="headerlink" title="去掉友链下那不必要的一栏空白"></a>去掉友链下那不必要的一栏空白</h4><p>修改前：</p><p><img src="https://img-blog.csdnimg.cn/20200806121702255.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="空白栏"><br>这个也简单，不必过于头疼！因为我已经改好了，直接卖就是了，白给不要钱！</p><pre><code>&lt;div class=&quot;card&quot;&gt;   &lt;!--&lt;div class=&quot;card-content&quot;&gt;        &lt;%- page.content %&gt;       &lt;/div&gt;--&gt; &lt;/div&gt;</code></pre><p>友链下的那栏不必要的空白着实凸显了它的不必要性，所以我们要去掉它。直接把它的代码给注释掉，找到layout文件夹下的friends.ejs文件。hexo引擎渲染该文件生成html文件，变成了友链页面，其中友链的那一片作为一个模块卡片，valine留言板及空白一栏也是，空白的就是什么也没有，很容易发现，注释即可。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>以后还会继续更新站点，如果想看总体的效果就访问我的网站吧！最近的美化优化了很多，变化也很大！如果想深入了解就上公众号吧，<strong>小码之光</strong>，加群交流也行。后续会持续跟大家讲博客美化。</p><hr><p>公众号：小码之光</p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery </tag>
            
            <tag> 博客美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-01网络模型</title>
      <link href="/2020/0730/"/>
      <url>/2020/0730/</url>
      
        <content type="html"><![CDATA[<h4 id="计算机网络——01网络模型"><a href="#计算机网络——01网络模型" class="headerlink" title="计算机网络——01网络模型"></a>计算机网络——01网络模型</h4><h5 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h5><ol><li><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6></li><li><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6></li><li><h6 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h6></li><li><h6 id="TCP确认机制"><a href="#TCP确认机制" class="headerlink" title="TCP确认机制"></a>TCP确认机制</h6></li><li><h6 id="连接与关闭"><a href="#连接与关闭" class="headerlink" title="连接与关闭"></a>连接与关闭</h6></li><li><h6 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h6></li><li><h6 id="TCP-ISO面向连接与无连接"><a href="#TCP-ISO面向连接与无连接" class="headerlink" title="TCP/ISO面向连接与无连接"></a>TCP/ISO面向连接与无连接</h6></li><li><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6></li></ol><h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p>计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现<strong>资源共享和信息传递的计算机系统</strong>。</p><h4 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h4><p>地理范围划分是一种大家都认可的通用网络划分标准。按这种标准可以把各种网络类型划分为<strong>局域网、城域网、广域网</strong>三种。最后讲一下互联网！</p><ul><li><p><strong>局域网</strong>：（Local Area Network，LAN）  通常我们常见的“LAN”就是指局域网，这是我们最常见、应用最广的一种网络。所谓局域网，那就是在局部地区范围内的网络，它所覆盖的地区范围较小。局域网在计算机数量配置上没有太多的限制，少的可以只有两台，多的可达几百台。一般来说在企业局域网中，工作站的数量在几十到两百台次左右。在网络所涉及的地理距离上一般来说可以是几米至10公里以内。这种网络的特点就是：连接范围窄、用户数少、配置容易、连接速率高。目前局域网最快的速率要算现今的10G以太网了。IEEE的802标准委员会定义了多种主要的LAN网：以太网（Ethernet）、令牌环网（Token Ring）、光纤分布式接口网络（FDDI）、异步传输模式网（ATM）以及最新的无线局域网（WLAN）。</p></li><li><p><strong>城域网</strong>：（Metropolitan Area Network，MAN）  这种网络一般来说是在一个城市，但不在同一地理小区范围内的计算机互联。这种网络的连接距离可以在10-100公里，它采用的是IEEE802.6标准。MAN与LAN相比扩展的距离更长，连接的计算机数量更多，在地理范围上可以说是LAN网络的延伸。在一个大型城市或都市地区，一个MAN网络通常连接着多个LAN网。如连接政府机构的LAN、医院的LAN、电信的LAN、公司企业的LAN等等。</p></li><li><p><strong>广域网</strong>：(Wide Area Network，WAN）  这种网络也称为远程网，所覆盖的范围比城域网（MAN）更广，它一般是在不同城市之间的LAN或者MAN网络互联，地理范围可从几百公里到几千公里。因为距离较远，信息衰减比较严重，所以这种网络一般是要租用专线，通过IMP（接口信息处理）协议和线路连接起来，构成网状结构。这种城域网因为所连接的用户多，总出口带宽有限，所以用户的终端连接速率一般较低，通常为9.6Kbps-45Mbps 如：邮电部的CHINANET，CHINAPAC，和CHINADDN网。</p></li><li><p><strong>互联网</strong>：（internet）指的是网络之间所串连成的最大网络，这些网络以一组通用的协议相连，形成逻辑上的大型国际网络，始于1969年美国的阿帕网。通常internet泛指互联网，而<strong>Internet</strong>则特指因特网(国际互联网)。因特网于1969年诞生于美国，最初名为“阿帕网”(ARPAnet）是一个军用研究系统 ，采用TCP/IP协议，现在则已发展成为一个覆盖五大洲多个国家的开放型全球计算机网络系统。</p></li></ul><h4 id="三、网络分层"><a href="#三、网络分层" class="headerlink" title="三、网络分层"></a>三、网络分层</h4><p>为什么要分层？在计算机之间通信，主要是为了发送一些数据信息，一台计算机把数据发送出去，首先要让网络识别目的主机，能够找到它；明确目的主机是否连接网络；机子上的应用是否打开准备接收数据以及相应的异常处理。让我们去处理的话，会怎么解决这些问题呢？这里建立了两种模型：</p><p><strong>OSI七层模型</strong>：亦称OSI（Open System Interconnection）。参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。</p><p><img src="https://img-blog.csdnimg.cn/20200730171144919.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="协议栈"></p><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层:"></a>应用层:</h5><p>网络服务与最终用户的一个接口。</p><p>协议有：HTTP FTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</p><h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层:"></a>表示层:</h5><p>数据的表示、安全、压缩。</p><p>格式有，JPEG、ASCll，加密格式等</p><h5 id="会话层"><a href="#会话层" class="headerlink" title="会话层:"></a>会话层:</h5><p>建立、管理、终止会话，对应主机进程，指本地主机与远程主机正在进行的会话</p><h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层:"></a>传输层:</h5><p>定义传输数据的协议<strong>端口号</strong>，以及流控和差错校验。</p><p>协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层</p><h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层:"></a>网络层:</h5><p>网络层的主要工作是定义网络地址、区分网段、子网内MAC寻址、对于不同子网的数据包进行路由</p><p>协议有：ICMP（因特网控制报文协议）  IP（IPV4 IPV6）  ARP地址解析   Routing路由协议</p><h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层:"></a>数据链路层:</h5><p>建立逻辑连接、进行硬件地址寻址、差错校验等功能，将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p><p>协议有：Ethernet  PPP</p><h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层:"></a>物理层:</h5><p>建立、维护、断开物理连接，比特传输。</p><p><strong>TCP/IP模型</strong>：(Transmission Control Protocol / Internet Protocol，传输控制协议/网络互联协议）是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议，由IETF国际互联网工程任务组的RFC 793  定义。<br><img src="https://img-blog.csdnimg.cn/20200730171822546.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="基本五层模型"><br>TCP/IP模型合并了前三层为应用层，应用层定义了各种各样的协议来规范数据格式，常见的在HTTP的Header请求头中，分别定义了请求数据格式Accept和响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理。而链路层定义了主机的身份，即MAC地址，而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。</p><p>因为数据链路层和物理层的内容相差不多，所以在TCP/IP协议中它们被归并在网络接口层次里。只有四层体系结TCP/IP协议，与有七层体系结构的OSI相比要简单了不少，也正是这样，TCP/IP协议在实际的应用中效率更高，成本更低 。</p><p><strong>ARP协议</strong>（网络层）：</p><p>即地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下：ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p><strong>路由协议</strong>：</p><p>首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。而完成这个路由协议的物理设备就是路由器，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。 </p><h4 id="四、TCP确认机制"><a href="#四、TCP确认机制" class="headerlink" title="四、TCP确认机制"></a>四、TCP确认机制</h4><p>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 </p><ul><li>在数据正确性与合法性上，TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和；同时可以使用MD5认证对数据进行加密。</li><li>在保证可靠性上，采用超时重传和捎带确认机制。</li><li>在流量控制上，采用滑动窗口协议，协议中规定，对于窗口内未经确认的分组需要重传。</li></ul><p>在拥塞控制上，采用TCP拥塞控制算法（也称AIMD算法）。该算法主要包括四个主要部分：</p><p>（1）慢启动</p><p>每当建立一个TCP连接时或一个TCP连接发生超时重传后，该连接便进入慢启动阶段。进入慢启动后，TCP实体将拥塞窗口的大小初始化为一个报文段，此后，每收到一个报文段的确认（ACK），拥塞窗口cwnd（congestion window）按指数增加。当cwnd值超过慢启动阐值或发生报文段丢失重传时，慢启动阶段结束。前者进入拥塞避免阶段，后者重新进入慢启动阶段。</p><p>（2）拥塞避免</p><p>在慢启阶段，当cwnd值超过慢启动阐值后，慢启动过程结束，TCP连接进入拥塞避免阶段。在拥塞避免阶段，每一次发送的cwnd个报文段被完全确认后，才将cwnd值加1。在此阶段，cwnd值线性增加。</p><p>（3）快速重传</p><p>快速重传是对超时重传的改进。当源端收到对同一个报文的三个重复确认时，就确定一个报文段已经丢失，因此立刻重传丢失的报文段，而不必等到重传定时器（RTO）超时。以此减少不必要的等待时间。</p><p>（4）快速恢复</p><p>快速恢复是对丢失恢复机制的改进。在快速重传之后，不经过慢启动过程而直接进入拥塞避免阶段。每当快速重传后，置sshtesrh=cwnd/2、ewnd=ssthresh+3。此后，每收到一个重复确认，将cwnd值加1，直至收到对丢失报文段和其后若干报文段的累积确认后，置cwnd=ssthesrh，进入拥塞避免阶段。</p><h4 id="五、连接与关闭"><a href="#五、连接与关闭" class="headerlink" title="五、连接与关闭"></a>五、连接与关闭</h4><h4 id="建立连接："><a href="#建立连接：" class="headerlink" title="建立连接："></a>建立连接：</h4><p>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN同步序列编号数据包连接请求后，等待对方回答</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvMjkzODFmMzBlOTI0Yjg5OWNiMzJmNjMxNmUwNjFkOTUwYTdiZjZhOQ?x-oss-process=image/format,png" alt="图2 TCP的三次握手"><br>SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。 </p><p>TCP三次握手的过程如下：</p><ol><li>客户端发送SYN（SEQ=x序列号）报文给服务器端，进入SYN_SEND状态。</li><li>服务器端收到SYN报文，回应一个SYN （SEQ=y）+ ACK（ACK=x+1）报文，进入SYN_RECV状态。</li><li>客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入已连接状态。</li></ol><p>三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</p><h4 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止:"></a>连接终止:</h4><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手，这是由TCP的半关闭（half-close）造成的。如下图所示。 </p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ia2ltZy5jZG4uYmNlYm9zLmNvbS9waWMvYTFlYzA4ZmE1MTNkMjY5NzIxY2M4NzU0NTVmYmIyZmI0MzE2ZDg5OA?x-oss-process=image/format,png" alt="图3 TCP连接的终止"><br>（1） 某个应用进程首先调用close，称该端执行“主动关闭”。该端的TCP于是发送一个FIN结束标志数据包，表示数据发送完毕。</p><p>（2） 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认，发送ACK数据包。</p><p><strong>注意</strong>：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因此，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</p><p>（3） 此时两者之间能够继续互相发送数据包，然而一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字，这导致它的TCP也发送一个FIN。</p><p>（4） 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）ACK确认这个FIN。既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。</p><p><strong>注意</strong>：<br>当一个进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。</p><h4 id="六、TCP和UDP"><a href="#六、TCP和UDP" class="headerlink" title="六、TCP和UDP"></a>六、TCP和UDP</h4><ul><li><p>TCP 是面向<strong>连接</strong>的传输控制协议，而UDP 提供了<strong>无连接</strong>的数据报服务；</p></li><li><p>TCP 具有确认机制，确保传输数据的正确性，很少出现丢失或乱序；</p></li><li><p>UDP  在传输数据前不建立连接，不对数据报进行查改，无须等待对方的应答，会出现分组丢失、重复、乱序；</p></li><li><p>UDP 具有较好的<strong>实时性</strong>，工作效率较 TCP 协议高；</p></li><li><p>UDP 段结构比 TCP 的<strong>段结构简单</strong>，因此网络开销也小。</p></li></ul><p>TCP  协议可以保证接收端毫无差错地接收到发送端发出的字节流，为应用程序提供可靠的通信服务。对可靠性要求高的通信系统往往使用 TCP 传输数据，比如  HTTP 运用 TCP 进行数据的传输。</p><h4 id="七、TCP、ISO模型"><a href="#七、TCP、ISO模型" class="headerlink" title="七、TCP、ISO模型"></a>七、TCP、ISO模型</h4><p><strong>面向连接与无连接</strong>，面向连接可以分为三个阶段：</p><ol><li>发出链接，建立连接</li><li>连接成功才开始传输</li><li>数据传输完毕，必须释放连接</li></ol><p>无连接直接进行数据传输。<br><img src="https://img-blog.csdnimg.cn/2020073017151443.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="模型对比"><br>TCP/IP模型减少了会话层，表示层，可以变成经典5层网络模型，TCP/IP协议能够迅速发展起来并成为事实上的标准，是它恰好适应了世界范围内数据通信的需要。它有以下<br>特点：</p><p>（1）协议标准是完全开放的，可以供用户免费使用不收费。<br>（2）独立于网络硬件系统，可以运行在广域网，更适合于互联网。<br>（3）网络地址IP统一分配，网络中每一设备和终端都具有一个唯一MAC物理地址。</p><p><strong>对比</strong>：OSI层次间存在严格的调用关系，两个层通信必须通过下一层，不能越级，而TCP/IP可以越过下一层，直接使用更低层次所提供的服务，因而减少了一些不必要的开销，提高了效率；TCP/IP协议先出现，之后建立模型，而ISO/OSI先建立模型，后有协议。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>讲了这么多，那么重点在哪呢？在目录三开始的网络分层到最后的TCP/OSI模型对比，分层就记住TCP/IP经典五层模型和各层的协议就行了，其实四层的更好记住，四层无非是应用的服务层、传输层(弄端口号的)、网络层(弄网络IP地址，获取MAC地址及路由寻找的)，接口层（偏向物理的，定义MAC地址，将比特组装成帧进行发送）。有个概念就行，另外TCP确认机制(拥塞控制机制)需要掌握，以及TCP连接和断开的握手机制，还有TCP\UDP和TCP\ISO模型对比都是重点，需要掌握。</p><p>模型对比，分层就记住TCP/IP经典五层模型和各层的协议就行了，其实四层的更好记住，四层无非是应用的服务层、传输层(弄端口号的)、网络层(弄网络IP地址，获取MAC地址及路由寻找的)，接口层（偏向物理的，定义MAC地址，将比特组装成帧进行发送）。有个概念就行，另外TCP确认机制(拥塞控制机制)需要掌握，以及TCP连接和断开的握手机制，还有TCP\UDP和TCP\ISO模型对比都是重点，需要掌握。</p><p>硬核！肝完了！^  _  ^</p><hr><p>公众号：小码之光（文章全部首发）<br><a href="https://github.com/coderxm" target="_blank" rel="noopener">github</a> coderxm</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络模型 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的内部类</title>
      <link href="/2020/0728/"/>
      <url>/2020/0728/</url>
      
        <content type="html"><![CDATA[<h3 id="java中的内部类"><a href="#java中的内部类" class="headerlink" title="java中的内部类"></a>java中的内部类</h3><h4 id="一、内部类及访问特点"><a href="#一、内部类及访问特点" class="headerlink" title="一、内部类及访问特点"></a>一、内部类及访问特点</h4><p>1:内部类概述:把类定义在其他类的内部，这个类就被称为内部类。<br>    理解：内部类不需要被其他外部类调用，所以内部类定义在外部类里边，连成一块<br>2:内部类访问特点<br>    a:内部类可以直接访问外部类的成员，包括私有。<br>    b:外部类要访问内部类的成员，必须创建对象。</p><h4 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h4><p>分类：<br>    成员位置:在成员位置定义的类，被称为成员内部类（不在方法里），又分为静态和非静态<br>    局部位置:在局部位置定义的类，被称为局部内部类（在方法里）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//成员内部类</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//局部内部类</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三、成员内部类的修饰"><a href="#三、成员内部类的修饰" class="headerlink" title="三、成员内部类的修饰"></a>三、成员内部类的修饰</h4><p>成员内部类：</p><ul><li>可以被static修饰(外部类不行)</li><li>被四种访问权限修饰(public private default protected)</li><li>被abstract修饰，不能被实例化</li></ul><p><strong>私有成员内部类</strong>：对于成员内部类得私有使用，<strong>private</strong>，只能被当前类的方法访问，所以可以在外部类创建一个方法，创建内部类对象然后使用内部类方法。</p><h4 id="四、静态和非静态成员内部类及使用"><a href="#四、静态和非静态成员内部类及使用" class="headerlink" title="四、静态和非静态成员内部类及使用"></a>四、静态和非静态成员内部类及使用</h4><p>静态和非静态有什么区别呢？非静态的成员内部类，如果使用比较缸的方式创建对象的话，也是new 类名()，确实会有误解，当然我们平时实例化的时候就是这么干的，不过这里不允许。<br><img src="https://img-blog.csdnimg.cn/20200728200739425.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="非静态"></p><p>而静态成员内部类却依旧保持着原来的做法，像类访问成员一样，调用其构造器创建内部类对象，同样的如果采用非静态类的方法创建对象也不行，new ().new ()也会报错！所以各自只有唯一的方法来创建对象，以免混淆！</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//静态static内部类测试        </span>        Outer<span class="token punctuation">.</span>Inner1 oi1 <span class="token operator">=</span> <span class="token keyword">new</span>  <span class="token class-name">Outer<span class="token punctuation">.</span>Inner1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oi1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//普通内部类测试：访问内部类成员需要创建对象        </span>        Outer<span class="token punctuation">.</span>Inner2 oi2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oi2<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            oi2<span class="token punctuation">.</span><span class="token function">outereat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//另一个外部类</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Outer吃饭啊_内部类调用外部内方法测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//静态static内部类     </span>     <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner1</span><span class="token punctuation">{</span>         <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"说话啊_静态static内部类测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//普通非静态成员内部类 </span>     <span class="token keyword">class</span> <span class="token class-name">Inner2</span><span class="token punctuation">{</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inner3吃饭啊_普通内部类测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                              <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">outereat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Outer<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//内部类获取外部类成员，采用 外部类名.this.外部类成员    </span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非静态内部类获取外部类成员，采用 <strong>外部类名.this.外部类成员</strong>，外部类成员无论哪种修饰也能进行访问。但是静态的成员内部类就惨了点，它不能通过这种方法获取外部类成员。原因是Static在类加载时就已经存在了，但是对象是在创建时才在内存中生成，而this指代的是当前的对象。在静态类里使用this的话，那么this指向的是哪个对象呢？<br><img src="https://img-blog.csdnimg.cn/20200728200849656.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="静态"></p><p> 静态方法是存放在内存中的数据段里，this和super调用的是堆空间里的应用对象不能调用数据段区域里的数据，因此静态方法中不能用this和super关键字，否则会报错。那为什么要分静态和非静态呢？静态使用起来方便，符合原本的创建对象的逻辑：外部类.静态内部类；</p><p><img src="https://img-blog.csdnimg.cn/20200728200828755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="内存图"></p><h4 id="五、局部内部类及使用"><a href="#五、局部内部类及使用" class="headerlink" title="五、局部内部类及使用"></a>五、局部内部类及使用</h4><p>定义在类的<strong>方法中的类</strong>，局部内部类在访问他所在的方法中的局部变量时必须用finnal修饰，因为方法结束后就弹栈了，变量也弹出去了，但是类还在堆里，还要用到变量，所以加个finnal将变量放到方法区常量池里（<strong>jdk1.8不需要加finnal了，默认添加finnal</strong>）</p><p><strong>局部内部类</strong>：（在外部类的方法里创建内部类的对象，外部类方法才能调用内部类方法）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Outer out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//另一个类</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span><span class="token punctuation">{</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//外部类方法</span>         <span class="token keyword">int</span>  num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//内部类</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//在外部类的方法里创建内部类的对象，外部类方法才能调用内部类方法</span>        Inner i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>匿名内部类：</strong>（特殊的局部内部类，也是局部内部类的一种，必须写在方法里，本质是一个继承了该类（一般是抽象类）或者实现了该接口的子类匿名对象）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyInterface1 myInterface1 <span class="token operator">=</span> <span class="token keyword">new</span>  <span class="token class-name">MyInterface1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你真秀！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//注意这里的分号，new开始到这里是一个语句;</span>        myInterface1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//接口</span><span class="token keyword">interface</span> <span class="token class-name">MyInterface1</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里虽然有一个名字myInterface1，但它是接口对象名，不是类名。其中你可以改写成：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">new</span>  <span class="token class-name">MyInterface1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"你真秀！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//注意这里的分号，new开始到这里是一个语句;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就啥名字也没有了！可能会有警告，不过没关系，照样跑！但如果你还学过lamda表达式的话就更好了：</p><pre class="line-numbers language-Java"><code class="language-Java">((MyInterface1) () -> System.out.println("你真秀！")).show();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分号就不容易漏了，一句话解决！你真秀！</p><hr><p>公众号：小码之光（文章全部首发）<br><a href="https://index.maliaoblog.cn/" target="_blank" rel="noopener">个人网站</a>  流浪舟引导<br><a href="https://github.com/coderxm" target="_blank" rel="noopener">github</a> coderxm</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据结构介绍了解</title>
      <link href="/2020/0725/"/>
      <url>/2020/0725/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：coderxm 小码<br><strong>公众号：小码之光</strong></p></blockquote><p><strong>数据结构：反应数据之间的关系，物理或逻辑上的关系。</strong></p><p>有两个角度看数据结构：逻辑结构和存储结构。逻辑结构是指数据之间的逻辑关系，有没有联系。而存储结构才是重点，数据怎么存？存成什么样？有顺序、链式、散列存储等，不过主要研究顺序和链式存储等方式，并对他们的运算进行了解。什么是顺序和链式？其实不难理解，就是容易忘(滑稽)！两者都要从逻辑和存储上看。</p><blockquote><p>顺序结构：逻辑上是连续的，即可以通过任意一节点元素找到该数据元素；存储上，就是物理地址是也是相邻的，连在一块。比如顺序表。</p><p>链式结构：逻辑上同理；但是物理存储地址却不是连在一块的。比如线性链表。</p></blockquote><p>那不是还有线性和非线性结构吗？这个是什么角度呢？从数据的存储方式看，分为线性和非线性。线性结构或者叫线性表，指一个数据结构中的每个节点最多有一个前驱或后继(指向作用)，则为线性表，可以看作连续线状结构。非空的线性表有以下特征：</p><ul><li>只有一个前节点，或头节点，无前件。</li><li>只有一个尾节点，无后件</li><li>其他节点只有一个前件和后件</li></ul><p>那么常见的线性表有这么几个：数组、栈、队列、线性链表；而相应的非线性线性表有树、二叉树、图等等。</p><h4 id="常见数据类型介绍："><a href="#常见数据类型介绍：" class="headerlink" title="常见数据类型介绍："></a>常见数据类型介绍：</h4><p>数组：这个好理解，连续的嘛！一维数组，可以通过下标找到你，而且定义一个数组，在内存上是相邻的一块，非常符合线性表的概念。</p><p>栈：特殊一点，操作都在一端进行，这端或这头叫栈顶top，相反，另一端则为栈底bottom。如果为空的话叫空栈，特点就是：FILO(first in ,last out)</p><p><img src="https://img-blog.csdnimg.cn/20200724122128537.jpg#pic_center" alt="栈"></p><ul><li>先进后出，后进先出</li><li>插入删除操作都是在栈顶进行</li><li>不像线性表，插入删除操作不需要移动栈内其他元素</li></ul><p>插入栈内为入栈或压栈，退出为出栈或退栈，读取就是将栈顶元素读取。</p><p>队列：一端插入，另一端退出删除。遵循FIFO，先进先出。那么哪里是头？哪里是尾呢？想象一下一列火车穿过隧道，火车头先进入隧道，然后尾部(Front)后进入。所以原理类似，在队尾(Rear)进行插入，在队头进行删除。</p><p><img src="https://img-blog.csdnimg.cn/20200724122146284.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="队列"></p><p>树：非线性的，是可以分支和划分层次的，由n(n&gt;=0)个结点构成，树的结点应该满足以下条件：</p><ul><li>只有一个没前驱的节点为根</li><li>其余结点可以构成子树</li><li>没有子结点的为叶子结点，其余为分支点或内点</li></ul><p>一个结点的前件为父结点，后件为孩子结点，有子节点个数多少为度。结点中最大的度为树的度，最大的层数为树的深度。</p><p>二叉树：通常由一个结点和左右子树构成，每一个结点最多有两个子结点。</p><p>满二叉树：除最后一层外，每一层上的结点都有两个子节点，从第一层开始数到n层，第k层有2的n减一次方个结点，共2的n次方减一个结点。（国内是这么定义的，国外则不是，国外定义为一棵二叉树的结点要么是叶子结点，要么它有两个子结点）</p><p>国内：<br><img src="https://img-blog.csdnimg.cn/2020072412220835.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="满二叉树"><br>国外：<br><img src="https://img-blog.csdnimg.cn/20200724122238899.png#pic_center" alt="国际二叉树"></p><p>完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 也就是说，满二叉树一定是完全二叉树！<br><img src="https://img-blog.csdnimg.cn/20200724122334769.jpg#pic_center" alt="完全二叉树"></p><h4 id="完全二叉树的判定："><a href="#完全二叉树的判定：" class="headerlink" title="完全二叉树的判定："></a>完全二叉树的判定：</h4><p>C++代码实现(不是本人亲写)：</p><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>#include <queue>using namespace std;template <class T>struct TreeNode{    T data;    TreeNode<T> *left;    TreeNode<T> *right;    TreeNode(const T &x) : data(x),                           left(NULL),                           right(NULL) {}};template <class T>bool IsComplete(TreeNode<T> *root){    //1.树为空，返回错误    if (root == NULL) {        return false;    }    //2.树不为空    queue<TreeNode<T> *> q;    q.push(root);    while (!q.empty()){        TreeNode<T> *top = q.front();        //2.1如果该节点两个孩子都有，则直接pop        if (top->left && top->right)  {            q.pop();            q.push(top->left);            q.push(top->right);        }        //2.2如果该节点左孩子为空，右孩子不为空，则一定不是完全二叉树        if (top->left == NULL && top->right   {            return false;        }        //2.3如果该节点左孩子不为空，右孩子为空或者该节点为叶子节点，则该节点之后的所有结点都是叶子节点        if ((top->left && top->right == NULL) || (top->left == NULL && top->right == NULL)) {                      if (NULL != top->left && NULL == top->right)   {                            q.push(top->left);                            }            q.pop(); //则该节点之后的所有结点都是叶子节点            while (!q.empty()) {                top = q.front();               if (top->left == NULL && top->right == NULL)  {                    q.pop();                }                else  {                    return false;                }            }            return true;        }                                                    }                                                                return true;}                                                            //满二叉树    //       1    //   2       3    // 4    5  6   7void test1(){    TreeNode<int> *node1 = new TreeNode<int>(1);    TreeNode<int> *node2 = new TreeNode<int>(2);    TreeNode<int> *node3 = new TreeNode<int>(3);    TreeNode<int> *node4 = new TreeNode<int>(4);    TreeNode<int> *node5 = new TreeNode<int>(5);    TreeNode<int> *node6 = new TreeNode<int>(6);    TreeNode<int> *node7 = new TreeNode<int>(7);    node1->left = node2;    node1->right = node3;    node2->left = node4;    node2->right = node5;    node3->left = node6;    node3->right = node7;    cout << IsComplete<int>(node1) << endl;} //二叉树为空void test2(){    cout << IsComplete<int>(NULL) << endl;}//3.二叉树不为空，也不是满二叉树，遇到一个结点左孩子为空，右孩子不为空void test3(){    //       1    //   2       3    // 4    5      7    TreeNode<int> *node1 = new TreeNode<int>(1);    TreeNode<int> *node2 = new TreeNode<int>(2);    TreeNode<int> *node3 = new TreeNode<int>(3);    TreeNode<int> *node4 = new TreeNode<int>(4);    TreeNode<int> *node5 = new TreeNode<int>(5);    TreeNode<int> *node7 = new TreeNode<int>(7);    node1->left = node2;    node1->right = node3;    node2->left = node4;    node2->right = node5;    node3->right = node7;    cout << IsComplete<int>(node1) << endl;} //4.二叉树不为空，也不是满二叉树，遇到叶子节点,则该叶子节点之后的所有结点都为叶子节点void test4(){    //        1    //    2       3    // 4    5    TreeNode<int> *node1 = new TreeNode<int>(1);    TreeNode<int> *node2 = new TreeNode<int>(2);    TreeNode<int> *node3 = new TreeNode<int>(3);    TreeNode<int> *node4 = new TreeNode<int>(4);    TreeNode<int> *node5 = new TreeNode<int>(5);    node1->left = node2;    node1->right = node3;    node2->left = node4;    node2->right = node5;    cout << IsComplete<int>(node1) << endl;}//4.二叉树不为空，也不是满二叉树，遇到左孩子不为空，右孩子为空的结点，则该节点之后的所有结点都为叶子节点void test5(){    //        1    //    2       3    // 4    5   6    TreeNode<int> *node1 = new TreeNode<int>(1);    TreeNode<int> *node2 = new TreeNode<int>(2);    TreeNode<int> *node3 = new TreeNode<int>(3);    TreeNode<int> *node4 = new TreeNode<int>(4);    TreeNode<int> *node5 = new TreeNode<int>(5);    TreeNode<int> *node6 = new TreeNode<int>(6);    node1->left = node2;    node1->right = node3;    node2->left = node4;    node2->right = node5;    node3->left = node6;    cout << IsComplete<int>(node1) << endl;}int main(){    test1();    /*test2();*/    /*test3();*/    /*test4();*/    /*test5();*/    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/gogogo_sky/article/details/76223384" target="_blank" rel="noopener">源码连接</a>：<a href="https://blog.csdn.net/gogogo_sky/article/details/76223384" target="_blank" rel="noopener">https://blog.csdn.net/gogogo_sky/article/details/76223384</a></p><p>二叉树通常用链式存储，每一个元素则可以有两个后件，分别可以指向左右子结点，其链式结构又叫二叉链表。</p><h4 id="二叉树遍历："><a href="#二叉树遍历：" class="headerlink" title="二叉树遍历："></a>二叉树遍历：</h4><p>二叉树遍历要求不能重复访问结点，常用的有前序遍历、中序遍历、后序遍历。</p><ul><li>前序遍历Data Left Right(DLR)：先访问根节点，然后遍历左子树，最后遍历右子树</li><li>中序遍历Left Data Right(LDR)：先遍历左子树，访问根节点，最后遍历右子树</li><li>后序遍历Left Right Data(LRD)：先遍历左子树，后遍历右子树，最后访问根节点</li></ul><p>相应的文章请到<a href="https://www.cnblogs.com/du001011/p/11229170.html" target="_blank" rel="noopener">博客园二叉树</a></p><p>公众号：小码之光（文章全部首发）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opera、google、firefox浏览器的选择</title>
      <link href="/2020/0719/"/>
      <url>/2020/0719/</url>
      
        <content type="html"><![CDATA[<p>作者：coderxm<br><strong>公众号：小码之光</strong></p><hr><h5 id="首先介绍："><a href="#首先介绍：" class="headerlink" title="首先介绍："></a>首先介绍：</h5><p>先介绍本人用的最多的浏览器：火狐</p><p>Mozilla Firefox，中文俗称“火狐”，是一个自由及开放源代码的浏览器，使用Gecko排版引擎，支持多种操作系统，如Windows、Mac OS及GNU/Linux等。该浏览器提供了两种版本，普通版和ESR延长支持版，ESR版本是 Mozilla 专门为那些无法或不愿每隔几周就升级一次的企业打造。Firefox  ESR 版的升级周期为 12 个月，而普通 Firefox 的升级周期为 4  周。由于该浏览器开放了源代码，因此还有一些第三方编译版供使用，如pcxFirefox、苍月浏览器、tete009等。</p><p><img src="https://img-blog.csdnimg.cn/20200719173503451.JPG" alt="百度"></p><p>简洁！使用火狐后，弹窗广告没了，乱七八糟的推送消失了，什么贪玩蓝月和黑网站链接都跟我拜拜了！使用起来还是非常舒适的，而且可以设置保护级别，拦截跟踪，加强反网络监视等等，尊重个人隐私，一些无证书认证的网址是有警告阻止页面的拦截的，很安全！当然不是说绝对的安全，有些墙缝里的黑角落还是有不好的网址的，首先体现在使用了百度搜索引擎之后，就有这个现象，不难看出某度引擎的强大之处。真是什么都能搜过来！</p><h5 id="接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器"><a href="#接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器" class="headerlink" title="接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器"></a>接下来介绍google：一款在中国爆胎的搜索引擎和它的chrome浏览器</h5><p>为什么会爆胎呢？在google chrome里搜索几乎等于在网址栏里搜索，所以只是输入关键字是不能搜索的，除非换成其他搜索引擎，比如必应或某度。一般在里面搜索关键字后往往得到如下回应：</p><p><img src="https://img-blog.csdnimg.cn/20200719173532541.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="google"></p><p>谷歌公司（Google Inc.）成立于1998年9月4日，由拉里·佩奇和谢尔盖·布林共同创建，被认为是全球最大的搜索引擎公司。 2010年3月23日，谷歌高级副总裁、首席法律官大卫·德拉蒙德公开发表声明，宣布谷歌关闭在中国大陆市场搜索服务，并将搜索服务由中国内地转至香港。随之，某度当之无愧完全成为第一大搜索引擎公司。</p><p>内核是谷歌自己开发的chrome V8引擎，双内核，不过是谷歌自己用c++研发的，打开网页确实快，但是耗CPU，某种程度上是依托硬件来加速页面的渲染。就chrome的应用文件占500多M，耗内存不是太明显，和火狐差不多。</p><p>不过耗CPU的问题，这里顺便就解决一下，在google的设置里下拉，找到高级，打开找到硬件加速关闭即可。</p><p><img src="https://img-blog.csdnimg.cn/20200719174004917.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="关闭加速"></p><p>应该就老实了吧！记得别加载太多动态页面就行了，很耗CPU的。</p><p><img src="https://img-blog.csdnimg.cn/20200719174037850.JPG#pic_center" alt="google后台消耗"></p><h5 id="其次是用的少的：opera浏览器"><a href="#其次是用的少的：opera浏览器" class="headerlink" title="其次是用的少的：opera浏览器"></a>其次是用的少的：opera浏览器</h5><p>Opera(奥普拉)浏览器，是一款挪威Opera Software ASA公司制作的支持多页面标签式浏览的网络浏览器，是跨平台浏览器可以在Windows、Mac和Linux三个操作系统平台上运行，创始人谭永文创始于1995年4月，中文名就这样。 </p><p>Presto是由Opera Software开发的浏览器排版引擎，Opera 7.0及以上使用。有拦截、标签式浏览、快速拨号(快速拨号就是可以帮助用户将自己最常访问的多个网站，依次设入“拨号面板”中，而这些网站是以缩略图形式展现出来直观明了。然后，每次启动Opera时，便可以通过这个面板，快速打开相应的网站)等待一系列功能。VPN应该也行吧，没用过该功能！</p><p>相比国内某361、222、23957乱七八槽的浏览器，奥普拉干净了不少！也算是老浏览器了，不过国内知名度并不高。有许多特性是opera首创的！同样的跨平台，同样有手机浏览器应用，支持主题更换(暗黑模式)，支持许多扩展功能。不过占内存比较大一点！多了几百M。不过2016年，挪威浏览器厂商 Opera发布公告，宣布了确定被 360 和昆仑万维收购。出价 105 亿挪威克朗（约合 81 亿人民币）收购的，所以，你懂的！</p><hr><h5 id="浏览器与搜索引擎的搭配"><a href="#浏览器与搜索引擎的搭配" class="headerlink" title="浏览器与搜索引擎的搭配"></a>浏览器与搜索引擎的搭配</h5><p>浏览器是浏览器，搜索引擎是搜索引擎，两个是不一样的，一般浏览器都会内置几种搜索引擎供选择，包括Google chrome。</p><p><img src="https://img-blog.csdnimg.cn/20200719174237343.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="内置搜索"></p><p>如果不使用google搜索引擎，就享受不到它的快速，但是国内有没有服务。百度又是国内最大的搜索引擎，搜到的结果是一大堆没用的。比如下图：<br><img src="https://img-blog.csdnimg.cn/20200719174328667.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="广告"></p><p>还有右边的百度热搜，无尽广告等等！另外其他的国外引擎就不行了，要么是进不来国内，要么是搜索结果偏差！这里建议使用微软的必应Bing搜索，虽然没什么花里胡哨的东西，没有热搜榜，但绝对是搜得到匹配的东西！有搜索级别限制，在国内按照相关的规定已默认设置为严格搜索，不能更改了，即使有黑网站链接，但是会拦截过滤掉，也就是说这样的网址是打不开的，环境还是相当好的，墙裂推荐，匹配相关性杠杠的！</p><p><img src="https://img-blog.csdnimg.cn/20200719174406709.JPG#pic_center" alt="必应"></p><blockquote><p>作为一种在线搜索引擎，必应的主要目标是将互联网上相关性最强的搜索结果呈现给用户，从而让用户轻松访问互联网发布者发布的高质量内容。为此，必应会自动抓取互联网内容，为新页面和更新页面（或  URL）建立索引，以便在用户发起搜索或执行操作时显示一组相关的搜索结果。这些页面的内容可能会引用或含有各种在线资源和内容，包括网站、图像、视频、文档以及其他项目。搜索结果是使用计算机算法生成的，即由算法将您输入的搜索词与我们索引中的结果加以匹配，然后据此生成搜索结果。通常情况下，我们尝试尽量全面且有帮助地提供一批显示的搜索结果。我们会设计并不断改进我们的算法，确保提供最相关、最有用的结果。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200719174751969.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="严格搜索"><br>作为一项以算法驱动的服务，必应不会控制编入索引的网站的运营或设计，也不会控制这些网站发布的内容。只要这些网站继续在网页上以及向爬网程序提供信息，通常就可以通过必应或其他搜索引擎获得这些信息。所以还等什么，用起来！</p><hr><p>公众号：小码之光（文章全部首发）</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互质环与最小公倍数的几种求法</title>
      <link href="/2020/0709/"/>
      <url>/2020/0709/</url>
      
        <content type="html"><![CDATA[<h3 id="互质环-序列-与最小公倍数的几种求法"><a href="#互质环-序列-与最小公倍数的几种求法" class="headerlink" title="互质环(序列)与最小公倍数的几种求法"></a>互质环(序列)与最小公倍数的几种求法</h3><h4 id="题目一：互质环"><a href="#题目一：互质环" class="headerlink" title="题目一：互质环"></a>题目一：互质环</h4><p>现在我们要把1…n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多，请输出最大对数.</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><pre><code>一行一个整数n(1≤ n≤ 1000)。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h5><pre><code>一行一个整数表示答案。</code></pre><h5 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h5><pre><code>4</code></pre><h5 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h5><pre><code>4    例：3 2 1 4</code></pre><p>很显然，又是个把做题的的同学(小白)弄得晕头的题，实质上她还是个数学题，就看你数学学的好不好了，呵呵！既然相邻的两个数要互质(除了公因子1外没有其他公因数)，那从小到大顺序排序怎么样！好，试一下：1 2 3 4，也是两两互质，对数为4。是不是巧合呢？大家都知道相邻两数(整数)互质，那么怎么说明是确实是一定互质呢?</p><h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>转化一下，相邻两数：n-1, n(n&gt;1)，我们用反证法证明一下。</p><pre><code>预设结论：这两数不互质，即有除1以外的公因数k，n-1=x·k，n=y·k；那么有n-(n-1)=(y-x)k=1，k=1/(y-x)；y,x,k都是整数，k&gt;1,则1&gt;y-x，不符合！所以相邻两数互质！证明就完了。</code></pre><p>所以结论就是输入几个数就输出几个数，就能构造互质环(互质对数最多的，两两互质)。</p><hr><h4 id="题目二：最小公倍数"><a href="#题目二：最小公倍数" class="headerlink" title="题目二：最小公倍数"></a>题目二：最小公倍数</h4><p>有人说求最小公倍数不很简单吗？我想说的是，你是用那种方法求得，而且算法复杂度小，效率高吗？现在我们就现场讨论一波！</p><p>最小公倍数=两整数的乘积÷最大公约数 。 所以该问题可以转化为求最大公约数。而最大公约数有这几种求法：</p><ol><li><h4 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法 :"></a>辗转相除法 :</h4><p>1.a%b得余数c</p><p>2.如果c = 0,则b为最大公约数</p><p>3.如果c不等于0,则a = b,b = c继续执行步骤1。</p><pre><code>#include&lt;iostream&gt;using namespace std;long long lcm(long long x, long long y){    long long maxs = max(x,y);    long long mins = min(x,y);    long long t = maxs % mins;    while(t != 0){        maxs = mins;        mins = t;        t = maxs % mins;    }    return x * y/mins;}int main(){    long long x, y;        //x,y很大    cin &gt;&gt; x &gt;&gt; y;    cout&lt;&lt;lcm(x,y)&lt;&lt;endl;    return 0;}</code></pre><p>最优算法，t最快接近最大公约数，因为是进行求模运算，所以比相减来得更快。T(n)应该是接近常数级，S(n)的话，由于lcm函数中进行了maxs,mins赋值，空间复杂度降低，和相减法差不多。</p></li></ol><h4 id="2-相减法"><a href="#2-相减法" class="headerlink" title="2 .相减法:"></a>2 .相减法:</h4><p>   两数之差与最大公约数成倍数关系。</p><pre><code>1.若a&gt;b，则a=a-b2.若a &lt; b，则b=b-a3. 若a=b，则a（或b）即为两数的最大公约数4. 若a≠b，则再回去执行1</code></pre><pre><code>#include&lt;stdio.h&gt;int main ( )  /* 相减法求最大公约数 */{     int m, n, a, b, c;   scanf (&quot;%d,%d&quot;, &amp;a, &amp;b);   m=a; n=b;      /* a, b不相等，大数减小数，直到相等为止。*/    while ( a!=b) {         if (a&gt;b)  a=a-b;         else  b=b-a;    }   printf(&quot;The largest common divisor:%d\n&quot;, a); //最大公约数   printf(&quot;The least common multiple:%d\n&quot;, m*n/a);    //最小公倍数}</code></pre><p>T(n)与第一种相比，当两个数比较大时，而且仅相差较小的数，循环需要a=b相等才结束，所以T(n)这时会比较大。</p><h4 id="3-枚举法："><a href="#3-枚举法：" class="headerlink" title="3.枚举法："></a>3.枚举法：</h4><p> 已知1是一个公约数，但是1不是最大公约数，所以可以检测K=2,3,4…..是否为x和y的公约数，直到k大于x或者y，将公约数存储在gcd的变量中,gcd初值设为1</p><pre><code>int gcd = 1;for(int k = 2;k &lt;= x&amp;&amp;k &lt;= y;k++){    if(x % k == 0&amp;&amp; y % k == 0)        gcd = k;}</code></pre><p>当问题规模很大时，这个算法最不好，还是从小到大枚举，T(n)就很大了，k需要不断被自加1赋值，还要判断取模等等，循环次数过多。</p><hr><p>今天的算法分享就完了，任务结束，别忘了点赞！hh！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互质 </tag>
            
            <tag> 最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年轻母牛的故事</title>
      <link href="/2020/0708/"/>
      <url>/2020/0708/</url>
      
        <content type="html"><![CDATA[<h3 id="年轻母牛的故事"><a href="#年轻母牛的故事" class="headerlink" title="年轻母牛的故事"></a>年轻母牛的故事</h3><h4 id="题目是这样的："><a href="#题目是这样的：" class="headerlink" title="题目是这样的："></a>题目是这样的：</h4><p>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>​    输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br> n=0表示输入数据的结束，不做处理。 </p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>​    对于每个测试实例，输出在第n年的时候母牛的数量。<br> 每个输出占一行。 </p><p>题目非常简洁，不知道是不是歪果仁想的题，我猜它的英文版是这样的：</p><p>There is a cow, which gives birth to a heifer at the beginning of each  year. Each heifer starts from the fourth year, and a heifer is also born at the beginning of each year. Please program how many cows are there  in the nth year?</p><p>母牛特别能生，4年就发育成熟，就能生！问第几年有多少头母牛？哎呀，对于一个刚入门的新手来说，要想解决这个题，确实很费劲了(很烧脑)！只能感叹：这公牛的后宫不久就壮大了！牛批！而老手一眼看穿规律，就有了思路。那么老手是怎么看穿的呢？</p><p>从数学角度看，这个母牛数目增长还是有一定的规律的，所以我们需要把每一年的母牛的数目清点一下，这个时候，数学基础就暴露出来了，第几年多少头牛都点不清，这还是小学问题，就是个点数题！注意题目描述！</p><p>第一年：1头</p><p>第二年：2头</p><p>第三年：3头</p><p>第四年：4头</p><p>第五年：6头</p><p>第六年：9头</p><p>OK，我相信你数学非常好，很快就能发现规律。归结为一个数学题：设第n年的母牛头数为a[n]，则可以得出一个·递推公式：</p><p>​    a[n] = a[n-1] + a[n-3]；</p><p>可以验证一波，没问题了就可以撸代码了，这里提供了java和c++版的代码题解，如果测试出现翻车概不负责！请注意！</p><p>Java版(我写的)：</p><pre><code>import java.util.Scanner;public class Main{    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        int[] a = new int[60];        a[0] = 0;        a[1] = 1;        a[2] = 2;        a[3] = 3;        a[4] = 4;        for(int i=5;i&lt;=55;i++){            a[i] = a[i-3] + a[i-1]; //递推填充数组        }        while (scanner.hasNextInt()) {      //等待输入            int num = scanner.nextInt();            if(num==0){             //判断是否为0                break;            }            System.out.println(a[num]);        }    }}</code></pre><p>c++版：</p><pre><code>#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(){    int t , a[60];    a[1] = 1 ;    a[2] = 2;    a[3] = 3;    a[4] = 4;    for(int i = 5 ; i &lt; 60 ; i ++)    {        a[i] = a[i-1] + a[i-3];    }    while(~scanf(&quot;%d&quot;,&amp;t) &amp;&amp; t)    cout&lt;&lt;a[t]&lt;&lt;endl;    return 0 ;}</code></pre><p>hh,如果真有问题公众号交流，加群也行！以学习为首要！</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对比两个代码版本，其实也没差多少，核心代码几乎相同，在算法上完全是一模一样！所以说算法在任何情况下都是通用的，每一种算法都可以解答一种题目，很有逻辑性。另外还涉及到数学的思想，有些特别简单，比如这个数学递推公式，这就结合数学来解算法题了！遇到这样的题目算是很有趣了，一般都有规律可循，只不过需要花点时间。OK，我是小码，一个会发光的准程序员！下期再见！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的复杂度</title>
      <link href="/2020/0705/"/>
      <url>/2020/0705/</url>
      
        <content type="html"><![CDATA[<h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3><blockquote><p><strong>前言</strong>：本人并非所谓的大佬，蒟蒻一枚，写文章的目的主要就是这么几个。一个是为了总结昨天学习的知识，巩固于心；二是将所学的整理起来，也方便以后备用查阅；第三个是可以给其他的有需要的人看，也可以一起学习进步，有必要还可以提建议！总之比没写强吧！缸巴咧！</p></blockquote><p>评判一个程序的好坏通常有几个标准，按照程序的运行效率和代码的可读性以及代码的美观性几个方面看，而最主要的方面不过效率和可读性。可读性没什么好说了，作为团队中的那一个蒟蒻，当然没啥高深的算法描述了。最后就看效率了，效率上可分为运行时间和所需空间大小两个方面入手，数据结构上可专业的称为算法的时间复杂度和空间复杂度。接下来就进入重点了，如何评测一个程序的时间和空间复杂度？</p><hr><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>这里又引入一个专业词：时间开销T，通俗点讲就是所花的时间；问题规模n，可以看作是代码基本语句的执行数量(可以被重复执行)。很显然，时间开销和问题规模n有关，记作T(n)。</p><pre><code>(1)    T(n) = 3n + 3 -&gt; o(f(n)) = n ，[f(n)的高阶无穷小，即n趋于无穷是等于它](2)    T(n) = n^3 + n +9990  -&gt; o(f(n)) = n^3 [同理趋于无穷接近]</code></pre><p>上述式子，省略了常数，那意味着当问题规模很大时，只需要计算一些循环的基本语句的执行次数就行了。</p><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>当(1)与(2)式相加时，效果还是一样，求出其高阶无穷小，简单方法就是去掉低阶项，保留高阶项。</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>既然都相乘了，就不好意思去掉其中任意一个了，所以吧两个高阶无穷小相乘即可。</p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><pre><code>void test(int k[],int n){    //n为数组长度    printf(&quot;I am Tiga\n&quot;);    for(int i=0;i&lt;n;i++){        if(k[i]==n){            printf(&quot;I am light %d\n&quot;,n);            break;        }    }}</code></pre><p>就源码分析来看，入口的参数有两个，一个数组k[ ]，一个整数n。而这个函数的作用在于判断数组k[ ]中是否有整数n,如果有则输出并结束。然而它的时间复杂度不是唯一确定的，需要分情况。最好情况是，数组第一个就是n，那很快就结束了，执行基本语句量为常数，记为T(n) = o(1);最坏情况是，需要找到最后一个n，根据上面的结论可得出，T(n) = o(n)，进而可以求平均时间复杂度。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度就相对理解起来更容易些，因为空间复杂度很少受问题规模的影响。</p><pre><code>void test(int n){    int k = 3;    if(k==n){        printf(&quot;Yes,Thanks!\n&quot;);    }}</code></pre><p>上述代码几乎可以算出所需内存空间大小，如果int整形为4个字节，那么总共需要8个字节，则可以表达为S(n) =o(1)，即常数级大小，那么这样典型的不受问题规模影响的空间复杂度情况就称作算法原地工作。如果受问题规模影响也能举出例子：</p><pre><code>void test(int n){    int k[n];    k[0] = 1;    printf(&quot;Yes,Thanks %d!\n&quot;,k[0]);}</code></pre><p>这个例子就简单又生动了，问题规模影响了空间复杂度，使它不唯一，则可以表示为S(n)= o(n)。</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>算法复杂度这两个方面就写完了，其实也并不复杂，复杂的还在后面。至少了解了一下算法好坏的判断标准，有助于以后写出更好的程序：执行时间少，占用空间小，效率高，美观，可读性好的程序！</p><p>一起学习，一起成长，欢迎关注本人公众号<strong>小码之光</strong>，一个会发光的准程序员！</p><p><a href="https://github.com/coderxm/" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>halo开源博客</title>
      <link href="/2020/0702/"/>
      <url>/2020/0702/</url>
      
        <content type="html"><![CDATA[<h2 id="Halo开源博客项目配置"><a href="#Halo开源博客项目配置" class="headerlink" title="Halo开源博客项目配置"></a>Halo开源博客项目配置</h2><h3 id="README"><a href="#README" class="headerlink" title="README"></a>README</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>Halo</strong> <code>[ˈheɪloʊ]</code>，意为光环。Halo 是一款现代化的个人独立博客系统，给习惯写博客的同学多一个选择。当然，你也可以当成拼音读(哈喽)。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><blockquote><p>本项目旨在创造一个好的产品以供人们使用（虽然现在并不是太好），并非一个所谓提供学习的项目。所以，不提供任何学习代码的帮助。也请不要在讨论群，issues，论坛发起任何有关代码学习的问题。当然，如果你是要参与代码贡献，我们非常欢迎。</p></blockquote><p>另外，写给想自己拉代码编译运行的同学：</p><blockquote><p>目前我们的开发分支即 master，肯定会有很多小问题，不要运行不起来就跑过来吐槽什么代码开源不完整之类的，多找找自己的原因。同时建议下载最新 release 版本的代码，或者在 master 分支执行 <code>git checkout v1.3.2</code>。</p></blockquote><p>PS：实在不想写这个声明（影响 README 的美观），但是就目前来看，写在 README 上是有必要的，因为大部分遇到问题的人都不会去仔细阅读文档。</p><h4 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h4><h5 id="下载最新的-Halo-安装包"><a href="#下载最新的-Halo-安装包" class="headerlink" title="下载最新的 Halo 安装包"></a>下载最新的 Halo 安装包</h5><blockquote><p>其他地址：<a href="https://halo.run/archives/download.html" target="_blank" rel="noopener">https://halo.run/archives/download.html</a></p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">curl -L https://github.com/halo-dev/halo/releases/download/v1.3.2/halo-1.3.2.jar --output halo-latest.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre><code>wget https://github.com/halo-dev/halo/releases/download/v1.3.2/halo-1.3.2.jar -O halo-latest.jar</code></pre><h5 id="启动-Halo"><a href="#启动-Halo" class="headerlink" title="启动 Halo"></a>启动 Halo</h5><pre class="line-numbers language-bash"><code class="language-bash">java -jar halo-latest.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>详细部署文档请移步：<a href="https://halo.run/archives/install-quick-start.html" target="_blank" rel="noopener">https://halo.run/archives/install-quick-start.html</a></p><h5 id="博客示例"><a href="#博客示例" class="headerlink" title="博客示例"></a>博客示例</h5><p>请移步： <a href="https://halo.run/p/user-wall.html" target="_blank" rel="noopener">https://halo.run/p/user-wall.html</a>。</p><h4 id="周边"><a href="#周边" class="headerlink" title="周边"></a>周边</h4><ul><li>后台管理（halo-admin）：<a href="https://github.com/halo-dev/halo-admin" target="_blank" rel="noopener">https://github.com/halo-dev/halo-admin</a></li><li>独立评论模块（halo-comment）：<a href="https://github.com/halo-dev/halo-comment" target="_blank" rel="noopener">https://github.com/halo-dev/halo-comment</a></li><li>管理 APP（已停止维护）：<a href="https://github.com/halo-dev/halo-app" target="_blank" rel="noopener">https://github.com/halo-dev/halo-app</a></li><li>主题仓库：<a href="https://halo.run/p/themes.html" target="_blank" rel="noopener">https://halo.run/p/themes.html</a></li><li>资源下载：<a href="https://dl.halo.run" target="_blank" rel="noopener">https://dl.halo.run</a></li><li>WeHalo 小程序：<a href="https://github.com/aquanlerou/WeHalo" target="_blank" rel="noopener">https://github.com/aquanlerou/WeHalo</a></li></ul><hr><p><strong>启动项目前配置</strong></p><p>项目为gradle项目，项目依赖文档配置在build.gradle,开始前确保能自动导入依赖，导入需要花费一些时间。之后可以进行具体的配置，如数据库的配置，找到文件application.yaml文件。<br><img src="https://img-blog.csdnimg.cn/20200702102932816.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="项目结构"></p><p>将h2数据库的enabled和web-allow-others改为<strong>true</strong><br><img src="https://img-blog.csdnimg.cn/20200702103019124.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="数据库配置"></p><p>差不多就可以启动整个项目了，怎么启动呢？之前已经有经验了吧，介绍了一个eladmin后台管理系统的项目，难度或者复杂度比这个大一点，其中就讲了具体的项目的启动配置。找到项目中唯一能运行的源代码文件，一般在源代码文档src/main/java里面，找到它，命名一般是AppRun或ApplicationRun或者Application的Java文件，打开能看到有main()函数的，就是项目启动文件。IDEA会自动找到可运行的启动文件，并打开绿色小三角按钮，点击小三角启动它！<br><img src="https://img-blog.csdnimg.cn/20200702103304505.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="小三角启动"><br>可以看到左下角项目在编译运行。<br><img src="https://img-blog.csdnimg.cn/20200702103054697.PNG#pic_center" alt="启动标志"><br>启动后没有乱码和红色报错，说明配置对了。<br><img src="https://img-blog.csdnimg.cn/20200702103122874.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="启动成功"><br><img src="https://img-blog.csdnimg.cn/20200702103132613.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="启动成功"></p><p>如果出现乱码的情况，说明编译的时候没有配置好，而编码需要的是UTF-8，找到项目的依赖配置文件build.gradle,添加如下配置。</p><pre><code>tasks.withType(JavaCompile) {    options.encoding = &#39;UTF-8&#39;}</code></pre><p>如果出现红色报错，说明有其他配置问题，很大原因是导入依赖不成功，受到了网速影响，需要重新导入模块。还有问题请加群交流，这里不做详细的解释！</p><h4 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDkvMTEvSXUxZU16WkRnNmZydzk3LnBuZw?x-oss-process=image/format,png" alt="install.png"><br>这个halo博客后台支持markdown语法的编辑，对写博客非常友好！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDkvMTEvdWNEaDJ0T1pMSkdUeUhYLnBuZw?x-oss-process=image/format,png" alt="admin-post-edit.png"></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对比其他博客框架，halo博客是一个动态的博客系统，有前端，有后台，可以自己买个服务器搭一搭。而其他的开源博客，有一部分是没有后台的，修改上传文章主要在线下完成，所以维护起来十分费劲。如果可以的话还可以动手改halo的样式，halo也有其他主题样式供选择。OK，以上就是简单的玩一玩开源项目，具体大家可自行研究，有问题或探讨可以关注我公众号加群！<br>公众号：小码之光<br>博客园：coderxm</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA报错稀有问题</title>
      <link href="/2020/0626/"/>
      <url>/2020/0626/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA报错稀有语法问题"><a href="#IDEA报错稀有语法问题" class="headerlink" title="IDEA报错稀有语法问题"></a><strong>IDEA报错稀有语法问题</strong></h3><hr><blockquote><p>Error:java: Compilation failed: internal java compiler error;</p><p>Error:java需要”;”<br><img src="https://img-blog.csdnimg.cn/20200626115209953.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="报错"></p></blockquote><p>这种报错不知道大家见过没有，可能一般人不会出现这种编译错误。实际上它的错误是红色的那个”Erroe:java:需要”;” “,但是仔细检查正在编辑的代码，一点语法错误都没有，IDEA也没说哪里出问题了。于是又陷入了长久以来的僵局——百度！</p><hr><h3 id="百度的结果"><a href="#百度的结果" class="headerlink" title="百度的结果"></a>百度的结果</h3><p>结果说是jdk版本没配置好，我信了，又屁颠屁颠的改版本，原来是jdk8呀，现在也是。步骤如下：</p><p><img src="https://img-blog.csdnimg.cn/20200626115249713.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="module"><br><img src="https://img-blog.csdnimg.cn/20200626115312144.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="project"><br><img src="https://img-blog.csdnimg.cn/20200626115342760.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="java compiler"></p><hr><h5 id="百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西"><a href="#百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西" class="headerlink" title="百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西"></a>百度结果的特点就是，搜出来一大堆相类似的东西，而你要的却是另外一个东西</h5><p>所以我放弃百度的搜索，改用经典的eclipse进行编辑，在导入文件夹时，没运行就发现了语法错误，然而eclipse给我报错是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20200626115425299.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="eclipse报错"></p><p>很清楚的给我错的地方！但是反过来看，IDEA自称最智能的编辑器，有时候还是像智障编辑器，eclipse虽然皮肤不好看，但是依旧经典。ok，我回到IDEA智障编辑器里了，这里的问题应该就不难弄懂了，还是过不去的语法问题，出错在另一个文件里。</p><p><img src="https://img-blog.csdnimg.cn/20200626115516956.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="修改错误"><br>改回来之后就行了，就能运行程序了。</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>IDEA报错有时让人摸不着头脑，还告诉你错在何处，接着错上加错，虚度光阴，罪恶之极！总结下来的原因就是，像IDEA编辑文件都是以项目文件进行编辑的，如果一个文件出语法错误，另一个文件(整个项目源码文件)都会受牵连，就会编译不过去。尽管这样，IDEA还是不告诉哪里有语法错误，建议在实际项目用eclipse进行编辑。管他香不香，用的舒服就好！</p><hr><p>更多问题关注我的公众号：小码之光，<strong>文章将在公众号首发</strong>！<br>最后附上：<br><a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码CSDN</a><br><a href="https://www.cnblogs.com/coderma/" target="_blank" rel="noopener">博客园</a><br>微信公众号：小码之光<br><img src="https://img-blog.csdnimg.cn/20200626115852678.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你跑一个开源项目</title>
      <link href="/2020/0531/"/>
      <url>/2020/0531/</url>
      
        <content type="html"><![CDATA[<h3 id="带你跑ELADMIN后台管理系统开源项目"><a href="#带你跑ELADMIN后台管理系统开源项目" class="headerlink" title="带你跑ELADMIN后台管理系统开源项目"></a>带你跑ELADMIN后台管理系统开源项目</h3><hr><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><p>最近开始稍微接触了点框架，本来是想学点开源项目什么的，但学起来耗得时间长，所以公众号和博客的文章都慢慢的停更了许久。之前的java多线程和反射都还没弄透，更别说java源码和JVM了，学习这件事真的需要坚持、耐心和不断总结 。github上满是开源项目，建议找一个适合的项目练练，看看它用到的技术，一个个吃透了，以后用到相同的技术就越发熟练，看代码如同行云流水，毫不费劲。今天就推荐一个十分火爆的开源项目el-admin后台管理系统，结合前端Vue使用 ，是一个不错的开胃菜。</p><hr><h5 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h5><p>一个基于 Spring Boot 2.1.0 、 Spring Boot Jpa、 JWT、Spring Security、Redis、Vue的前后端分离的后台管理系统</p><p>开发文档： <a href="https://docs.auauz.net/" target="_blank" rel="noopener">https://docs.auauz.net/</a><br>体验地址： <a href="https://auauz.net/" target="_blank" rel="noopener">https://auauz.net/</a></p><p>账号密码： <code>admin/123456</code> (默认密码都是123456)</p><table><thead><tr><th></th><th align="center">后端源码</th><th align="center">前端源码</th></tr></thead><tbody><tr><td>github</td><td align="center"><a href="https://github.com/elunez/eladmin" target="_blank" rel="noopener">https://github.com/elunez/eladmin</a></td><td align="center"><a href="https://github.com/elunez/eladmin-web" target="_blank" rel="noopener">https://github.com/elunez/eladmin-web</a></td></tr><tr><td>码云</td><td align="center"><a href="https://gitee.com/elunez/eladmin" target="_blank" rel="noopener">https://gitee.com/elunez/eladmin</a></td><td align="center"><a href="https://gitee.com/elunez/eladmin-web" target="_blank" rel="noopener">https://gitee.com/elunez/eladmin-web</a></td></tr></tbody></table><p>这是用流行框架spring boot和vue实现的前后端分离的后台管理系统，不要被前后端分离吓到了，只是前后端的代码放在不同的地方而已，没有什么特别重要的技术难点。</p><hr><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p>上面已经给出了项目的源码，把前后端的源码下下来就行了，之后要准备什么呢？当然是准备跑项目的环境了，可以分为前端和后端的运行环境。在项目里，是需要后端的，所以先配置后端环境。那我们如何知道应该配好怎样的环境呢？看github项目的介绍，README文档里面也有介绍，以后可以直接看README就行了。既然是个Java项目，当然应该有Java的环境啦，这个可以直接用IDEA代替，社区版的也行，项目的文件就用IDEA打开就是了。</p><hr><h5 id="Redis数据库安装配置"><a href="#Redis数据库安装配置" class="headerlink" title="Redis数据库安装配置"></a>Redis数据库安装配置</h5><p>如果没有，可在公众号内回复<strong>redis</strong>获取。下载好后，应首先配置它的环境变量。分别打开redis-servr.exe和redis-cli.exe，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531093506213.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="redis">)<img src="https://img-blog.csdnimg.cn/20200531093545795.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="redis启动"></p><hr><h5 id="mysql配置"><a href="#mysql配置" class="headerlink" title="mysql配置"></a>mysql配置</h5><p>项目里的eladmin.sql文件为MySQL启动脚本，了解后，并不是双击运行。前提应该有mysql和数据库管理器吧，没有mysql可以在公众号内的软件工具哪里找，应该有，记得配置环境变量。另外管理工具就别用SQL Server了，sqlyog也不错，官网有社区版的，就下的慢，推荐链接：<a href="https://pan.baidu.com/s/1PcVVkucLRf-49lHDPl6syA" target="_blank" rel="noopener">https://pan.baidu.com/s/1PcVVkucLRf-49lHDPl6syA</a> 提取码：w27i 。先建一个项目数据库。</p><p><img src="https://img-blog.csdnimg.cn/2020053110421664.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="创建数据库"></p><p>接着用记事本或其他打开项目sql脚本，全选粘贴在询问一栏，并再次全选右键执行查询或摁F9。</p><p><img src="https://img-blog.csdnimg.cn/20200531093646199.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="sql查询"><br>结果没报错即可，都不要关闭这些。</p><hr><h5 id="后台spring"><a href="#后台spring" class="headerlink" title="后台spring"></a>后台spring</h5><p>如果没有还有spring这个框架，不用太担心，这样大部分是框架依赖，所以交给IDEA去干就行了，前提是别把网断了，需要下依赖包。如何让IDEA自动下呢？在文件那点击setting设置，在Build,Execute那的Maven选项。</p><p><img src="https://img-blog.csdnimg.cn/20200531093753426.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="导入依赖"><strong>自动导入Maven项目</strong></p><p><img src="https://img-blog.csdnimg.cn/20200531093822889.PNG#pic_center" alt="mport-ij"></p><p><img src="https://img-blog.csdnimg.cn/20200531094000871.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字节码版本"><br>上图把编译器生成的字节码类型改为和jdk相同版本，我这里用jdk11编译，不然会报“不支持java 5版本，请使用6及以上版本”。更具体的操作可以自己搜索解决，比较简单。同样在项目的配置文件pom.xml里，需要添加相应的依赖属性。</p><blockquote><p><properties> //添加下面几个，如果没有就加上去<br>        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br>        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;<br>        &lt;java.version&gt;11&lt;/java.version&gt;<br>        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;<br>        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; </properties></p></blockquote><p>这时候还不能自动下载依赖包，可以手动刷新或者说重新导入项目，右键项目文件，在maven选项那点reimport就行了。</p><p><img src="https://img-blog.csdnimg.cn/20200531094242220.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="重新导入"><br>耐心等待后，就可以启动后台了，在eladmin-system下找到Apprun的Java文件，运行它。<br><img src="https://img-blog.csdnimg.cn/20200531094302865.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="项目启动文件"><br>结果如下，没报错就行！<br><img src="https://img-blog.csdnimg.cn/20200531094336323.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><hr><h5 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h5><p>前端配置比较容易出错，报错了直接在命令行输出一大堆信息，关键是解决起来非常麻烦。配置前端呢主要是为了能让大家在本地就能看到效果，只有后端的项目，再好，没前端相辅相成，项目跑的也没意思！同样的套路，同样的逼数！首先咱们找到前端的文件夹，发现里面是没有前端的依赖的，这个不足为奇。那咱们就需要配置依赖了。主要是node.js , node.js 是一个基于 Chrome V8 引擎的 JavaScirpt 运行环境，可以用于服务端编程。我们把它下载后需要<strong>配置它的环境变量</strong>，目的是为了用他的包管理工具npm(nodejs package management)，那有什么用呢?</p><pre><code>  1  允许用户从NPM服务器下载别人编写的第三方包到本地使用  2  允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用  3  允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用</code></pre><p>在这之前，把文件夹里的package.json包修改一下，找到script那里，添加如下：</p><pre><code>&quot;scripts&quot;: {    //如果没有以下，则添加    &quot;dev&quot;: &quot;vue-cli-service serve&quot;,    &quot;start&quot;: &quot;node index.js&quot;,    &quot;server&quot;: &quot;nodemon index.js --ignore client&quot;,    &quot;build&quot;: &quot;vue-cli-service build&quot;,  },</code></pre><p>我们下翻，还能看到前端的依赖dependencies和环境需要的版本，node在8.9及以上，npm在3.0.0及以上。</p><pre><code>&quot;engines&quot;: {    &quot;node&quot;: &quot;&gt;=8.9&quot;,    &quot;npm&quot;: &quot;&gt;= 3.0.0&quot;  },</code></pre><p>之后说白了，npm就是帮我们把前端需要的依赖给下了，方便生成前端页面。具体的nodejs的下载安装配置，可以搜索相关文章，这里就不多讲了。命令行‘npm -v’查看npm版本，能看到输出，说明配置成功。</p><blockquote><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>-g    //设置淘宝镜像，加快下载依赖</p></blockquote><p>cd进入前端文件夹内，输入”npm install”，开始下载依赖，之后文件夹内会多出node_modules文件夹，命令行中不出现报错就行，报错的话可能有几个原因。</p><blockquote><ol><li>网络原因，下载中断了，或下载较慢</li><li>package依赖包没配置好，应先配置好</li><li>版本低，检查一下</li><li>如果不是以上原因，可能是某一个具体因素导致的，就需要仔细查看命令行报错了，很可能是某个依赖没有下好，可以直接进入文件夹查看，如果没有则真的没下好，可以：npm<br>uninstall xxx;再npm install xxx，重新来一遍。</li></ol></blockquote><hr><p>然后一切顺利，”npm run build: prod”；”npm run dev”；前端就跑起来了！结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200531101424186.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="eladmin"><br>当然我们不只是纯粹为了演示项目，像里面的配置啊什么的，技术还需要我们一步一步吃透。要学会解决问题，学习路上总有风雨，只要努力专研，还是会有所收获的！如果有更多问题就关注公众号吧！加群了解更多！这次就分享到这了。</p><p>最后附上：<br><a href="https://www.maliaoblog.cn" target="_blank" rel="noopener">小码blog</a><br><a href="https://www.cnblogs.com/coderma/" target="_blank" rel="noopener">博客园</a><br>微信公众号：小码之光</p><p> <img src="https://img-blog.csdnimg.cn/20200427213721746.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eladmin </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相比c++,java在基础语法上的改变</title>
      <link href="/2020/0528/"/>
      <url>/2020/0528/</url>
      
        <content type="html"><![CDATA[<p>此篇给Java初学者的一点参考，算是入门吧，对有c/c++基础的同学来说，更是帮助他们尽快理解Java更深层次(面向对象，集合，泛型，多线程与并发)的强力剂，如有缺漏敬请补正！转载需注明出处！</p><h5 id="文章目录："><a href="#文章目录：" class="headerlink" title="文章目录："></a>文章目录：</h5><ol><li>运行机制</li><li>基本数据与特殊类型</li><li>字符集与数值表达</li><li>文档注释</li><li>连字符+与输出</li><li>switch语句</li><li>foreach循环</li><li>数组类型</li></ol><hr><h4 id="01-Java运行机制"><a href="#01-Java运行机制" class="headerlink" title="01 Java运行机制"></a>01 Java运行机制</h4><p>在运行机制上，Java不同于任何一门语言，Java编写好的源代码文件并不是经过编译后就能立马执行的。不像c/c++一样，编译后就是.exe了，双击就可以运行，但是Java有它巧妙的地方。先说明一下，任何的编程语言的源码都需要经过编译变成二进制代码，才能被执行，无论c/c++还是Java。在Windows上把c/c++源码经过gCC/g++编译后能运行，但在Linux或其他平台，要有相应的源码编译器为源码进行编译，也就是说，想要在其他平台上运行，得把c/c++源码在编译一遍才能运行。看起来也还行的样子，不就是在编译一次嘛！有多大麻烦呢？对程序员来说不算是什么难事，但对用户来说就是难事，或者说，用起来就是个麻烦事。谁还会辛辛苦苦又编译一次源码，然后让它在机子上跑，万一出问题还得重来！</p><p>起初Java就是为解决这个问题而设计出来的，最早是被sun公司用于嵌入式的设备开发，理念是“write once,run anywhere!”，设计出来后并不很火，那时候c++本身就可以跨平台，所以也没Java什么事儿了。但是之后发现真的可以做到 “  run anywhere ” , 并且由于网页端互联网浪潮的掀起，Java在web上大显身手，这才有了今天的Java，然而sun公司在09年被Oracle收购，之后江湖上再也没了sun公司的身影。那Java又是怎么解决跨平台的问题呢?</p><p>先要了解Java文件，源码文件以.java为后缀，经过编译后不直接生成可执行文件，而是生成.class字节码文件(16进制)，这个文件不是让平台的操作系统读的，是让JVM (java virtual machine)java虚拟机读的，平台上的虚拟机识别后会相应生成能让机子跑起来的二进制文件，就能执行了。其中的原理比较复杂，就不过多陈述啦！</p><p>那有人就不快乐啦：就这？</p><p>当然不是，继续讲。想简单跑一个”hello 妹纸！”需要咋做啊？</p><p>首先上[Oracle的官网]，下载jdk1.8版本，就是常说的Java8。jdk(java development kits大概就这样)，顾名思义：Java开发包，有SE(standard     environment)   ,  EE (enterprise environment),ME(micro environment),即标准版，企业版，微型版。我们要学的是SE，到了工作岗位，可能就要EE了，ME现在基本少的接触，就不用学了，毕竟jdk都14了！里面大致分为javac编译器，运行器java.exe，JRE(java runtime environment) java 运行环境，java基础类库，和其他支持。其中JRE里面有JVM(负责解释字节码)，和其他环境支持。如果在windows上编译”coder小 码.java “源文件，就变成”coder小码.class”,想要在另一台装linux的机子上运行，只需要在这台机子上装JRE就行了，JVM解释”coder小码.class”文件后执行它就行了。</p><hr><h4 id="02-基本与特殊数据类型"><a href="#02-基本与特殊数据类型" class="headerlink" title="02 基本与特殊数据类型"></a>02 基本与特殊数据类型</h4><p>Java相较于原始的c语言，多出了两个基本数据类型，byte字节(1个字节)，和boolean布尔(true/false)基本类型,总共8种；其他为引用(reference)类型，多出了String字符串类型，Array数组类型，null类型(唯一值null)，等等。原来的char字符类型变成了两个字节，可以支持中文字符，一个char,一个汉字。</p><p>保留字(目前未使用但以后会使用):const ; goto也是关键字。</p><p>直接量：true,false,null.虽然不是关键字，但依然不能用来做标识符。</p><p>标识符：增加了$标识开头(中英字母，下划线)，同样不能数字打头，其后才能接任意字符，中日英皆可。</p><hr><h4 id="03-字符集与数值表达"><a href="#03-字符集与数值表达" class="headerlink" title="03 字符集与数值表达"></a>03 字符集与数值表达</h4><p>上面大家可能就有点疑问了，咋就这么越来越开放了！中日字符都来了！没错，Java换了字符支持，使用unicode字符集，几乎支持所有字符，改变了以往编程语言只支持英文标识符的情况，现在读取一个char就相当于读取了一个汉字了。unicode就是这么杠！</p><p>数值表达：Java在整数上又动手动脚的，增加了对二进制整数的表达，比如。</p><pre><code>int binary = 0b10000001;</code></pre><p>上面为一个负数，需要换算成原码为-128。另外为防止程序员出意外看走眼，还可以写成：</p><pre><code>int binary  = 0b1000_0001;</code></pre><p>用下划线可以分隔整型和浮点型。</p><hr><h4 id="04-文档注释"><a href="#04-文档注释" class="headerlink" title="04 文档注释"></a>04 文档注释</h4><p>注释除了以前常用的单多行注释，Java还增加了文档注释。Java为开发者提供了大量的基础类，同时也提供了<a href="https://www.oracle.com/technetwork/java/javase/downoads/" target="_blank" rel="noopener">API帮助文档</a>，介绍各个API、方法、包、类的使用方法，原型。如果编写很大的Java程序，可以利用javadoc工具将源码的文档注释提取出来变成API文档，例：</p><pre><code>/**两个**Description*&lt;h1&gt;javadoc&lt;/h1&gt;*Copyright 2009*@author coder小码*@version 1.0*/</code></pre><p>可以在类，方法，public\protected变量前加注释。进入目录，终端输入：</p><pre><code>javadoc -d D://coder/ -windowtitle API文档 -author -version *.java</code></pre><p>上面的命令用于生成Java文档，-d 存放目录 ，-windowtitle 窗口标题，-author -version,加上作者和版本信息，从当前目录下所有Java源文件中提取注释。之后就生成了和官方一样专业的API文档了！</p><hr><h4 id="05-连字符‘-’与输出"><a href="#05-连字符‘-’与输出" class="headerlink" title="05 连字符‘+’与输出"></a>05 连字符‘+’与输出</h4><p>和c++一样，Java也有连字符，可以将字符串拼接到一起，但同时又能做算术运算，这就涉及到了运算符的重载和基本数据类型的装拆箱了。</p><pre><code>String coder = &quot;小码&quot;+&quot;coder&quot;;String coder2 = &quot;coder小码&quot;+321；System.out.println(coder);System.out.println(coder2);</code></pre><p>输出为：“小码coder”,“coder小码321”。</p><p>将+看作是一个方法，既可以把数字作为参数，又可以把字符做参数，而方法名却没有变，算是隐式的重载一个“+”方法。</p><h5 id="输入输出："><a href="#输入输出：" class="headerlink" title="输入输出："></a>输入输出：</h5><p>Java里主要有3种输出方式，或者说方法吧！上面的算一种：println(变量),即直接输出变量值，还带换行！第二种：printf(“%s”,string),这种再熟悉不过了，需要搭配格式符输出；第三种：print(变量)，同样直接输出值，只不过不带换行！以上都在lang包的System类下的out方法，返回PrintStream输出流类下的println()方法。</p><hr><h4 id="06-switch语句"><a href="#06-switch语句" class="headerlink" title="06 switch语句"></a>06 switch语句</h4><p>Java7增强了switch语句,原来从switch(expression)，表达式只能是byte , short , int , char四种，后来增加了枚举类型enum和String类型，但是不能为true/false布尔型 。相比c/c++的switch语句，多了byte,char(可以是单个中文字符)。需要注意的是：可以是String类型，而不是StringBuffer或StringBuilder字符串类型，即使都是字符串类型。</p><pre><code>String coder = &quot;coder小码&quot;;switch (coder){    case &quot;点赞&quot;:        System.out.println(coder);        break;    case &quot;收藏&quot;:        System.out.println(coder);        break;    case &quot;coder小码&quot;:        System.out.println(coder);        break;    default:        System.out.println(coder);}</code></pre><hr><h4 id="07-foreach循环"><a href="#07-foreach循环" class="headerlink" title="07 foreach循环"></a>07 foreach循环</h4><p>foreach循环是从Java5之后开始加入的，python语法里也有foreach循环，使用它进行遍历操作非常方便。那方便在哪呢？</p><ul><li>无需获得要遍历对象的长度，即不需要知道数组或集合多大</li><li>无需根据索引(下标)访问数组或集合(collection)的元素</li></ul><p>foreach语法如下：</p><pre><code>for(元素类型 循环变量: 数组或集合){    //要执行的代码块    System.out.println(循环变量);}</code></pre><p>从上面看出，foreach的循环将数组或集合中的元素临时赋值给了循环变量，后逐个输出，并没有改变数组的元素，即foreach虽好，但不能改变数组或集合的内容 或值。如果在循环内给循环变量进行赋值，同样不能改变其内容，反而将想要获得的数组的元素修改替换了。</p><hr><h4 id="08-数组类型"><a href="#08-数组类型" class="headerlink" title="08  数组类型"></a>08  数组类型</h4><p>在Java里数组类型有很大变化，以前在c/c++里，数组名就相当于一个指针，指向数组内存首地址。在Java中不是没有指针，只是指针这种概念被弱化了，很少提到，反而多出了引用这种类型，而数组就属于引用类型。</p><h5 id="数组的定义有两种方式："><a href="#数组的定义有两种方式：" class="headerlink" title="数组的定义有两种方式："></a>数组的定义有两种方式：</h5><pre><code>int[] coder;或int coder[];</code></pre><p>很明显，在引入引用的概念并支持unicode字符集后，选择第一种方式才符合Java的语法，不是说第二种就错了，而是第二种可读性太差，很容易看成是定义了一个int类型的以“coder[]”为变量名的数据，而第一种方式，int[]本身就是一种引用类型，而coder就是一个妥妥的引用变量。</p><h5 id="数组的初始化的3种方式："><a href="#数组的初始化的3种方式：" class="headerlink" title="数组的初始化的3种方式："></a>数组的初始化的3种方式：</h5><pre><code>第一种：coder = new int[] {3,2,1};第二种：coder = new int[3];第三种：int[] coder = {3,2,1};</code></pre><p>经典又常用的三种初始化方式，先说前两种吧。前两种都是在已经定义了数组的情况下进行初始化的，我们将第一种称做静态初始化，即初始化的时候就把元素值填了进去，这个时候数组就定了，长度不再改变。而第二种则可以称动态初始化，只是初始化他的长度，并没有赋值。第三种是第一种的简化，即把数组定义和静态初始化两步合一步。以上就是数组的诞生过程，可能有小伙伴会发牢骚：弄一个数组都这么麻烦，还没c/c++效率高呢！的确，c/c++是效率高，但上面之所以要带一个关键字new，其实是为了给数组分配一个内存并初始化赋值，尽管定义了一个数组变量，但只是引用变量而已，没有真正的存数据的内存，起到的也只是一个指向内存的作用，真正有内存是new一个给它。</p><hr><p>最后附上：<br><a href="https://GitHub.com/coderxm/" target="_blank" rel="noopener">github</a><br><a href="https://www.cnblogs.com/coderma" target="_blank" rel="noopener">博客园</a><br>微信公众号：小码之光</p><p> <img src="https://img-blog.csdnimg.cn/20200427213721746.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL server连接本地数据库的两个问题</title>
      <link href="/2020/0523/"/>
      <url>/2020/0523/</url>
      
        <content type="html"><![CDATA[<h4 id="SQL-Server连接本地数据库时的异常"><a href="#SQL-Server连接本地数据库时的异常" class="headerlink" title="SQL Server连接本地数据库时的异常"></a>SQL Server连接本地数据库时的异常</h4><p> 作者：coder小码</p><hr><p>最近想学点SQL server,几个月前下过，可中间电脑换过机名，重装过系统(电脑不是键盘一下没反应就是鼠标没反应)，充分暴露出windows的不稳定。这告诉我们：要早点和windows离婚吧，换一个漂亮又好用点的linux系统(关键是免费开源)，如果有钱可以跟风mac。哈哈！所以呢，系统里的环境变量全部没了，除了操作系统本身的变量外。经验告诉我们：换系统就是换血，把C盘的除系统外的渣渣都清除了，还好是其他盘的东西还在，不过又得手动配置她们的变量了。。。</p><hr><h5 id="01-SQL-SERVER初探"><a href="#01-SQL-SERVER初探" class="headerlink" title="01 SQL SERVER初探"></a>01 SQL SERVER初探</h5><p>初入SQL SERVER的可能不知道有两种版本分类的SQL SERVER，那现在就普及一下。第一种是MSSQL SERVER,全称是Microsoft SQL Sever，开发版，目前的大型网站一般使用Oracle或者MSSQL，JSP.PHP.ASP都可以。一般是企业级的商务网站使用的。全功能SQL数据库服务器，从2017版开始，横跨任何平台，完全免费。第二种是Express ，商业免费，有对应的限制一般都用这个。是SQL SERVER的简洁版，可以这样说。</p><p> 但开始我也不懂啊，也没人叫我怎么玩哈，所以最近发现SQL不见了，就急忙下个SQL server2019最新版的玩一下。不行的是下载了6个多G，连带管理工具一起下(都是开热点的流量啊！啊啊！)，N久后，才下完！然后安装！！！N久。</p><p>起初是发现从前的2017版的没有了，主要是SSMS没有，SSMS是SQL SERVER Management Studio,SQL SERVER管理工具，用来管理数据库的，而我们下的是SQL SERVER的一个下载工具罢了。没SSMS还是玩不起来。</p><hr><h5 id="02-第一个问题：配置管理器无法连接到-WMI-提供程序"><a href="#02-第一个问题：配置管理器无法连接到-WMI-提供程序" class="headerlink" title="02  第一个问题：配置管理器无法连接到 WMI 提供程序"></a>02  第一个问题：配置管理器无法连接到 WMI 提供程序</h5><p> 这个<strong>问题</strong>我记住你了，化成灰我都认得你！！</p><p> <img src="https://img-blog.csdnimg.cn/20200521170345860.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="配置管理器异常">弄了我一整晚，网上都查遍了，每个有效的方法。现在给大家清楚讲一遍，按上面的说，WMI,（Windows Management Instrumentation 即windows 管理规范）是一项核<br>心的 Windows 管理技术；<strong>用户可以使用 WMI 管理本地和远程计算机</strong>。简单点，就是管本地和远程计算机的一个东西。有点内味了！！也就是说要这个服务来帮助SQL配置管理器管理计算机的，那怎么管呢？</p><p>有两种解决方法：要么是没权限，弄权限；要么是服务器真的不能访问了，解决服务器。很明显，连自己的本地的机子，还说无法访问，那就是没权限啦。查查了半天，说要弄一个NETWORK SERVICE的权限，也弄了没反应，估计还不够吧！之后又有其他办法，说进如：”C:\Program Files (x86)\Microsoft SQL Server”里面，我的是这样的，里面是90‘100’120‘的数字文件夹(跟系统打交道的)，不是真正的SQL SERVER文件夹(有界面的那个)。</p><p>其中有一个shared文件夹里有150\Shared\sqlmgmproviderxpsp2up.mof这个文件。<br><img src="https://img-blog.csdnimg.cn/2020052117542694.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="sql~mof"></p><p>我的是150/，可能不一样。之后在命令行输入：</p><blockquote><p>mofcomp “C:\Program Files(x86)\Microsoft<br>SQLServer\150\Shared\sqlmgmproviderxpsp2up.mof”</p></blockquote><p>结果：<br><img src="https://img-blog.csdnimg.cn/20200521173114764.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="将本地数据放到SQL储存库中"><br>将本地数据放到SQL储存库中了，就表示能访问到。那mof是个什么东西呢！</p><p><img src="https://img-blog.csdnimg.cn/20200521173617862.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="mof"></p><p> 反正就是微软瞎造的东西，跟配置有关。不管了！可以正常打开配置管理器，但是里面项目为空，啥也看不到呀！正常是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20200521174143779.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="正常"></p><p>但是右边什么也没有，而且，SSMS还是连不上本地的数据库实例。</p><hr><h5 id="第二个问题：系统找不到指定的文件"><a href="#第二个问题：系统找不到指定的文件" class="headerlink" title="第二个问题：系统找不到指定的文件"></a>第二个问题：系统找不到指定的文件</h5><p>GUI是这样的：<br><img src="https://img-blog.csdnimg.cn/20200521174341368.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="系统找不到指定的文件"><br>本来是输入个本机名字就行了，可就是死活连不上。SSMS: 想玩我？没门！这个时候，还是用的2017的SQL配置管理器，2019的SQLEXPRESS，连2019的配置管理器都没有，当然弄不了了。那之前的努力都白搭，花了我N久弄完！</p><p>其实挺简单的，一步解决上面两个问题，还能使用最新的2019SQL SERVER。对啦，就是重新安装，不用开浏览器上什么官网，直接follow me。哈哈！</p><p>找到SQL SERBER的安装目录，就是那个有安装的SQL server2019：</p><hr><p> D盘文件夹：<br> <img src="https://img-blog.csdnimg.cn/20200521180118799.PNG#pic_center" alt="SQL文件"></p><p>sqlserver文件夹里是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20200521181435401.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="新的本地实例MSSQL1.5"></p><p>之后一路默认安装：</p><p><img src="https://img-blog.csdnimg.cn/20200521180336817.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="SQL 安装中心"></p><hr><p>安装期间会同时实例化本地的数据库，以windows管理员的身份管理，完成后就能看到开始菜单里有2019配置管理器了：</p><p><img src="https://img-blog.csdnimg.cn/20200521180652720.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="开始菜单"></p><p>sercice服务里也会有SQL服务，之前是没有的，即使解决了第一个问题后。估计这就是第二个问题没解决的原因吧！没SQL server服务，就没得玩喽！</p><p><img src="https://img-blog.csdnimg.cn/20200521180951615.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="SQLsever服务"></p><hr><p>所以最后献上玩美结果：</p><p><img src="https://img-blog.csdnimg.cn/20200521181319650.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="连上了本地"></p><p>哈哈，如果要用Network service权限解决的话请参考<a href="https://blog.csdn.net/qq_17532383/article/details/45542605?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159005588419724811810680%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=159005588419724811810680&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v25-7-45542605.nonecase&utm_term=sql%E6%97%A0%E6%B3%95WMI" target="_blank" rel="noopener">另一篇</a><br>最后祝大家玩的愉快！！</p><hr><p>最后附上：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码csdn</a><br><a href="https://www.cnblogs.com/coderma" target="_blank" rel="noopener">博客园</a><br>微信公众号：小码之光</p><p> <img src="https://img-blog.csdnimg.cn/20200427213721746.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小码moneykeeper</title>
      <link href="/2020/0514/"/>
      <url>/2020/0514/</url>
      
        <content type="html"><![CDATA[<h3 id="纯c小项目，小码资金管理工具moneykeeper"><a href="#纯c小项目，小码资金管理工具moneykeeper" class="headerlink" title="纯c小项目，小码资金管理工具moneykeeper"></a>纯c小项目，小码资金管理工具moneykeeper</h3><p>作者：coderxm<br>公众号：小码之光</p><hr><p> 你小码哥回来啦！最近闷得慌，又在学java(自学，想走这条路，哎，一个人找到所爱的真的很难,说不定哪天真的挂了，就来不及了)，慢慢地觉得特别吃力了，主要是学习环境不好，住在一个‘破房子’里，人口又多，真的是烦，而且还不是自个家（没家）。有意识地数了数钱口袋，发现是真的穷死光，哎！！！郁闷啊啊啊！感觉连自个亲人都被抛弃地感觉！(<strong>除了自己，谁都别信！</strong>因为别指望他们能帮你买房买车，理解你的世界！) 总想做点什么，于是敲了敲几行代码，做了个小钱钱管理工具，以后方便看看钱兜(哎！)，自己觉得挺简单实用地就分享给大家了，源码也给哈！<br>下载地址        :    <a href="https://github.com/coderxm/moneykeeper.git" target="_blank" rel="noopener">小码理财moneykeeper</a></p><hr><h6 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h6><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt;#include&lt;conio.h&gt;// 户名结构体 typedef struct{    char hum[100];//    char money[10];}hums;// 构造函数void outdata(void); void empty(char *sf);void putdata(hums *hm);void qorw(hums *hm);int strint(char *s);int main(void){    hums zhanghu[11];    //定义户名结构体数组     char get[4];     char command[4];    FILE *fpr;    fpr = fopen(&quot;E:\\wokfilc\\moneykeeper\\data.txt&quot;,&quot;r&quot;);    fgets(get,5,fpr);    fclose(fpr);    if(get==&#39;\0&#39;||get==&quot; &quot;){        printf(&quot;无账户信息!&quot;);        qorw(zhanghu);    }else{        outdata();        printf(&quot;请继续写入wd或退出quit：\n&quot;);        scanf(&quot;%s&quot;,command);        if(strcmp(command,&quot;quit&quot;)==0){            exit(0);        }else if(strcmp(command,&quot;wd&quot;)==0){            putdata(zhanghu);            outdata();            qorw(zhanghu);        }else{            printf(&quot;输入错误，请重新输入：\n&quot;);            qorw(zhanghu);        }    }    return 0;} //输出信息 void outdata(){    FILE *fpr;    fpr = fopen(&quot;E:\\wokfilc\\moneykeeper\\data.txt&quot;,&quot;r&quot;);    int sum=0;    char DataStr[100];    printf(&quot;*****$$*****\n正在输出账户信息：\n&quot;);    while(feof(fpr)==0){        fseek(fpr,0L,SEEK_CUR);                //?        fgets(DataStr,100,fpr);        if(DataStr!=&#39;\0&#39;&amp;&amp;DataStr!=&quot; &quot;){            printf(&quot;%s \n&quot;,DataStr);        }                sum = sum+strint(DataStr);        empty(DataStr);    }     fclose(fpr);    printf(&quot;您的总资金合计为：%d元\n&quot;,sum);}//empty初始化清空数组 void empty(char *sf){    int sfsize = 0;    sfsize = sizeof(sf);     for(int n=0;n&lt;sfsize;n++){        sf[n] = &#39;\0&#39;;     }} //写入数据 void putdata(hums *hm){    FILE *fpw;    fpw = fopen(&quot;E:\\wokfilc\\moneykeeper\\data.txt&quot;,&quot;w+&quot;);    int i = 0;    char input[100];    printf(&quot;(回车)请写入账户数据：\n&quot;);    do{        int len = 0;        empty(input);         printf(&quot;请写入第%d个账户数据:\n&quot;,i+1);        scanf(&quot;%s&quot;,input);            len = strlen(input);        strcpy(hm[i].hum,input);         strcat(hm[i].hum,&quot;\n&quot;);        fputs(hm[i].hum,fpw);        i = i+1;    }while( (strcmp(input,&quot;end&quot;))!=0&amp;&amp;(i&lt;11) );    fclose(fpw);    //写入完毕后关闭文件 }//字符串中提取数字 int strint(char *s){    int slen=0;    int Money=0;    int ml = 0;    char money[10];    slen = strlen(s);    for(int n=0;n&lt;slen;n++){        if(s[n]&gt;=48&amp;&amp;s[n]&lt;=57){            money[ml]=s[n];            ml++;        }    }    Money = atoi(money);    return Money;}//选择（退出或重新写入）函数void qorw(hums *hm){    char getput[10];    printf(&quot;请选择(重新)输入wrdo或退出quit：\n&quot;);    scanf(&quot;%s&quot;,getput);    while(strcmp(getput,&quot;quit&quot;)!=0){        if(strcmp(getput,&quot;quit&quot;)==0){            return;        }else if(strcmp(getput,&quot;wrdo&quot;)==0){            putdata(hm);            qorw(hm);            return;        }else{            printf(&quot;重新输入,&quot;);            qorw(hm);            return;        }    }} </code></pre><hr><p>源码讲解就不用了吧！相信坚定走这路的人学过c，能看懂吧！主要是也让大家有个真实的现实观，好好管管小钱钱，别胡乱挥霍，以后说不定有大用处！至少能给你一个<strong>真正的家</strong>(一个固定的住处)！好啦！拜拜，学习去喽！</p><hr><p>最后：<br>个人站点：<a href="https://www.cnblogs.com/coderma" target="_blank" rel="noopener">博客园</a><br>公众号：<br><img src="https://img-blog.csdnimg.cn/20200513202720997.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> moneykeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疫情之下c又崛起！</title>
      <link href="/2020/0510/"/>
      <url>/2020/0510/</url>
      
        <content type="html"><![CDATA[<blockquote><p>已经5月份了，国内的疫情也渐渐的好转，人们也把目光放在了经济发展和工作上，拿着漫长的疫情期间，编程界有什么波动呢？</p></blockquote><p>据tiobe官网5月份最新数据显示，C语言在疫情结束后悄悄地登上排行第一位，这是继2015java霸着冠军宝座以来，c语言重新闪耀它的魅力。来看看数据：</p><p><img src="https://img-blog.csdnimg.cn/20200510071549355.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="5月排行"></p><p>从上面看出，c已经超过java1%，相差并不大，也就是说，java仍有其可用之处，短期内并不会被时代抛弃。同时也不意味着c能继续禅位。其中可以看到，以大数据、嵌入式为方向的语言如python、R有了明显的排名提升，这说明，在未来大数据、云计算及嵌入式的科技发展将占据一定的主导地位，并且将应用到人工智能领域，推动人工智能的进一步发展。</p><hr><p><strong>再来看看官网的解读</strong>：</p><p>Java和C在4月已经非常接近，但是本月C再次超越Java。C上一次成为第一名是在2015年。我们只能猜测C为什么再次成为第一名。原因之一可能是冠状病毒。这听起来很愚蠢，但是某些编程语言确实可以从这种情况中受益。例子是数据科学领域的Python和R，因为每个人都在寻找该病毒的解毒剂。但是嵌入式软件语言（例如C和C ++）也越来越流行，因为它们被用于医疗设备的软件中。另一方面，值得一提的是，Rust实际上已经接近前20名（一个月内从第27位上升到第21位）。Paul Jansen(保罗·詹森) TIOBE Software首席执行官 TIOBE编程社区索引是编程语言受欢迎程度的指标。索引每月更新一次。评级基于全球熟练的工程师，课程和第三方供应商的数量。<br><img src="https://img-blog.csdnimg.cn/20200510071720384.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="趋势"><br>诸如Google，Bing，Yahoo！，Wikipedia，Amazon，YouTube和Baidu等流行的搜索引擎用于计算评分。</p><blockquote><p> 重要的是要注意，TIOBE索引与最佳编程语言或大多数代码行所用的语言无关。该索引可用于检查您的编程技能是否仍然是最新的，或用于在开始构建新软件系统时就应采用哪种编程语言做出战略决策。TIOBE索引的定义可以在这里找到。</p></blockquote><p>看来官网已经为我们解释的非常好了，只不过有些话很罗嗦。我就不再跟着啰嗦一遍了，总之，c从疫情中发挥了很大的作用，这足以让看不上c的人开开眼。c还是很有作为的！只不过之前没发现而已。大家又在使用或学习哪种语言呢？</p><hr><p>最后：<br><a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">博客CSDN</a>：coder小码<br>公众号‘<strong>小码之光</strong>’：<br><img src="https://img-blog.csdnimg.cn/20200510071951248.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 疫情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java equals()函数与‘==&#39;</title>
      <link href="/2020/0509/"/>
      <url>/2020/0509/</url>
      
        <content type="html"><![CDATA[<h3 id="java-equals-函数与‘-’"><a href="#java-equals-函数与‘-’" class="headerlink" title="java equals()函数与‘==’"></a>java equals()函数与‘==’</h3><hr><blockquote><p>谈到java的字符串比较函数equals(),就不得不说它真真的用途啦！虽然只是java里面一个简单的知识点，还是有必要扯扯它，因为有许多学习java的小伙伴在比较字符串上纠结与equals()和‘==’的选择。</p></blockquote><hr><h4 id="equals-函数"><a href="#equals-函数" class="headerlink" title="equals()函数"></a>equals()函数</h4><p>函数原型：</p><blockquote><p>public boolean equals(Object anObject)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200509203330784.PNG#pic_center" alt="equals()"></p><p>函数用来比较<strong>字符串内容</strong>的相等，可以是字符串的变量String a = “coder小码”,字符串对象String a = new String(“coder小码”)之间或和同类型的字符串比较，只要是String就行。返回值是布尔值，true \ false,与类型是String或String对象没有关系，只要字符串内容一致，就返回true,否则false。</p><h6 id="字符对象比较"><a href="#字符对象比较" class="headerlink" title="字符对象比较"></a>字符对象比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509204232153.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符对象的比较"></p><h6 id="字符对象与字符String比较"><a href="#字符对象与字符String比较" class="headerlink" title="字符对象与字符String比较"></a>字符对象与字符String比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509204448284.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符对象与字符String比较"></p><h6 id="字符String之间比较"><a href="#字符String之间比较" class="headerlink" title="字符String之间比较"></a>字符String之间比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509204724918.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符String之间比较"></p><hr><h4 id="‘-’关系运算符的运用"><a href="#‘-’关系运算符的运用" class="headerlink" title="‘==’关系运算符的运用"></a>‘==’关系运算符的运用</h4><p>在编写代码的过程中我们经常用到‘==’ 运算符，那 它实质比较的是什么呢？其实也不很高深莫测，实质上是在比较引用指向的内存地址的，只要指向的内存地址相同，即可判断为true。</p><p>说到这里可能会有疑惑了，难道还比内存不成？咋回事啊？咱们先看看几个小例子：</p><h6 id="对象间的比较"><a href="#对象间的比较" class="headerlink" title="对象间的比较"></a>对象间的比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509205936508.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="对象间的比较"></p><h6 id="字符间的比较"><a href="#字符间的比较" class="headerlink" title="字符间的比较"></a>字符间的比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509210051416.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符间的比较"></p><h6 id="字符与字符对象的比较"><a href="#字符与字符对象的比较" class="headerlink" title="字符与字符对象的比较"></a>字符与字符对象的比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509210147114.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字符与字符对象的比较"></p><h6 id="整型间比较"><a href="#整型间比较" class="headerlink" title="整型间比较"></a>整型间比较</h6><p><img src="https://img-blog.csdnimg.cn/20200509210230950.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="整型间比较"></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上代码例子可以说明equals()只是用来比较字符串内容的，不涉及字符串值的地址，而‘==’用法就广泛一点，还能用来比较整形(不止整形和字符)，但实质上是比较是不是来自同一个地址，是就返回true，否则false。好啦，以上就是今天的内容，欢迎在下面留言哦！每一点都是知识的积累，希望学习躺赢，学习愉快！</p><hr><p>最后：<br><a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">博客CSDN</a>：coder小码<br>公众号‘<strong>小码之光</strong>’：<br><img src="https://img-blog.csdnimg.cn/20200509211320148.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> equals </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA启动加速与java编译</title>
      <link href="/2020/0506/"/>
      <url>/2020/0506/</url>
      
        <content type="html"><![CDATA[<h4 id="IJ-IDEA启动加速与java编译"><a href="#IJ-IDEA启动加速与java编译" class="headerlink" title="IJ IDEA启动加速与java编译"></a>IJ IDEA启动加速与java编译</h4><p>1.<strong>启动加速</strong><br>2.<strong>java编译</strong></p><hr><h5 id="01-启动加速"><a href="#01-启动加速" class="headerlink" title="01 启动加速"></a>01 启动加速</h5><p><img src="https://img-blog.csdnimg.cn/20200504113321417.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="tips"><br>忽然有一天IDEA说：你打开它“有点慢”，然后说：consider reducing the num of folder under antivirus protection. 这很有效！</p><p> 可能用IDEA的伙伴都会遇到这样的问题，这只是一个提示。那他说这很有效，到底个怎么有效呢？<em>consider reducing the num of folder under antivirus protection</em> 意思翻译过来 就是：考虑在病毒防护中排除启动器打开的文件。那具体咋弄？先看看官方解释：<br> <img src="https://img-blog.csdnimg.cn/20200504114120578.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70" alt="jetbrain"><br>再翻译一下：</p><blockquote><p>某些防病毒软件可能会干扰IDE的构建过程，从而导致构建的运行速度大大降低。 在IDE中运行构建时，会在计算机上创建许多类文件。<br>如果您的防病毒软件启用了实时扫描，则防病毒软件可以在每次创建文件时强制停止构建过程，而防病毒软件会扫描该文件。</p><p>如果您使用的是Windows Defender，则IDE会自动检查您是否启用了实时扫描，以及是否将扫描配置为处理IDE写入大量文件的目录。</p><p>IDE提供了一种可能性，可以从自动扫描中排除那些目录（此功能在2019.2+ IDE版本中可用）。</p><p>如果您希望手动执行必要的配置，则可以按照以下步骤进行：</p><pre><code> 点击开始按钮 输入“ Windows安全性” 点击“病毒和威胁防护” 点击“病毒和威胁防护设置”下的“管理设置” 如果需要，请向下滚动，然后单击“添加或删除排除项” 对于通知中显示的每个文件夹，请按+按钮，从菜单中选择“文件夹”，然后选择该文件夹。</code></pre></blockquote><p> 官方都非常详细地解释了一番，打开IDEA慢的原因受到电脑自带的杀毒软件的影响，使IDEA不能构建文件。</p><hr><h5 id="02-java编译"><a href="#02-java编译" class="headerlink" title="02 java编译"></a>02 java编译</h5><p>有些刚玩IDEA的小伙伴在创建java文件后不知如何编译，大家都知道点击RUN编译运行就可以了，但那是编译带运行输出结果，如果是没有主函数main()呢，只是想编译呢？</p><p> 接下来我们介绍三种编译方式：</p><blockquote><p> Compile、Make和Build的区别</p></blockquote><p>针对开发工具，一般都有Compile、Make和Build三个菜单项，完成的功能的都差不多，但是又有区别。编译，是将源代码转换为可执行代码的过程。编译需要指定源文件和编译输出的文件路径（输出目录）。Java的编译会将java编译为class 文件，将非java的文件（一般成为资源文件、比如图片、xml、txt、poperties等文件）原封不动的复制到编译输出目录，并保持源文件夹的目 录层次关系。</p><p>在Java的集成开发环境中，比如Eclipse、IDEA中，有常常有三种与编译相关的选项<strong>Compile、Make、Build</strong>三个选项。这三个选项最基本的功能都是完成编译过程。但又有很大的区别：</p><blockquote><p>1、Compile：只编译选定的目标，不管之前是否已经编译过。</p></blockquote><blockquote><p>2、Make：编译选定的目标，但是Make只编译上次编译变化过的文件，减少重复劳动，节省时间。（具体怎么检查未变化，这个就不用考虑了，IDE自己内部会搞定这些的）</p></blockquote><blockquote><p>3、Build：是对整个工程进行彻底的重新编译，而不管是否已经编译过。Build过程往往会生成发布包，这个具体要看对IDE的配置了，Build在实际中应用很少，因为开发时候基本上不用，发布生产时候一般都用ANT等工具来发布。Build因为要全部编译，还要执行打包等额外工 作，因此时间较长。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200504115100594.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="编译"><br>·</p><hr><p>··················································END························································</p><p>以后编译不用迷迷糊糊的去编译啦！对于IEAD的启动Tips，有些人可能会厌烦，但作为一款风靡全球的智能开发软件，还是对新入门的小鸟有很大帮助的，用习惯了，就想说：“<strong>真香</strong>！”</p><hr><p> 最后写作不易：关注我吧(小码之光)<br><a href="https://www.maliaoblog.cn" target="_blank" rel="noopener">博客</a>：<a href="http://www.maliaoblog.cn" target="_blank" rel="noopener">www.maliaoblog.cn</a><br><img src="https://img-blog.csdnimg.cn/20200504120421301.jpg#pic_center" alt="小码之光"></p><hr>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息轰炸</title>
      <link href="/2020/0504/"/>
      <url>/2020/0504/</url>
      
        <content type="html"><![CDATA[<h4 id="消息轰炸器-c语言版"><a href="#消息轰炸器-c语言版" class="headerlink" title="消息轰炸器(c语言版)"></a>消息轰炸器(c语言版)</h4><p> C语言学着学着都感觉没啥用，但是事情没有你想的那样枯燥！C还是很有作为的，比如简单的QQ消息轰炸，原理其实很简单！如有需要或了解可关注下面的微信公众号：<strong>小码之光</strong>，回复<strong>消息轰炸</strong>即可获得源码和轰炸器及使用说明。</p><p><img src="https://img-blog.csdnimg.cn/20200503183114618.jpg#pic_center" alt="小码之光"></p><hr><p>话不多说，既然是个成品，就爽快地拿出来：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main(){    int i;    char name[100];    printf(&quot;目标：&quot;);    scanf_s(&quot;%s&quot;,&amp;name,40);    printf(&quot;次数：&quot;);    scanf_s(&quot;%d&quot;,&amp;i);    HWND H = FindWindow(0,name);    //寻找对话框     while(i--&gt;0){        SendMessage(H,WM_PASTE,0,0);    //粘贴         SendMessage(H,WM_KEYDOWN,VK_RETURN,0);//回车     }} </code></pre><h5 id="原理介绍："><a href="#原理介绍：" class="headerlink" title="原理介绍："></a>原理介绍：</h5><blockquote><p> &lt;windows.h&gt;这个头文件大家很少接触到，里面是一些有关操作系统地接口函数，实际上它是windows的一部分。</p></blockquote><p>scanf_s()函数的用法和scanf()类似，只不过要两个参数，函数原型为</p><pre><code>int scanf_s( const char *format ，[argument]);</code></pre><p>这个函数原型不是太精确，大概来说是这样的，&amp;name为输入需要的储存地址（数组首地址），第二个40为输入大小的限制（40字节）。这个函数是微软之后加上去的，相比scanf()，有输入限制，更安全。</p><p>HWND H是定义了一个句柄，本质上是一个指针，指向窗口。FindWindow()函数用来寻找窗口，所以输入给name数组的为窗口标题。第一个参数是个位常量字符串指针，可以不用管。</p><p>sendmessage()函数很明显用来发消息，发消息第一步肯定是先把消息粘贴，然后enter键发送啦！第一个参数为句柄，第二个为发消息的类型，比如粘贴或按键，后面的参数为具体按键操作。应该能理解。</p><p>i–&gt;0 的意思就是，先判断i是否大于0（大于0，表达式的值为1，否则为0，这个结果将用于while的条件），然后将 i 的值减1。while语句，权如果括号内的值为0，则跳出while循环， 只要括号内的值不为0，则继续循环。 这个大家都学过也能理解。</p><hr><blockquote><p>ok，以上代码就不难弄懂了，好啦，感兴趣的话，可以关注我的公众号进一步了解，希望大家学习c更快乐学习躺赢哦！！哈哈！</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200503192355721.gif#pic_center" alt="学习躺赢"></p><hr><p> 最后：<br>个人博客：<a href="https://www.maliaoblog.cn" target="_blank" rel="noopener">https://www.maliaoblog.cn</a><br>公众号：小码之光</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++高级编程</title>
      <link href="/2020/0501/"/>
      <url>/2020/0501/</url>
      
        <content type="html"><![CDATA[<h4 id="c-高级编程介绍"><a href="#c-高级编程介绍" class="headerlink" title="c++高级编程介绍"></a>c++高级编程介绍</h4><p>   学c++确实是件痛苦的事，这水平得一步步抬上去，实话说学校教的也不好，就更痛苦了，还要学这学那，对技术没半点提升。最近就在学这个，没得方向，只好自己归纳了。嘤！嘤！<br>   <img src="https://img-blog.csdnimg.cn/20200429165631459.jpg#pic_center" alt="嘤嘤"></p><hr><h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ul><li>预处理</li><li>模板</li><li>命名空间</li><li>文件和流</li><li>动态内存分配</li><li>异常处理</li><li>信号处理</li><li>多线程</li><li>web编程</li></ul><hr><p><img src="https://img-blog.csdnimg.cn/20200429190054196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="知识图"></p><hr><h5 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h5><h6 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h6><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。所有的预处理器指令都是以井号（#）开头，和C语言一样，也不是c++语句。C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等。</p><p><strong>define 预处理</strong></p><p>#define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：</p><pre><code>#define 宏 替代文本 </code></pre><p>这里的宏可以当成常量，书本上一般都大写。但不是非得大写，可以小写，只是在以后的学习上有一个好习惯。其他的宏就不一一介绍了。</p><p><strong>预定义宏</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429170234837.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="预定义宏"></p><p><strong>#运算符</strong></p><p> 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把替换文本令牌转换为用引号引起来的字符串。<br> <img src="https://img-blog.csdnimg.cn/20200429170741843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70" alt="#"><br> <strong>条件编译</strong><br> 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。条件预处理器的结构与 if 选择结构很像。<br><img src="https://img-blog.csdnimg.cn/20200429171048730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70" alt="条件编译"></p><hr><h5 id="02-模板"><a href="#02-模板" class="headerlink" title="02 模板"></a>02 模板</h5><p>模板是c++一个很重要的概念，模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p><p>上面是c++自己说的，讲的这么高尚，都把自己讲糊涂了！简单去讲，模板可以理解为一种基本模样，可以用来创建函数或者类，或者别的，只是还不到变量的类型。需要注意的是模板可不是类，也就是没有特定的类型啦！</p><p><strong>函数模板</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429172124168.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="函数模板">)图中的T是无特定类型，整个用法有点像函数重载一样，至少重载需要定义不同的同名函数，参数输入也要不一样，有了模板，代码量就减少了，套模板就是。当输入的是整型时，则T为整形进行运算，其余类似。关于刚才的重载和inline内联可参考上次的文章：<a href="https://blog.csdn.net/gobullin/article/details/105798076" target="_blank" rel="noopener">c++面向对象吗？不懂看这个</a></p><p><strong>类模板</strong></p><p>在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型。<br><img src="https://img-blog.csdnimg.cn/20200429173329417.PNG#pic_center" alt="类模板"></p><p><img src="https://img-blog.csdnimg.cn/20200429173646951.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="类模板"><br>以上就是几个常见的模板，如果真要一个类型去归纳的话，c++给了一个高大上的名字：<strong>泛型</strong>，一个宽泛的类型。。。。</p><hr><h5 id="03-命名空间"><a href="#03-命名空间" class="headerlink" title="03 命名空间"></a>03 命名空间</h5><p>在c++中，一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。因此，引入了命名空间这个概念，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个<strong>范围</strong>。<br><img src="https://img-blog.csdnimg.cn/20200429174417484.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="图解"><br><strong>特定命名</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20200429174452299.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="命名namespace">然而，以上命名空间的函数前，都加了空间名，我们可以用using指令省去，即using namespace 空间名 就可以省去了，例：</p><p>using namespace std;</p><p>cout &lt;&lt; ‘小码之光’ &lt;&lt;endl;<br> 而不是std::cout/endl</p><p><strong>嵌套命名</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429175303338.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="嵌套命名"></p><hr><h5 id="04-文件和流"><a href="#04-文件和流" class="headerlink" title="04 文件和流"></a>04 文件和流</h5><p>C++ 中另一个标准库 fstream，它定义了三个新的数据类型：<br><img src="https://img-blog.csdnimg.cn/20200429175459819.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="文件io"><br>以上三个理解：<br>ofstream:out-file-stream写文件;<br>ifstream:in-file-stream读文件;<br>fstream:file-stream读写;</p><p><img src="https://img-blog.csdnimg.cn/20200429180035780.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="读写模式"><br>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，即需要<strong>先创建文件对象</strong>，如果只需要打开文件进行读操作，则使用 ifstream 对象。和c里的文件读取一样，c++也有打开模式。不过有点不同。</p><p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><p>void open（文件名, ios::打开模式);</p><p><img src="https://img-blog.csdnimg.cn/20200429180141903.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="例"><br>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p><p>close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><hr><h5 id="05-动态内存"><a href="#05-动态内存" class="headerlink" title="05 动态内存"></a>05 动态内存</h5><p><strong>关键字</strong>new\delete<br>堆是程序中未使用的内存，在程序运行时可用于动态分配内存。使用new 运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。</p><p><strong>数组</strong><br><img src="https://img-blog.csdnimg.cn/20200429181216147.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="动态分配"><strong>对象</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429181424810.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="对象分配"></p><hr><h5 id="06-异常处理"><a href="#06-异常处理" class="headerlink" title="06 异常处理"></a>06 异常处理</h5><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p><p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。<br>··································································································<br>   throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。<br>   catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕    获异常。<br>    try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。<br>····································································································</p><p><img src="https://img-blog.csdnimg.cn/20200429181940957.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="异常处理"><br><img src="https://img-blog.csdnimg.cn/20200429182015771.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="捕获异常"><br>C++ 提供了一系列标准的异常，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200429182113676.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="异常说明"><br><strong>自定义异常</strong></p><p><img src="https://img-blog.csdnimg.cn/2020042918221952.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="自定义"></p><hr><h5 id="07-信号处理"><a href="#07-信号处理" class="headerlink" title="07 信号处理"></a>07 信号处理</h5><p>信号是由操作系统传给进程的中断，会提早终止一个程序。不是我们一般意义上的信号。这些信号是定义在 C++ 头文件csignal 。</p><p><img src="https://img-blog.csdnimg.cn/20200429182634851.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="信号">C++ 信号处理库csignal提供了 signal 函数，用来捕获突发事件。<br><strong>signal函数</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429182924504.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="signal"><br><strong>raise函数</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429183036845.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="raise"></p><hr><h5 id="08-多线程"><a href="#08-多线程" class="headerlink" title="08 多线程"></a>08 多线程</h5><p>在高级语言编程里，总是会听到多线程，一些大厂面试也会提到多线程，那多线程有多厉害多神秘呢？</p><p>这里又要扯上专业课了，多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。</p><pre><code>基于进程的多任务处理是程序的并发执行。基于线程的多任务处理是同一程序的片段的并发执行。</code></pre><p>多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。通俗的说就是，计算机干活时候，将以一个进程为单位，处理一个要执行的程序，比如要打开的QQ，但不能一股脑把它干了，还有别的程序要运行呢。所以进程在内存上是间隔的，运行一个程序，计算机把很大的可执行文件分成若干部分去执行，每一部分以线程(都这么叫)的形式执行，这样就有了多线程处理。</p><p><strong>创建线程</strong>：<br>    #include &lt;pthread.h&gt;<br>    pthread_create (thread, attr, start_routine, arg) ；</p><p><img src="https://img-blog.csdnimg.cn/20200429184556582.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="参数"><br><strong>终止线程</strong></p><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p><p>#include &lt;pthread.h&gt;<br>pthread_exit (status) ；</p><p>在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止</p><p><strong>线程连接与分离</strong></p><p><img src="https://img-blog.csdnimg.cn/20200429185150937.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="线程连接分离">)<img src="https://img-blog.csdnimg.cn/20200429185212778.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="lianjie"><br>··············································································································<br><img src="https://img-blog.csdnimg.cn/20200429185308444.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="c11"></p><hr><h5 id="09-web编程"><a href="#09-web编程" class="headerlink" title="09 web编程"></a>09 web编程</h5><p> 除了线程难以外，web编程学起来也很费劲，对初学者一点也不友好。所以在这里就不做过多累赘了。要学的太多了！就简单介绍一下公共网关接口（CGI），公共网关接口（CGI）是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的，是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。如果要深入学习就寻找相关的书籍资料吧！(进公众号也行，问小码要哦，尽量帮你弄到， 写作不易，客官赏一个！)<br><img src="https://img-blog.csdnimg.cn/2020042919130999.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="拽"></p><hr><p>更多尽在微信公众号小码之光</p><p>博客：<a href="http://www.maliaoblog.cn" target="_blank" rel="noopener">www.maliaoblog.cn</a><br> 推荐：<br>    《Essential C++ 中文版》<br>    《C++ Primer Plus 第6版中文版》<br>    《C++ Primer中文版（第5版）》</p><p>··················································END·························································</p><p> 微信公众号    ：小码之光（免费资料等你拿哦，文章公众号首发！二维码7天有效）<br> <a href="https://mp.weixin.qq.com/s/C-IDOjM245by-U_mBzPV2Q" target="_blank" rel="noopener">项目资料</a></p><p> <img src="https://img-blog.csdnimg.cn/20200429190944279.jpg#pic_center" alt="公众号"></p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++对象？看看这个</title>
      <link href="/2020/0428/"/>
      <url>/2020/0428/</url>
      
        <content type="html"><![CDATA[<h3 id="深入理解c-面向对象几大特性"><a href="#深入理解c-面向对象几大特性" class="headerlink" title="深入理解c++面向对象几大特性"></a>深入理解c++面向对象几大特性</h3><hr><ul><li>类</li><li>继承</li><li>重载</li><li>多态</li><li>数据抽象</li><li>数据封装</li><li>抽象类及实例化</li></ul><hr><p><img src="https://img-blog.csdnimg.cn/20200427194118832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="思维图"></p><hr><h4 id="01-类"><a href="#01-类" class="headerlink" title="01 类"></a>01 类</h4><p>类是 C++ 的核心特性，通常被称为用户定义的类型。也就是说，它和其他基本类型一样(浅显的这么说)，都是type。类定义是以关键字 class 开头，后跟类的名称。由类可以生成对象，这里，对象可以理解为变量，一种特殊类型的变量，相当于c语言中的struct结构体类型变量。</p><hr><h4 id="02-类成员函数"><a href="#02-类成员函数" class="headerlink" title="02 类成员函数"></a>02 类成员函数</h4><p>类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。也可以在类的外部使用范围解析运算符 :: 定义该函数</p><p><img src="https://img-blog.csdnimg.cn/20200427195444481.PNG#pic_center" alt="范围解析"></p><p>需要强调一点，在 :: 运算符之前必须使用类名，调用成员函数是在对象上使用点运算符（.）。</p><hr><h4 id="03-类访问修饰符"><a href="#03-类访问修饰符" class="headerlink" title="03 类访问修饰符"></a>03 类访问修饰符</h4><p>访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。</p><p>公有成员在程序中类的外部是可访问的(public)，即可以通过(对象.成员)或内部的public调用函数访问。</p><p> 私有成员(private)则不同，那只能通过类内部的调用函数访问或修改，这时的内部public函数相当于链接类内外的桥梁，而不能用(对象.成员)去访问了，即便是继承了的子类(派生类)也不能这样调用私有成员。除了protected。</p><p> 保护成员(protected)像私有成员一样，不能直接访问，需要使用内部函数，但区别就体现在继承的子类上，子类则可以直接通过(对象.成员)调用成员。</p><p><img src="https://img-blog.csdnimg.cn/20200427202735199.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="protected"></p><hr><h4 id="04-析构与构造函数"><a href="#04-析构与构造函数" class="headerlink" title="04 析构与构造函数"></a>04 析构与构造函数</h4><p>类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p><p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><p>下面的实例有助于更好地理解析构函数的概念：</p><p><img src="https://img-blog.csdnimg.cn/20200427203150275.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="构造函数"></p><hr><h5 id="拷贝构造函数："><a href="#拷贝构造函数：" class="headerlink" title="拷贝构造函数："></a>拷贝构造函数：</h5><p>拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</p><p><img src="https://img-blog.csdnimg.cn/20200427203553626.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="拷贝构造函数"></p><h4 id="05-友元函数"><a href="#05-友元函数" class="headerlink" title="05 友元函数"></a>05 友元函数</h4><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend。</p><p><img src="https://img-blog.csdnimg.cn/20200427203814283.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="友元函数"><br>注意：友元函数不是类成员函数，但有很厉害的通行证，能访问所以成员，同时也不能被子类继承，要访问不能用(对象.函数)。</p><hr><h4 id="06-内联函数"><a href="#06-内联函数" class="headerlink" title="06 内联函数"></a>06 内联函数</h4><p> 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p><pre><code>1.在内联函数内不允许使用循环语句和开关语句；2.内联函数的定义必须出现在内联函数第一次调用之前；</code></pre><hr><h4 id="07-this指针"><a href="#07-this指针" class="headerlink" title="07 this指针"></a>07 this指针</h4><p>每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p><p>this 指针是所有成员函数的隐含参数，即this已经事先定义好了，不用再声明了。友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。用法与c中结构体类似，指向对象。</p><hr><h4 id="08-指向类的指针"><a href="#08-指向类的指针" class="headerlink" title="08 指向类的指针"></a>08 指向类的指针</h4><p>指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。访问指向类的指针的成员，需要使用成员访问运算符 -&gt;，就像访问指向结构的指针一样。与所有的指针一样，必须在使用指针之前，对指针进行初始化。</p><hr><h4 id="09-静态成员"><a href="#09-静态成员" class="headerlink" title="09 静态成员"></a>09 静态成员</h4><p>使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。</p><p><img src="https://img-blog.csdnimg.cn/20200427210152476.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="静态成员函数"></p><hr><h4 id="10-继承"><a href="#10-继承" class="headerlink" title="10 继承"></a>10 继承</h4><p>创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。<br> 如：<br>class 继承类: 访问修饰符 基类；</p><hr><h4 id="11-多继承"><a href="#11-多继承" class="headerlink" title="11 多继承"></a>11 多继承</h4><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：</p><p>class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…<br>{<br>&lt;派生类类体&gt;<br>};</p><hr><h4 id="12-函数重载"><a href="#12-函数重载" class="headerlink" title="12 函数重载"></a>12 函数重载</h4><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。</p><p><img src="https://img-blog.csdnimg.cn/2020042721070710.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="重载">)<img src="https://img-blog.csdnimg.cn/20200427210731932.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="重载"></p><hr><h4 id="13-运算符重载"><a href="#13-运算符重载" class="headerlink" title="13 运算符重载"></a>13 运算符重载</h4><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。成员运算符重载：</p><p>Box operator+(const Box&amp;);</p><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，那这样子类也不能继承，如下所示：</p><p>Box operator+(const Box&amp;, const Box&amp;);</p><p><img src="https://img-blog.csdnimg.cn/20200427211346583.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="重载函数"></p><h6 id="重载决策："><a href="#重载决策：" class="headerlink" title="重载决策："></a>重载决策：</h6><p>上面的print()函数用了3次，仔细看都是不一样类型的参数，接下来在主函数main里调用了3次，所以内部有一个重载决策机制判断输入的参数类型该定义哪一个函数后调用。</p><hr><h4 id="14-多态"><a href="#14-多态" class="headerlink" title="14 多态"></a>14 多态</h4><p>就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数(即使成员函数名相同)时，会根据调用函数的对象的类型(意味着在基类上产生了不同的派生类)来执行不同的函数。</p><p><img src="https://img-blog.csdnimg.cn/20200427212119939.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="多态"></p><hr><h4 id="15-数据抽象与封装"><a href="#15-数据抽象与封装" class="headerlink" title="15 数据抽象与封装"></a>15 数据抽象与封装</h4><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。使用类来定义我们自己的抽象数据类型（ADT），可以使用类 iostream 的 cout 对象来输出数据到标准输出，而不需要知道如何实现。说简单点就是要用到接口之类的，从而来方便调用操作数据。</p><p>数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。</p><hr><h4 id="16-抽象类"><a href="#16-抽象类" class="headerlink" title="16 抽象类"></a>16 抽象类</h4><p>C++ 接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示：<br>class Box<br>{<br>   public:<br>      // 纯虚函数<br>      virtual double getVolume() = 0;<br>   private:<br>      double length;      // 长度<br>      double breadth;     // 宽度<br>      double height;      // 高度<br>};</p><p>设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p><p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为具体类。</p><p><img src="https://img-blog.csdnimg.cn/20200427212858552.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="抽象类"><br>说白了，这术语本质上就是个接口，以供调用。这些人说的这么高大上，最后把大家都弄晕了。好了以上就是给大家一个柳暗花明，希望有帮助在学习c++的路上！</p><p><img src="https://img-blog.csdnimg.cn/20200427213257990.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="哈哈"><br> 最后附上：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码csdn</a><br> 微信公众号：小码之光<br> <img src="https://img-blog.csdnimg.cn/20200427213721746.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还要翻墙？试试这个</title>
      <link href="/2020/0427/"/>
      <url>/2020/0427/</url>
      
        <content type="html"><![CDATA[<p>想看看国外的风光吗？疫情期间就像挂在家的咸鱼一样，快发酵了！点开浏览器，可是只能在国内的网站上静静地划过，没有一点新鲜事。可是想上外网又被墙，怎么办？</p><p><img src="https://img-blog.csdnimg.cn/20200426223714317.jpg#pic_center" alt="咋办"></p><p>  哈哈!客官别着急，我这就给您上‘菜’。咱们开了浏览器，最好是火狐的，在设置里的附加组件中的扩展里搜索谷歌上网助手Ghelper(在插件商店里也行)</p><p><img src="https://img-blog.csdnimg.cn/20200426225107588.jpg#pic_center" alt="gao"></p><p><img src="https://img-blog.csdnimg.cn/20200426223824507.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="插件"></p><hr><p>接下来很简单，添加这个插件就行了，添加如下</p><p><img src="https://img-blog.csdnimg.cn/20200426223918722.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="ghelper"><br>on开启上网策略，在这之前需要配置隐私设置。找到该插件，点击管理，允许在隐私窗口运行即可。<br><img src="https://img-blog.csdnimg.cn/20200426224000741.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="ghelper"><br><img src="https://img-blog.csdnimg.cn/20200426224038620.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="开启后台运行"></p><hr><p><img src="https://img-blog.csdnimg.cn/20200426224215506.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="excited"></p><hr><pre><code>客官：太好了！！！！！小码：先别太过于兴奋，咱们先试试看，到底能不能上像youtube这样的外网。客官：那好，快试试！</code></pre><p><img src="https://img-blog.csdnimg.cn/20200426224442361.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="youtube"></p><hr><p>行啦！！（可能需要验证邮件）没问题！不过是走日本的线路，所以才有日语，可以换换别的，就有别的语言选择。</p><pre><code>客官：嗯，不错！开动！小码：莫急，咱再试试！</code></pre><p><img src="https://img-blog.csdnimg.cn/20200426225236528.jpeg#pic_center" alt="tm"></p><p>进入face看看，来到了奥巴马的主页。。。。</p><p><img src="https://img-blog.csdnimg.cn/2020042622455269.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="obama"></p><hr><p>又进入了</p><p><img src="https://img-blog.csdnimg.cn/20200426224651912.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="威尔史密斯"></p><hr><pre><code>​客官：你tm又个P啊！开动！开动！</code></pre><p>小码：好的好的，喜欢的话就关注我哦！哈哈！<br>blog：<a href="https://www.maliaoblog.cn" target="_blank" rel="noopener">小码blog</a><br> 微信公众号：小码之光<br> <img src="https://img-blog.csdnimg.cn/20200426225554247.jpg#pic_center" alt="小码之光"></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ghelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtualbox虚拟机安装</title>
      <link href="/2020/0425/"/>
      <url>/2020/0425/</url>
      
        <content type="html"><![CDATA[<h4 id="用虚拟机virtualbox安装ubantu桌面系统"><a href="#用虚拟机virtualbox安装ubantu桌面系统" class="headerlink" title="用虚拟机virtualbox安装ubantu桌面系统"></a>用虚拟机virtualbox安装ubantu桌面系统</h4><ul><li>下载ubantu镜像</li><li>下载安装虚拟机</li><li>新建一个虚拟电脑Linux01</li><li>安装ubantu镜像</li><li>（网络设置）</li></ul><hr><h5 id="01-下载ubantu镜像"><a href="#01-下载ubantu镜像" class="headerlink" title="01 下载ubantu镜像"></a>01 下载ubantu镜像</h5><p>要想在虚拟机里玩ubantu，就要先准备好该系统的iso镜像文件，那么我们就直接到了官网去了</p><p><img src="https://img-blog.csdnimg.cn/20200425111147300.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="官网"><br>可是我们点击下载后速度又慢了，比github还慢，原因就不说了。所以当然有更快的方法啦！不一定非要去国外的官网下载，国内的各大高校和巨头都有镜像站提供免费的镜像下载，这里就给大家推荐一番。</p><h6 id="阿里云开发者社区镜像站"><a href="#阿里云开发者社区镜像站" class="headerlink" title="阿里云开发者社区镜像站"></a><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">阿里云开发者社区镜像站</a></h6><p><img src="https://img-blog.csdnimg.cn/20200425111743145.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="阿里镜像站"><br>第一个就是ubantu,这里可以下server或desktop都可以，反正又快又免费！哈哈</p><h6 id="浙大镜像站"><a href="#浙大镜像站" class="headerlink" title="浙大镜像站"></a><a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">浙大镜像站</a></h6><p> 为什么选择浙江大学的镜像站呢？国内有很多这样的镜像站啊。。。。当然是快啦，相比较其他大学的站点，算是比较好了。</p><p><img src="https://img-blog.csdnimg.cn/20200425112624418.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="浙大镜像站"></p><p> 我是在阿里云下的，起初弄不清server和desktop版，就先下了server版，结果就是疑惑了半天，也没出现漂亮的界面。<br> <img src="https://img-blog.csdnimg.cn/20200425112906835.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="命令行"></p><hr><h5 id="02-安装oracle-virtualbox虚拟机"><a href="#02-安装oracle-virtualbox虚拟机" class="headerlink" title="02 安装oracle virtualbox虚拟机"></a>02 安装oracle virtualbox虚拟机</h5><p>这个就有点难下了，我没在镜像站里找，在网盘下的。(VMware需要许可证)这里大家可以搜一搜，分享<a href="https://pan.baidu.com/s/13mubMuemzTbLApTyxJXQVQ" target="_blank" rel="noopener">VM</a></p><p>提取码：vz1h</p><p>下载好安装包后，打开就行了</p><p><img src="https://img-blog.csdnimg.cn/20200425115703159.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="安装完成"></p><hr><h5 id="03-新建虚拟电脑Linux01"><a href="#03-新建虚拟电脑Linux01" class="headerlink" title="03 新建虚拟电脑Linux01"></a>03 新建虚拟电脑Linux01</h5><p>点击新建，选择要安装的系统，之后就是一路默认。</p><p><img src="https://img-blog.csdnimg.cn/20200425120535645.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="新建"><br> 内存最好配置在2G以上</p><p><img src="https://img-blog.csdnimg.cn/20200425120650265.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="内存"></p><hr><h5 id="04-安装ubantu镜像"><a href="#04-安装ubantu镜像" class="headerlink" title="04 安装ubantu镜像"></a>04 安装ubantu镜像</h5><p>虽然已经有一个虚拟电脑了(其实就是占用宿主机的磁盘空间)，这个时候只有硬件上的支持，还没有系统文件的调用。所以咋们进入启动Vbox界面的设置项</p><p><img src="https://img-blog.csdnimg.cn/20200425121253258.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="设置"></p><p>红色箭头那点击进入，再点击注册项，即可从宿主机文件里选择下载好的ubantu镜像文件</p><p><img src="https://img-blog.csdnimg.cn/20200425121517698.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="注册"><br>ok,配置好后，再启动虚拟电脑，就进入ubantu系统安装界面了，而不是命令行。</p><p><img src="https://img-blog.csdnimg.cn/2020042512174573.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="ubantu界面"></p><pre><code> 接下来就是安装了 </code></pre><p><img src="https://img-blog.csdnimg.cn/20200425122022310.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> 这里可以选择试用或者安装ubantu，安装后启动就直接进入虚拟电脑工作界面了。</p><p><img src="https://img-blog.csdnimg.cn/20200425122834737.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="ubantu"><br> 界面还是很漂亮的，不过virtualbox是小型机，界面不能全屏，如果可能还是选VMware虚拟机吧，试过，感觉就是香！哈哈！</p><hr><h5 id="05-网络设置"><a href="#05-网络设置" class="headerlink" title="05 网络设置"></a>05 网络设置</h5><p> 这里就不过多讲了，建好后可以配置网络，有自己的cdn节点。推荐<a href="https://www.bilibili.com/video/BV1bA411b7vs" target="_blank" rel="noopener">程序羊</a></p><hr><p>附：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码csdn</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubantu </tag>
            
            <tag> virtualbox虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitpage CDN加速配置与深入</title>
      <link href="/2020/0421/"/>
      <url>/2020/0421/</url>
      
        <content type="html"><![CDATA[<h3 id="github-page-cdn加速服务深入了解"><a href="#github-page-cdn加速服务深入了解" class="headerlink" title="github page cdn加速服务深入了解"></a>github page cdn加速服务深入了解</h3><ul><li>CDN介绍</li><li>CDN提供商</li><li>github page cdn加速服务配置</li><li>CDN加速服务深入</li></ul><h4 id="CDN介绍"><a href="#CDN介绍" class="headerlink" title="CDN介绍"></a>CDN介绍</h4><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术…..</p><p>上面是百度的介绍，啰嗦了一大堆，说白了就是让坐在电脑前的用户就近的获取需要的网络资源，而不用跑去访问遥远的服务器了。既然这么好，那就用呗！国内外都有一些这样的CDN服务提供商，但是大家都知道，访问外面的网络很费劲的。国内的一些CDN提供商也有不少，服务也不错，就给大家推荐一下。</p><h4 id="CDN提供商"><a href="#CDN提供商" class="headerlink" title="CDN提供商"></a>CDN提供商</h4><h6 id="阿里云CDN-DCDN全站加速"><a href="#阿里云CDN-DCDN全站加速" class="headerlink" title="阿里云CDN/DCDN全站加速"></a>阿里云CDN/DCDN全站加速</h6><p><img src="https://img-blog.csdnimg.cn/20200421103618200.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="阿里云CDN">阿里云的CDN加速服务应该算是不错了，支持国内外和全球加速，这里选择全站加速会比较好一点。</p><h5 id="腾讯云CDN"><a href="#腾讯云CDN" class="headerlink" title="腾讯云CDN"></a>腾讯云CDN</h5><p>巨头们总是这么滴强。。。腾讯云内同样提供比较哟西的CDN加速服务，提供商不一样，可能CDN操作的流程会略有不同。<br><img src="https://img-blog.csdnimg.cn/20200421104213353.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="腾讯CDN"></p><h5 id="又拍云CDN"><a href="#又拍云CDN" class="headerlink" title="又拍云CDN"></a>又拍云CDN</h5><p>又拍云服务提供商也还行吧，反正试了下没啥效果，这里最好在域名提供商哪里选择CDN服务。<br><img src="https://img-blog.csdnimg.cn/20200421104446548.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="又拍云CDN"></p><h4 id="Github-page-cdn配置"><a href="#Github-page-cdn配置" class="headerlink" title="Github page cdn配置"></a>Github page cdn配置</h4><p>在没有CDN的时候是这样的<br><img src="https://img-blog.csdnimg.cn/20200421104655773.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="无CDN测速">火红的大火鸡，非常差的访问去访问github节点。之后我选择阿里云的CDN去加速访问，在这之前可能要准备一个域名来操作啦。</p><p>现在我们进入阿里云的CDN，在域名管理处添加要加速的域名，如’<a href="http://www.maliaoblog.cn&#39;,这时候会提示没有备案，不用管，继续操作。在源站信息配置上，有三种选择，分别是OSS，域名，IP，如果你还填要加速的域名的话，显然会有重定向的麻烦，所以这里的源站在阿里云帮助文档里就讲了，源站就是github" target="_blank" rel="noopener">www.maliaoblog.cn&#39;,这时候会提示没有备案，不用管，继续操作。在源站信息配置上，有三种选择，分别是OSS，域名，IP，如果你还填要加速的域名的话，显然会有重定向的麻烦，所以这里的源站在阿里云帮助文档里就讲了，源站就是github</a> page服务器的域名或IP地址，这里还没有涉及到回源host的设置，大家尽管放心操作。之后在端口处选择443端口（以https协议访问，需要添加Https证书，如SSL的），加速区域选不包含中国大陆的，即海外节点加速，最后点击下一步。</p><p><img src="https://img-blog.csdnimg.cn/20200421110442442.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="CDN配置"><br>到这里基本上就完成了，返回的时候刷新一下，能看到CNAME地址！需要在域名解析到这个CNAME地址。</p><p><img src="https://img-blog.csdnimg.cn/20200421111013463.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="CDN运行正常">只有解析到这个CNAME地址后，过几分钟，阿里云才能进行CDN加速服务。之后以这个加速域名去测速，速度就会提升了。注意，是以这个加速了的域名访问，那访问的就是阿里云帮我们提供的CDN节点，那当然会更快啦。</p><h4 id="CDN加速服务深入"><a href="#CDN加速服务深入" class="headerlink" title="CDN加速服务深入"></a>CDN加速服务深入</h4><p>其实也没有多大的深入，就是在弄明白一个问题：github page还需要自定义域名吗？我们加没加速对博客站点的访问？</p><h5 id="ping了一下，没加速对github-io的访问"><a href="#ping了一下，没加速对github-io的访问" class="headerlink" title="ping了一下，没加速对github.io的访问"></a>ping了一下，没加速对github.io的访问</h5><p><img src="https://img-blog.csdnimg.cn/20200421112042708.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="io还是原样"><br>github.io为美国的节点，直接访问当然没多快呀，如果ping加速域名的话，会访问阿里美国的CDN的节点，如果要回源的话，访问的请求会从节点发送出去。这就等于加速了从电脑前的客户所在地到节点该段的速度，走的是访问CDN节点的路线。</p><p><img src="https://img-blog.csdnimg.cn/2020042111291429.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="流程图">接着我再以加速域名测速，肯定是红色少了</p><p><img src="https://img-blog.csdnimg.cn/20200421113044946.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="鸡儿绿了"><br>访问请求最终还是要得到最后的服务器的回应，也就是给我们网页资源。为此我又进行了测试。</p><h6 id="路由测试"><a href="#路由测试" class="headerlink" title="路由测试"></a>路由测试</h6><p><img src="https://img-blog.csdnimg.cn/20200421115105784.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="路由测试"></p><h6 id="DNS测试"><a href="#DNS测试" class="headerlink" title="DNS测试"></a>DNS测试</h6><p><img src="https://img-blog.csdnimg.cn/202004211152004.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="DNS测试">)如果加速域名DNS解析到github.io的话，github.io又有节点，那整个访问就快了。真的是这样的吗？还要不要.io自定义域名呢？page通过产生的github.io就可以访问到博客，自定义域名只是放到另一个展示(published)的地方(site)，那既然我们需要买域名去覆盖，那就要解析一个到github.io的CNAME的记录了。这么多，浏览器可能产生重定向的问题，以至于要不断刷新页面。但可以用一下，至少不要跑老远去DNS解析，输入域名，浏览器就老老实实交出页面啦。<br><a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github page </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连接远程服务器出现乱码</title>
      <link href="/2020/0419/"/>
      <url>/2020/0419/</url>
      
        <content type="html"><![CDATA[<h2 id="连接远程服务器后出现命令行乱码"><a href="#连接远程服务器后出现命令行乱码" class="headerlink" title="连接远程服务器后出现命令行乱码"></a>连接远程服务器后出现命令行乱码</h2><p>真是巧了，最近遇到的事儿净跟编码有关，好像中了毒一样。话不多说，看乱码。<br><img src="https://img-blog.csdnimg.cn/20200419212122295.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="linux命令行乱码">大家已经看到了，连上服务器后的写个文件的目录命令，就只拉出了四个字，呃，不对，还有一个零蛋。好，这种乱码现象其实已经多见少怪了，然而还是有原因的，不然我怎么会写个博客记录一下。值得注意的就是在命令行出现乱码的情况很少，还是敲了命令之后，何况有的小伙伴还不熟悉linux系统的操作，更不知道怎么办了。慌了手脚，求救网页标签都打开了好几个，还是不知道咋弄，于是小伙伴只好四下求救大佬。<br>今天我就带大家一块干了。。</p><h3 id="so-到了面对编码的时候了"><a href="#so-到了面对编码的时候了" class="headerlink" title="so 到了面对编码的时候了"></a>so 到了面对编码的时候了</h3><p> 大家还记得上次讲过的编码格式问题吧，这次就不是转成Ansy格式了，要在secureCRT把编码格式转成utf-8格式，为什么呢？因为默认的secureCRT命令行不是utf-8,也不是中文字符集，所以就要改一改。如果小伙伴用的是中文破解版的，点击菜单栏中选择里会话选项，英文为option,界面如下，在外观(appearance)那里的字符编码选择那选择utf-8<br> <img src="https://img-blog.csdnimg.cn/20200419214524425.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="option会话选项"><br> 字体选择自己喜欢的，但是要中文字符集gb2312</p><p><img src="https://img-blog.csdnimg.cn/20200419214829854.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="字体">OK啦，解决问题啦，就有如下对比</p><p><img src="https://img-blog.csdnimg.cn/20200419214956728.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="命令输入"><br>这样就顺顺利利地干了它了，哈哈，心里是不是很爽啊。如果大家对界面背景不满意同样可以调节，比如背景为黑色，命令前景为白色或黑客绿(瞎装逼色)，看图</p><p><img src="https://img-blog.csdnimg.cn/20200419215401157.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="黑客绿"> <code>如果小伙伴还弄不明白，那只能献上本人亲自为大家制作的动图了（不信你看不懂）</code></p><p><img src="https://img-blog.csdnimg.cn/20200419221542948.gif#pic_center" alt="亲力亲为动图"><br>好啦，以上就是小码码的学习心得，希望对大家有帮助，喜欢的话就点赞，留言哦，哈哈。<br>附<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">小码码官方博客</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matery主题优化问题</title>
      <link href="/2020/0409/"/>
      <url>/2020/0409/</url>
      
        <content type="html"><![CDATA[<h1 id="matery主题优化时解析出bug"><a href="#matery主题优化时解析出bug" class="headerlink" title="matery主题优化时解析出bug"></a>matery主题优化时解析出bug</h1><ul><li><p>matery是个好的主题这个我就不详细地说了，但是优化也难</p></li><li><p>越好的主题、越丰富的主题，插件越多，配置越多，就容易出错</p></li><li><p>最要命的是这种静态网页的部署还要用最原始的方法进行，先在命令行生成静态文件，然后发送给要命的github</p></li><li><p>总之bug数不胜数，大部分出错的原因基本都一致，无非就是在yml文件里乱弄出的bug</p></li><li><p>但是我优化主题时碰上了难得的bug，就分享给大家，省的大家走弯路</p><h2 id="page-ForEach-is-not-a-function后接一大片路径"><a href="#page-ForEach-is-not-a-function后接一大片路径" class="headerlink" title="page.*.ForEach is not a function后接一大片路径"></a>page.*.ForEach is not a function后接一大片路径</h2></li></ul><p><img src="https://img-blog.csdnimg.cn/20200409184120112.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="page bug"><br>这里的*就是图中的categorioes,我叫他page bug。就光看那么多行根本摸不着头脑，想着是肯定是配置出了问题，于是就打开配置文件查看。其实这个问题很少见，一般都不是config配置文件的问题。弄了半天，谁也没想到是页面文件categorioes里的index.md文件有问题。我的配置如下：<br><img src="https://img-blog.csdnimg.cn/2020040918524995.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="index.md配置"><br>一般都很少进入里面配置什么的，但是为了优化主题，让它更好看，就进入里面瞎搞乱改，网上也没什么指导如何优化配置的好文章，所以自然会遇到稀奇bug。上面的配置就出错了，出在categorioes的属性的配置，用这个主题，categories文件(需要事先new一个才有)好像不准添加属性，换成小写c也不行，之后做了如下更改。</p><p><img src="https://img-blog.csdnimg.cn/20200409190637167.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="删除属性后"><br>去掉那个C后，那个bug就没了，一切顺畅生成页面。四不四很无语，就这个鬼东西弄了一整天，不是说，就是这个静态页面配置太苛刻了，用md和yml去写，缩进不对都是要出错的。这给广大怀着博客梦的IT客破了一大盆冷水，太难了！<img src="https://img-blog.csdnimg.cn/20200409202700413.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="🆗"></p><p>我还试了在其他页面文件中的md文件里设置categories属性，结果都🆗。。。</p><p><img src="https://img-blog.csdnimg.cn/20200409191736240.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="tags文件里md文件配置了没问题"><br>tags文件里md文件配置了没问题,我是说categorioes属性，图片里没有，配置tags属性也没事(没打双引号都没事)。</p><pre><code>那到底是什么样的优化造成的魔王级的bug呢？</code></pre><p>hexo主题本来就不会自带页面的配置优化，需要自己弄，就matery来说吧，除了归档页面，其他的页面都不会出现和用这个主题的人一样相似布局，所以接下来就告诉大家怎么弄。</p><pre><code>就是在index.md文件里配置，只需添加如下几行：在categories里：type: &#39;categories&#39;                layout: &#39;categories&#39;        (注意：后空格)其他类推</code></pre><p>这样在各个页面就有自己配置了，如下</p><p><img src="https://img-blog.csdnimg.cn/20200409195433492.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="配置了friendst页面"><br>这是弄好了友链页面后的效果，能看到基本上是有个排版了。但框框内却出现了乱码，很巧的是出现乱码的地方都是汉字该出现的地方。所以大家应该知道了，又是编码的问题。这次我们还用notepad++更改编码友链的josn格式,如果没有notepad++或不知道如何更改编码格式，请参考<a href="https://blog.csdn.net/Gobullin/article/details/105349236" target="_blank" rel="noopener">批处理文件编码出错</a>原来友链的josn的编码格式为Ansi,我们需要utf-8格式。欧克，行了，如下：<img src="https://img-blog.csdnimg.cn/20200409200717571.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="乱码解决"></p><h3 id="谈谈hexo"><a href="#谈谈hexo" class="headerlink" title="谈谈hexo"></a>谈谈hexo</h3><p>hexo这样的博客虽然用了很流行的框架，但部署起来还是很费劲，就是用上去很费劲，powerful的博客框架还是太少了，什么都追求免费服务，哪有这么样的好事，这就导致了开发出优质的框架的人太少了。现在大牛的程序员都快是古董，做个IT技术更倾向于商业化，应用型。以上就是分享，另附<a href="https://www.maliaoblog.cn" target="_blank" rel="noopener">个人博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> bug问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决执行批处理文件后出现的问题</title>
      <link href="/2020/0406/"/>
      <url>/2020/0406/</url>
      
        <content type="html"><![CDATA[<h1 id="执行批处理文件后出现的乱码问题"><a href="#执行批处理文件后出现的乱码问题" class="headerlink" title="执行批处理文件后出现的乱码问题"></a>执行批处理文件后出现的乱码问题</h1><p>用windows批处理总是很放便的，特便是在抢时间的情况下用批处理开启程序，运行大量命令等等。但对于刚接触的新手来说，可能是一件费劲的事！有时候还会遇到问题，比如今天要讲的执行批处理文件后出现的乱码问题。如下图：<br><img src="https://img-blog.csdnimg.cn/20200406190912897.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="批处理文件"><br>文件里的命令的意思就是在命令行输出“垃圾快跑”四个字，然后运行后如下</p><p><img src="https://img-blog.csdnimg.cn/20200406191232149.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="运行结果"><br>运行后出现的“致富喽”几个字。。。其实我也不知道是什么字。接着面对乱码的问题，大家想一想就明白估计是文件的编码格式出了问题，强调一下啊，是编码格式。在这里就要讲一个东西，就是windows的cmd命令行本身用的是Ansi编码，但用记事本打开或者说文件本身的编码其实不是Ansi编码，有可能是Utf-8。那这里就有两种解决方法。</p><h4 id="一、使用notepad-转换编码格式"><a href="#一、使用notepad-转换编码格式" class="headerlink" title="一、使用notepad++转换编码格式"></a>一、使用notepad++转换编码格式</h4><p> 既然要用到notepad++，相信大家应该不会陌生，notepad++功能强大，可以说比sublime text好用，这里之所以不推荐sublime text，是因为它没有编码格式的转换功能，甚至没有Ansi格式的编码，最后建议选择notepad++。考虑到有人没用过，下面就送上notepad++的网盘下载地址：<a href="https://pan.baidu.com/s/1Rz4RTcvTAktiXpQHY90kqQ" target="_blank" rel="noopener">notepad++下载</a>    提取码：xnl1</p><p> <img src="https://img-blog.csdnimg.cn/20200406193206198.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="notepad++"><br> notepad++支持多种语法高亮和编码及文件兼容，是程序哥的必备良器。打开notepad++后，默认为utf-8格式，点击文件，选择打开，选择你要打开的批处理文件，看到菜单栏的编码选项(已经很醒目了)，之后点击编码，选择转换为Ansi格式，再在文件选项中点击保存。</p><p> <img src="https://img-blog.csdnimg.cn/20200406194032449.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="Notepad++"><br> 在命令行后执行或直接点开批处理文件，解决乱码了</p><p> <img src="https://img-blog.csdnimg.cn/20200406194216646.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="二、另存为"><a href="#二、另存为" class="headerlink" title="二、另存为"></a>二、另存为</h4><p> 用记事本打开bat文件后，选择另存为，之后点击选择Ansi格式编码，同样能解决问题。<br> <img src="https://img-blog.csdnimg.cn/20200406202619497.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dvYnVsbGlu,size_16,color_FFFFFF,t_70#pic_center" alt="另存为">打开运行批处理文件后，就没出现过乱码啦。</p><p>以上就是解决类似问题的几个方法，可以的话就留言评论，希望大家多多留言哦。<br>另附：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">个人博客</a></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C语言实现链表</title>
      <link href="/2020/0405/"/>
      <url>/2020/0405/</url>
      
        <content type="html"><![CDATA[<h1 id="用C语言实现链表，附代码注释"><a href="#用C语言实现链表，附代码注释" class="headerlink" title="用C语言实现链表，附代码注释"></a>用C语言实现链表，附代码注释</h1><p>这里给已经在学C和数据结构的小伙伴提供一些弹药支持，虽然不知道管不管用，在这里大佬就勿扰了吧！哈哈！</p><p>在实现一个简单的链表前需要用到哪些知识点呢？</p><ul><li>C语言基础知识，比如要用到的结构体、指针、函数、运算</li><li>一点数据结构的知识，在学习数据结构也能看到链表的身影，我们这里实现的是单项链表</li><li>有手，有脑</li></ul><p>现在上代码：</p><pre><code># include&lt;stdio.h&gt;# include&lt;malloc.h&gt;//创造链表 //定义一个节点类型typedef struct node{    int data;    char name[10];    struct node *next;}noDe,* pnoDe; // 输入函数 pnoDe funkin(void){     pnoDe pHead = (pnoDe)malloc(sizeof(noDe));    //定义头指针和尾指针分别指向头和尾节点      pnoDe ptail = pHead;    ptail-&gt;next = NULL;    int n,score;    //有效节点的数量      char name[10];        printf(&quot;please funkin a number:&quot;);    scanf(&quot;%d&quot;,&amp;n);             // 连续输入学生及成绩数据     for(int i=0;i&lt;n;i++){        pnoDe pNew = (pnoDe)malloc(sizeof(noDe));        printf(&quot;please scanf the score of number %d :&quot;,i+1);        scanf(&quot;%d %s&quot;,&amp;(pNew-&gt;data),pNew-&gt;name);        /*核心代码*/        ptail-&gt;next = pNew;       //让尾节点指针指向新节点         ptail = pNew;    //让尾指针指向新节点 ,并移动到下一个节点         ptail-&gt;next = NULL;    //让新节点指针域为空     }        return pHead;} // 输出函数 void out(pnoDe pHead){    int k = 1;    pnoDe p = pHead-&gt;next;    while(p != NULL){        printf(&quot;\nfunkout number %d: &quot;,k);        printf(&quot;score= %d\nname= %s\n&quot;,p-&gt;data,p-&gt;name);        p = p-&gt;next;        k++;    }    return;}int main(void){    pnoDe pHead = NULL;    pHead = funkin();    out(pHead);    return 0;    } </code></pre><p>代码并不难懂，大概就是先输入需要创建的节点数或有效数据个数，之后创建了一个会构造链表的函数，并返回头指针。这个时候链表其实已经创建好了，并且已经放入了数据。之后，输出函数out()会输出数据。ok，就是这么简单！觉得可以就点赞加关注，博主会定期更新哦！哈！最后附上个人博客链接：<a href="https://blog.csdn.net/Gobullin" target="_blank" rel="noopener">csdn博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致访客</title>
      <link href="/2020/0327/"/>
      <url>/2020/0327/</url>
      
        <content type="html"><![CDATA[<p>这是经过多天努力的结果，这个站点就界面来说，不怎么酷炫。但是是我一直想做的东西–建一个与众不同的个人网站，每天可以像发微博一样自由地推送我写好的博客文章。对于<a href="http://www.maliaoblog.cn，我很珍惜能拥有它，还是经过自己的不断尝试，一点一点地做出来的，就如心血的结晶。" target="_blank" rel="noopener">www.maliaoblog.cn，我很珍惜能拥有它，还是经过自己的不断尝试，一点一点地做出来的，就如心血的结晶。</a></p><h1 id="来访"><a href="#来访" class="headerlink" title="来访"></a>来访</h1><pre><code>I&#39;m so proud for your visit!我想说，感谢你能来见证我博客的诞生，正因为有你的加入，才能有我的博客的成长。以后大家可以通过我的博客官网看到我最新的动态，我会在这个站点和你面对面。</code></pre><h1 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h1><p>博客会不定期更新，我会不断的努力写出好的文章作品。</p><h1 id="为什么叫码力奥"><a href="#为什么叫码力奥" class="headerlink" title="为什么叫码力奥"></a>为什么叫码力奥</h1><pre><code>可能因为马里奥比较出名吧！作为产码达人，一定要起一个好名字。</code></pre><h1 id="以后站点会变换吗？"><a href="#以后站点会变换吗？" class="headerlink" title="以后站点会变换吗？"></a>以后站点会变换吗？</h1><pre><code>可能吧！但现在算是比较稳定了，起初，我想在站点加入更多功能插件，可是条件限制各方面因素，就只能到这！另外博客的站点是建在外网的，所以访问比较慢！这里就体谅一下吧！一个人建站比较幸苦的。</code></pre><h1 id="加油！"><a href="#加油！" class="headerlink" title="加油！"></a>加油！</h1><pre><code>毕竟建站不是我最终的想法，想着继续努力地学习成长，以后拥有更加幸福的生活。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客简介 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
